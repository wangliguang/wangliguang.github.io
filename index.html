<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Robot Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="说不定世界上根本就没有偶然，就如一切都是必然那样">
<meta property="og:type" content="website">
<meta property="og:title" content="广广的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="广广的技术博客">
<meta property="og:description" content="说不定世界上根本就没有偶然，就如一切都是必然那样">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="广广的技术博客">
<meta name="twitter:description" content="说不定世界上根本就没有偶然，就如一切都是必然那样">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> 广广的技术博客 - 说不定世界上根本就没有偶然，就如一切都是必然那样 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">广广的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">说不定世界上根本就没有偶然，就如一切都是必然那样</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/15年-年终总结/" itemprop="url">
                  15年 年终总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T16:49:19+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/年终总结/" itemprop="url" rel="index">
                    <span itemprop="name">年终总结</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/15年-年终总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/15年-年终总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="经常强调课程的重点"><a href="#经常强调课程的重点" class="headerlink" title="经常强调课程的重点"></a>经常强调课程的重点</h1><p>将本节课学生必须掌握的内容，写出来，要不断的跟学生强调。</p>
<h1 id="知识点的背景介绍要详细"><a href="#知识点的背景介绍要详细" class="headerlink" title="知识点的背景介绍要详细"></a>知识点的背景介绍要详细</h1><p>以前有些疏忽了，知道知识点的来源，让学生对这个东西有更多的熟悉感。</p>
<h1 id="3W1H"><a href="#3W1H" class="headerlink" title="3W1H"></a>3W1H</h1><p>之前总想将3W1H嵌入到课程中，让学生慢慢体会。但由于授课经验少，目前还不能引导学生灵活自如的切换。所以目前需要在课程中明确的提到3W1H，慢慢的进行转变。</p>
<h1 id="技术的提升"><a href="#技术的提升" class="headerlink" title="技术的提升"></a>技术的提升</h1><p>swift</p>
<p>iOS 热门效果</p>
<p>H5</p>
<h1 id="学生分享"><a href="#学生分享" class="headerlink" title="学生分享"></a>学生分享</h1><p>让学生养成博客分享的好习惯。<br>明日一词</p>
<h1 id="培养理念"><a href="#培养理念" class="headerlink" title="培养理念"></a>培养理念</h1><ul>
<li>规范学生的代码规范，并让他们认真对待写的每一句代码  </li>
<li>不能哄孩子式教育</li>
<li>培养学生自学能力</li>
</ul>
<h1 id="课前引导"><a href="#课前引导" class="headerlink" title="课前引导"></a>课前引导</h1><p>提前将今天学的东西，写成一个小demo给学生演示。用于提升学生的兴趣</p>
<h1 id="王云老师培训"><a href="#王云老师培训" class="headerlink" title="王云老师培训"></a>王云老师培训</h1><ul>
<li>前期靠哄,玩技术是大忌，主要是提升学生兴趣</li>
<li>当前学的内容跟工作的相关联</li>
<li>经常回顾当前所学的内容</li>
<li>经常刺激学生</li>
<li>反复提到今天将的内容，集中注意力 </li>
<li>分步骤化(先告诉学生有几步，让学生时刻都知道自己到哪一步了)</li>
<li>先快速灌入整体，然后慢慢细化。</li>
<li>记不住，重复度不够</li>
</ul>
<h1 id="IT讲师条件"><a href="#IT讲师条件" class="headerlink" title="IT讲师条件"></a>IT讲师条件</h1><p>熟练的理论知识<br>相关的项目经验<br>语言能力<br>授课技巧<br>责任心、激情、耐心</p>
<h1 id="好讲师条件"><a href="#好讲师条件" class="headerlink" title="好讲师条件"></a>好讲师条件</h1><ul>
<li>清晰的授课目标和思路</li>
<li>引人入胜的讲解</li>
<li>恰到好处的提问</li>
<li>丰富多彩的案列</li>
<li>简明扼要的总结归纳</li>
<li>活跃的课堂气氛</li>
</ul>
<h1 id="3W1H-1"><a href="#3W1H-1" class="headerlink" title="3W1H"></a>3W1H</h1><ul>
<li>利用3W1H其实更重要的是在不断的告诉自己当前自己讲的是什么。</li>
</ul>
<h1 id="魏老师"><a href="#魏老师" class="headerlink" title="魏老师"></a>魏老师</h1><ul>
<li>印象笔记-形成自己的知识库</li>
<li>sublime text 课堂形成笔记</li>
<li>高级编程放在B段项目中</li>
<li>项目驱动</li>
<li>直播</li>
<li>摸透课程体系</li>
</ul>
<h1 id="课程优势"><a href="#课程优势" class="headerlink" title="课程优势"></a>课程优势</h1><ol>
<li>学习模块搭配合理、循序渐进、易掌握</li>
<li>课程内容设计精炼</li>
<li>紧贴企业一线需求 </li>
<li>商业项目驱动教学 </li>
<li>业界大牛直播课（H5、php、产品经理、swift编程） </li>
<li>培养全栈工程师（一专多通人才）</li>
<li>写代码+新知识能力+读代码+解决问题</li>
</ol>
<h1 id="学生引导"><a href="#学生引导" class="headerlink" title="学生引导"></a>学生引导</h1><ol>
<li>不用高薪，职业规划引导</li>
<li>学术严谨，用心实在的付出</li>
<li>行业引导，</li>
</ol>
<h1 id="讲师接班准备的资料"><a href="#讲师接班准备的资料" class="headerlink" title="讲师接班准备的资料"></a>讲师接班准备的资料</h1><ol>
<li>学生基本信息表</li>
<li>考试成绩表</li>
<li>讲师每月测评数据</li>
<li>项目答辩数据</li>
<li>学生出勤表</li>
<li>学生就业数据</li>
<li>每个班级A段、B段项目存档</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>每天分享一个互联网名词</li>
<li>课前将今天学习的内容写成一个demo</li>
<li>尽量介绍一下知识点的背景故事</li>
<li>3W1H写博客和讲课</li>
<li>整理出来今天学生必须要会的几个知识点，在授课过程中不断的重复</li>
<li>将今天将的内容明确的分步骤化</li>
<li>当前学的内容跟工作的关联</li>
<li>课堂内容尽量提前写成PPT或者博客</li>
<li>在授课过程中告知告知怎么找到关键问题所在</li>
<li>有些东西底层原理没必要讲很深，只要让他们理解这个过程就行。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/沙盒路径查找/" itemprop="url">
                  沙盒路径查找
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T16:42:32+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/沙盒路径查找/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/沙盒路径查找/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>默认情况下，每个沙盒含有3个文件夹：Documents, Library 和 tmp。</p>
</blockquote>
<ol>
<li><p><strong>Documents</strong>：苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下，iTunes备份和恢复的时候会包括此目录 </p>
</li>
<li><p><strong>Library</strong>：存储程序的默认设置或其它状态信息，里面还有一个二级目录<strong>Library/Caches</strong>：存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出删除</p>
</li>
<li><p><strong>tmp</strong>：提供一个即时创建临时文件的地方，此目录下文件可能会在应用退出后删除</p>
</li>
<li><p>iTunes在与iPhone同步时，备份所有的Documents和Library文件。<br>iPhone在重启时，会丢弃所有的tmp文件。</p>
</li>
</ol>
<h1 id="路径查找格式"><a href="#路径查找格式" class="headerlink" title="路径查找格式"></a>路径查找格式</h1><p>  比如我要查找，数据所在缓存的绝对路径,也就是Library下的Caches目录</p>
<pre><code>/*
  *  方法NSSearchPathForDirectoriesInDomains用于返回指定范围内的指定名称的目录的路径集合。有三个参数：

  * 第一个参数：directoryNSSearchPathDirectory类型的enum值，表明我们要搜索的目录名称，

  * 第二个参数：domainMaskNSSearchPathDomainMask类型的enum值，指定搜索范围

  * 第三个参数：expandTildeBOOL值，表示是否展开波浪线~。我们知道在iOS中~的全写形式是/User/userName，该值为YES即表示写成全写形式，为NO就表示直接写成“~”。

  */
  NSString *libraryCachesPath=[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];

 第一个参数可能的枚举值，也就是想要查找的目录：
 typedef NS_ENUM(NSUInteger, NSSearchPathDirectory) {

 // 到applications (Applications)目录下
 NSApplicationDirectory = 1,

 // 到Applications/Demos目录下
 NSDemoApplicationDirectory,

 // 到Developer/Applications目录下.
 NSDeveloperApplicationDirectory,

 // 到Applications/Utilities目录下
 NSAdminApplicationDirectory,

 // 到Library目录下
 NSLibraryDirectory,

 // 到Developer目录下.
 NSDeveloperDirectory,

 // 到用户的主目录下
 NSUserDirectory,

 // 到documentation (Documentation)的目录下
 NSDocumentationDirectory,

 // 到documents (Documents)目录下
 NSDocumentDirectory,

 // CoreServices目录的位置 (System/Library/CoreServices)
 NSCoreServiceDirectory,

 // 自动保存的文档位置 (Documents/Autosaved)
 NSAutosavedInformationDirectory 

 // 本地用户的桌面
 NSDesktopDirectory = 12,

 // 本地缓冲区目录(Library/Caches)
 NSCachesDirectory = 13,

 // 本地应用支持文件目录 (plug-ins, etc) (Library/Application Support)
 NSApplicationSupportDirectory = 14,

 // 本地下载downloads目录
 NSDownloadsDirectory 

 //输入方法目录 (Library/Input Methods)
 NSInputMethodsDirectory 

 // 电影目录 (~/Movies)
 NSMoviesDirectory 

 // 音乐目录 (~/Music)
 NSMusicDirectory 

 // 图片目录 (~/Pictures)
 NSPicturesDirectory

 // 本地用户分享目录 (~/Public)
 NSSharedPublicDirectory 

 };

 第二个参数可能的枚举值，查找的区域
 typedef NS_OPTIONS(NSUInteger,        NSSearchPathDomainMask) {

  // 用户的主目录
  NSUserDomainMask = 1,

  // 当前机器的本地目录
  NSLocalDomainMask = 2,

  // 在网络中公开可用的位置
  NSNetworkDomainMask = 4,

  // 被苹果系统提供的，不可更改的位置 (/System)
  NSSystemDomainMask = 8,

  // 上述所有及未来的位置
  NSAllDomainsMask = 0x0ffff
 };

补充：
  //获取应用程序的沙盒目录
  NSString*homePtah =NSHomeDirectory()

未完，待续。。。。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/FMDB/" itemprop="url">
                  FMDB
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T16:36:47+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/FMDB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/FMDB/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><p>SQLite (<a href="http://www.sqlite.org/docs.html" target="_blank" rel="external">http://www.sqlite.org/docs.html</a>) 是一个轻量级的关系数据库。iOS SDK 很早就支持了 SQLite，在使用时，只需要加入 libsqlite3.dylib 依赖以及引入 sqlite3.h 头文件即可。但是，原生的 SQLite API 在使用上相当不友好，在使用时，非常不便。于是，开源社区中就出现了一系列将 SQLite API 进行封装的库，而 FMDB (<a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">https://github.com/ccgus/fmdb</a>) 则是开源社区中的优秀者。FMDB 同时兼容 ARC 和非 ARC 工程，会自动根据工程配置来调整相关的内存管理代码。而且他提供了多线程安全的数据库操作方法，有效地防止数据混乱。</p>
</li>
<li><p>FMDB是将sqlite封装处理的，所以使用FMDB之前也必须导入libsqlite3.dylib框架。</p>
</li>
<li><p>FMDB常用类</p>
<ul>
<li><p>FMDatabase ：          一个单一的SQLite数据库，用于执行SQL语句。</p>
</li>
<li><p>FMResultSet ：          执行查询一个FMDatabase结果集。    </p>
</li>
<li><p>FMDatabaseQueue ：在多个线程来执行查询和更新时会使用这个类。</p>
</li>
</ul>
</li>
</ul>
<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><pre><code>NSString*path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)lastObject];

path = [path stringByAppendingString:@&quot;testDB.sqlite&quot;];

db = [FMDatabase databaseWithPath:path];  //指定路径创建一个数据库 dB是一个全局变量
</code></pre><p>   1、testDB.sqlite不存在，系统会在路径下自动创建一个数据库。若在该路径之前存在这样的数据库，不会重复创建。</p>
<p>2、如果path为@””,系统会在一个临时的目录（并不是沙盒中的temp文件，这个临时目录是系统自动分配的）自己创建一个数据库，数据库断开连接后会自动删除。</p>
<p>3、如果path为nil,系统会在内存中创建一个数据库，数据库会在关闭后被销毁。</p>
<h1 id="在数据库中建表"><a href="#在数据库中建表" class="headerlink" title="在数据库中建表"></a>在数据库中建表</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-300cdf320d643f39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>0、数据库操作前记得打开，操作结束后记得关闭</p>
<p>1、在FMDB中，除查询以外的所有操作，都称为“更新”。例如，create、drop、insert、update、delete等都采用executeUpdate来进行操作，select采用executeQuery操作。</p>
<p>2、executeUpdate方法返回一个BOOL值来表明是否操作成功。executeQuery方法返回一个FMResultSet(结果集),存放查询到的结果。</p>
<h1 id="在表中插入数据"><a href="#在表中插入数据" class="headerlink" title="在表中插入数据"></a>在表中插入数据</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-202f2ce52bc97e21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>1、？做占位符的话，传进来的值必须是对象类型。</p>
<p>2、FMDB的更新方法有很多，有兴趣的朋友可以都试试。</p>
<ul>
<li><p>(BOOL)executeUpdate:(NSString*)sql, …</p>
</li>
<li><p>(BOOL)executeUpdateWithFormat:(NSString*)format, …</p>
</li>
<li><p>(BOOL)executeUpdate:(NSString<em>)sql withArgumentsInArray:(NSArray </em>)arguments</p>
</li>
</ul>
<p>3、sqlite的增删改(没有查)，跟上面的格式其实都是一样的。唯一的不同的就是sqlite语句。sqlite语句不会写的直接百度搜索即可。</p>
<h1 id="在表中查询数据"><a href="#在表中查询数据" class="headerlink" title="在表中查询数据"></a>在表中查询数据</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-38055686d315ea9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>1、FMResultSet提供了很多方法来获得所需的格式的值:stringForColumn  doubleForColumn boolForColumn等。不仅能通过列名来取数据，还能通过列的下标取数据。</p>
<p>2、FMDB的查询方法也有很多，同样可以试试</p>
<ul>
<li><p>(FMResultSet <em>)executeQuery:(NSString</em>)sql, …</p>
</li>
<li><p>(FMResultSet <em>)executeQueryWithFormat:(NSString</em>)format, …</p>
</li>
<li><p>(FMResultSet <em>)executeQuery:(NSString </em>)sql withArgumentsInArray:(NSArray *)arguments</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/C语言操作SQLite/" itemprop="url">
                  C语言操作SQLite
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T16:29:01+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/C语言操作SQLite/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/C语言操作SQLite/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SQLite介绍"><a href="#SQLite介绍" class="headerlink" title="SQLite介绍"></a>SQLite介绍</h1><p>SQLite，是一款轻型的数据库(按照数据结构来组织、存储和管理数据的仓库)，是遵守ACID的关系型数据库管理系统，它的设计目标是嵌入式的，而且目前已经在很多嵌入式产品中使用了它，它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了。</p>
<h1 id="打开OR创建数据库"><a href="#打开OR创建数据库" class="headerlink" title="打开OR创建数据库"></a>打开OR创建数据库</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-cbe60e89c278d1cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>1、由于sqlite使用C语言写的，所以sqlite他不是一个对象，而只是一个指针变量而已。</p>
<p>2、每次打开都要将数据库和结果集置空，避免上次对数据库的操作影响当前的操作。</p>
<h1 id="关闭结果集和数据库"><a href="#关闭结果集和数据库" class="headerlink" title="关闭结果集和数据库"></a>关闭结果集和数据库</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-6c79d670d08796eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>1、每次操作之后都要关闭，避免内存泄露。</p>
<h1 id="在数据库中建表"><a href="#在数据库中建表" class="headerlink" title="在数据库中建表"></a>在数据库中建表</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-c9684c4db86369c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>0、SQLite语法不区分大小写,对数据库操作前打开数据库，操作结束后关闭数据库。</p>
<p>1、SQLite3支持 NULL、INTEGER、REAL（浮点数字）、TEXT(字符串文本)和BLOB(二进制对象)数据类型，但实际上sqlite3也接受varchar(n)、char(n)、decimal(p,s) 等数据类型，只不过在运算或保存时会转成对应的五种数据类型。</p>
<p>2、 SQLite最大的特点是你可以把各种类型的数据保存到任何字段中，而不用关心字段声明的数据类型是什么。例如：可以在Integer类型的字段中存放字符串，或者在布尔型字段中存放浮点数，或者在字符型字段中存放日期型值。 但有一种情况例外：定义为INTEGER PRIMARY KEY(PRIMARY KEY修饰表明这个字段是表的主键)的字段只能存储64位整数， 当向这种字段保存除整数以外的数据时，将会产生错误。</p>
<h1 id="在表中插入数据"><a href="#在表中插入数据" class="headerlink" title="在表中插入数据"></a>在表中插入数据</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-3128123474761be0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在表中插入数据<br>1、关于数据的删，改跟上面的插入的格式一样。只不过是sql语句不同而已。碰到不会写的sql语句，百度搜索即可。请原谅我的懒惰😄。</p>
<h1 id="在表中查询数据"><a href="#在表中查询数据" class="headerlink" title="在表中查询数据"></a>在表中查询数据</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-722c0854f3f3324d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>1、Command+左键SQLite_ROW,里面有很多的宏，sqlite_step返回的值，在那些宏里都有相应的解释。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/日期NSDate/" itemprop="url">
                  日期NSDate
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T16:19:17+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/日期NSDate/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/日期NSDate/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果没有做日历的需求。对日期经常用到的就是两个类NSDate(日期类)和NSDateFormatter(时间格式器)。NSDate的对象表示一个具体的时间点。使用NSDateFormatter对象将时间对象转化成字符串或者反转。</p>
<p>关于日期类还有NSTimeZone,NSDateComponents,NSCalendar等。有需要的可以在深入研究。有关于这些好的资料欢迎分享。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-30f3836aa8be7bfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="创建NSDate对象的几种方式以及区别"><a href="#创建NSDate对象的几种方式以及区别" class="headerlink" title="创建NSDate对象的几种方式以及区别"></a>创建NSDate对象的几种方式以及区别</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-74e276fe5e267ecb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>1、这上面的我用的都是类方法，用init方法也都可以的。例如：NSDate<em>date = [[NSDate alloc]init];和NSDate</em>date = [NSDatedate];是一样的。</p>
<p>2、如果你用的时间戳是后台给你传过来的话，要记得核查是否该时间戳是否乘以1000。根据情况来决定是否除以1000。如果乘以过1000,表明后台给你传过来的是毫秒。<br>NSDate对象常用的方法</p>
<h1 id="NSDate对象常用的方法"><a href="#NSDate对象常用的方法" class="headerlink" title="NSDate对象常用的方法"></a>NSDate对象常用的方法</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-60f1483f05f739c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>1、<a href="http://tool.chinaz.com/Tools/unixtime.aspx" target="_blank" rel="external">点击</a>进入时间戳在线转换工具。</p>
<h1 id="时间格式转化器NSDateFormatter"><a href="#时间格式转化器NSDateFormatter" class="headerlink" title="时间格式转化器NSDateFormatter"></a>时间格式转化器NSDateFormatter</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-9a81d42d818339d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>1、啥也不说了，感情都在图里。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/归档/" itemprop="url">
                  归档
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T16:12:03+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/归档/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/归档/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>归档：将对转序列化成二级制数据，并保存在文件中。</li>
<li><p>解归档：将归档后的数据反序列化成明码（能够看懂）对象，供我们使用。</p>
</li>
<li><p>说明：只有遵守了NSCoding或 NSSecureCoding（更为安全的归档协议,想要深入了解可以留下评论）协议,并且实现了协议里归档与解归档的方法的的类创建的对象才能够进行归档。</p>
<pre><code> //归档时会自动调用encodeWithCoder:(NSCoder *)aCoder
- (void)encodeWithCoder:(NSCoder *)aCoder

// 解归档的时候 会自动调用 initWithCoder:(NSCoder *)aDecoder
- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder
</code></pre></li>
</ul>
<hr>
<h1 id="将单个对象归档与解归档"><a href="#将单个对象归档与解归档" class="headerlink" title="将单个对象归档与解归档"></a>将单个对象归档与解归档</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-0ed0360e9ee38616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="将单个对象归档与解归档"></p>
<ol>
<li><p>看不懂是怎么找路径给path赋值的，请移步<a href="http://www.jianshu.com/p/2d9ca94b584d" target="_blank" rel="external">这里</a>查看。</p>
</li>
<li><p>采用archiveRootObject方法在同一路经下只能归档一个对象。但如果此时我想将我传进来的名字和年龄都归档，只需将这两个数据放到一个字典对象里。让后将字典给归档便可。将归档方法变为如下即可。</p>
<pre><code>- (void)archiverName:(NSString *)name WithAge:(NSNumber *)age {

  //[NSKeyedArchiver archiveRootObject:name toFile:path];

  //[NSKeyedArchiver archiveRootObject:age toFile:path];

  NSMutableDictionary *dict = [NSMutableDictionary dictionary];

  dict[@&quot;name&quot;] = name;
  dict[@&quot;age&quot;] = age;

  [NSKeyedArchiver archiveRootObject:dict toFile:path];

  //验证是否将字典给归档
  id content =  [NSKeyedUnarchiver unarchiveObjectWithFile:path];
 NSLog(@&quot;%@&quot;,content);
}
</code></pre></li>
</ol>
<h1 id="对自定义的类的单个对象创建的对象归档与解归档"><a href="#对自定义的类的单个对象创建的对象归档与解归档" class="headerlink" title="对自定义的类的单个对象创建的对象归档与解归档"></a>对自定义的类的单个对象创建的对象归档与解归档</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-3c160d48a7c706e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对自定义的类的单个对象创建的对象归档与解归档"></p>
<ol>
<li>Person是我自定义的一个类</li>
<li><p>在前言部分咱们说过只有遵守了NSCoding或NSSecureCoding（更为安全的归档协议,想要深入了解可以留下评论）协议,并且实现了协议里归档与解归档的方法的的类创建的对象才能够进行归档。</p>
<p>因此我们需要对Person类做以下操作。</p>
<ul>
<li>遵守NSCodeing协议（暂不考虑NSSecureCoding）</li>
<li>实现-(void)encodeWithCoder:(NSCoder *)aCoder;</li>
<li>实现-(nullable instancetype)initWithCoder:(NSCoder *)aDecoder;</li>
</ul>
</li>
</ol>
<h2 id="Person-h"><a href="#Person-h" class="headerlink" title="Person.h"></a>Person.h</h2><pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface Person : NSObject&lt;NSCoding&gt;

@property (nonatomic,copy) NSString *name;
@property (nonatomic,assign) NSInteger age;
@property (nonatomic,copy) NSString *sex;

@end
</code></pre><h2 id="Peroson-m"><a href="#Peroson-m" class="headerlink" title="Peroson.m"></a>Peroson.m</h2><pre><code>#import &quot;Person.h&quot;

@implementation Person

//被归档的时候会调用者方法，aCoder就是归档时传过来的归档对象
- (void)encodeWithCoder:(NSCoder *)aCoder{

    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];

    [aCoder encodeInteger:self.age forKey:@&quot;age&quot;];

    [aCoder encodeObject:self.sex forKey:@&quot;sex&quot;];

}

//解归档的时候会调用这个方法
  - (instancetype)initWithCoder:(NSCoder *)aDecoder{

      //解归档时会产生一个Person对象，这里是给这个Person对象赋值。

      self = [super init];

      if (self) {

        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];

        self.age = [aDecoder decodeIntegerForKey:@&quot;age&quot;];

        self.sex = [aDecoder decodeObjectForKey:@&quot;sex&quot;];

        }

        return self;
   }

@end
</code></pre><h1 id="同时将多个的对象归档与解归档"><a href="#同时将多个的对象归档与解归档" class="headerlink" title="同时将多个的对象归档与解归档"></a>同时将多个的对象归档与解归档</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-209968fac461b8ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同时将多个系统类创建的对象归档与解归档"></p>
<ol>
<li>你自己可以试试在这里也将自定义的Person类给归档。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/Cocoapods配置/" itemprop="url">
                  Cocoapods配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T16:03:33+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/Cocoapods配置/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/Cocoapods配置/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在iOS开发中势必会用到一些第三方依赖库，比如大家都熟悉的ASIHttpRequest、AFNetworking、JSONKit等。使用这些第三方类库能极大的方便项目的开发，但是，集成这些依赖库需要我们手动去配置，例如集成ASIHttpRequest库时除了加入源码以外还需要手动去添加一些系统框架，比如CFNetwork、MobileCoreServices等，如果这些第三方库发生了更新，还需要手动去更新项目。这就显得非常麻烦。有麻烦自然有解决办法，CocoaPods就是为了解决这个问题而生的。通过CocoaPods，我们可以将第三方的依赖库统一管理起来，配置和更新只需要通过简单的几行命令即可完成，大大的提高了实际开发中的工作效率，使我们的主要精力集中到更重要的事情上去。</p>
<h1 id="安装Cocoapods"><a href="#安装Cocoapods" class="headerlink" title="安装Cocoapods"></a>安装Cocoapods</h1><blockquote>
<p>mac系统自带ruby环境，网上有的教程是让你重新装svm,然后利用rvm再装ruby，注意区分。</p>
</blockquote>
<h2 id="将ruby的原生镜像移除"><a href="#将ruby的原生镜像移除" class="headerlink" title="将ruby的原生镜像移除"></a>将ruby的原生镜像移除</h2><pre><code>$ gem sources --remove https://rubygems.org/
</code></pre><h2 id="用淘宝的镜像代替"><a href="#用淘宝的镜像代替" class="headerlink" title="用淘宝的镜像代替"></a>用淘宝的镜像代替</h2><pre><code>这一步是因为国内有墙的限制，会造成安装cocoapods的过程变的十分慢，替换为淘宝的镜像速度会相对较快。
$ gem sources -a https://ruby.taobao.org/
</code></pre><h2 id="查看是否设置成功"><a href="#查看是否设置成功" class="headerlink" title="查看是否设置成功"></a>查看是否设置成功</h2><pre><code>$ gem sources -l

如果输出结果是如下这样，那说明这一步就成功了。
 *** CURRENT SOURCES ***
 http://ruby.taobao.org/
</code></pre><h2 id="安装Cocoapods-1"><a href="#安装Cocoapods-1" class="headerlink" title="安装Cocoapods"></a>安装Cocoapods</h2><pre><code>$ sudo gem install cocoapods
</code></pre><h2 id="查看Cocoapods是否支持某个类库，只要能够查询到框架就表明这个这台电脑Cocoapods已经安装成功。"><a href="#查看Cocoapods是否支持某个类库，只要能够查询到框架就表明这个这台电脑Cocoapods已经安装成功。" class="headerlink" title="查看Cocoapods是否支持某个类库，只要能够查询到框架就表明这个这台电脑Cocoapods已经安装成功。"></a>查看Cocoapods是否支持某个类库，只要能够查询到框架就表明这个这台电脑Cocoapods已经安装成功。</h2><pre><code>$ pod search 类库名
支持模糊查询(如:AFNetworking),如果下面显示出AFNetworking框架的各个版本就代表Cocoapods安装完成。
</code></pre><h2 id="可能碰到的问题"><a href="#可能碰到的问题" class="headerlink" title="可能碰到的问题"></a>可能碰到的问题</h2><p>1、ERROR:  While executing gem … (Errno::EACCES)    Permission denied - /Users/xxxxx/.gemrc</p>
<pre><code>可以用sudo chown -R xxxx /Users/xxxx/.gemrc解决
</code></pre><p>2、pod search 搜索库的时候报错Unable to find a specification for xxxxx</p>
<pre><code>解决方法：在终端执行这两句代码，然后重新安装pod,在进行搜索。
pod repo remove master  
pod setup
</code></pre><p>3、 安装的时候报错说selected xcode error<br>        解决方法:运行这句代码，然后重新安装</p>
<pre><code>sudo xcode-select -switch /Applications/Xcode.app/
</code></pre><p>–<br>Cocoapods相当于一款软件，在电脑上安装成功以后，以后就可以直接使用他来给项目集成框架。不需要重复上面的操作。</p>
<h1 id="在项目中如何使用Cocoapods"><a href="#在项目中如何使用Cocoapods" class="headerlink" title="在项目中如何使用Cocoapods"></a>在项目中如何使用Cocoapods</h1><p>　　我们通过集成MJRefresh类库来演示如何使用CocoaPods来做依赖库管理。首先，建立一个xcode工程，命名为CocoaPodsTest，现在的工程结构如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/1338564-e771007bf3c576ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正常新建工程结构图"></p>
<h2 id="检查MJRefresh是否支持Cocoapods-支持模糊查询"><a href="#检查MJRefresh是否支持Cocoapods-支持模糊查询" class="headerlink" title="检查MJRefresh是否支持Cocoapods,支持模糊查询"></a>检查MJRefresh是否支持Cocoapods,支持模糊查询</h2><pre><code>$ pod search mjrefresh
</code></pre><p>　　出现Setting up CocoaPods master repo，说明Cocoapods正在将它的信息下载到 ~/.cocoapods里，<strong>保持这个终端不动，新打开一个终端</strong>，cd到该目录里，用du -sh <em>命令来查看文件大小，每隔几分钟查看一次，我的这个目录最终大小是211M，就是完成了。如果不成功，在下面会显示一个git的网址，在这个网址下载相应的文件放在~/.cocoapods相应的文件夹便可。<br>　　<strong>执</strong>行后通过输出结果可以看到mjrefresh是支持CocoaPods的，注意红框标记的内容，这是待会我们配置xcode时需要的信息，这条配置项就是告诉CocoaPods去下载和管理第三方库的哪一个版本。*</em>   如果搜索过后最下面出现一个：,则直接点击q便可退出。<br><img src="http://upload-images.jianshu.io/upload_images/1338564-19797b3bc2e34241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MJRefresh库的把版本信息"></p>
<h2 id="检测完毕后我们在终端里来到工程CocoaPodsTest的目录下。"><a href="#检测完毕后我们在终端里来到工程CocoaPodsTest的目录下。" class="headerlink" title="检测完毕后我们在终端里来到工程CocoaPodsTest的目录下。"></a>检测完毕后我们在终端里来到工程CocoaPodsTest的目录下。</h2><pre><code>$ cd /Users/GG/Desktop/CocoaPodsTest  我这里是放在GG用户的桌面上了。你们需要改成你们自己的路径。
</code></pre><h2 id="管理第三方库的PodFile文件"><a href="#管理第三方库的PodFile文件" class="headerlink" title="管理第三方库的PodFile文件"></a>管理第三方库的PodFile文件</h2><pre><code>$ vim Podfile　
</code></pre><p>　　利用终端运行以上代码会在工程里打开一个名为Podfile（注意大小写）的文件。如果有这个文件会在终端中打开，如果没有这个文件会新建后打开。这个Podfile文件的作用是配置依赖库信息，就是告诉CocoaPods去下载和管理哪些依赖库。</p>
<h2 id="在文件里写入你想用的框架。"><a href="#在文件里写入你想用的框架。" class="headerlink" title="在文件里写入你想用的框架。"></a>在文件里写入你想用的框架。</h2><p>　　文件创建好以后，需要写的内容就是在上图中的红圈表示的信息。版本号可以根据自己的需求改变。vim打开文件后按i进入插入模式，编辑完成后按esc退出编辑模式，接着输入:wq保存并退出文件。保存以后可以在C文件夹里验证一下是否有Cocoapods这个文件。下图中我写了好几个框架。<br> <img src="http://upload-images.jianshu.io/upload_images/1338564-f218bd8bfe9d7155.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在Podfile文件里写入你想用的框架"></p>
<h2 id="将第三方库集成到项目中"><a href="#将第三方库集成到项目中" class="headerlink" title="将第三方库集成到项目中"></a>将第三方库集成到项目中</h2><p>　　如果之前的全部工作都完成了，工程目录下就会有一个Podfile文件了，注意必须和.xcodeproj在同一个目录下。接下来就可以使用CocoaPods来安装并管理JSONKit库了，首先确保终端当前路径是在CocoaPodsTest目录下。</p>
<pre><code>$ pwd   可以查看当前终端所处的路径。
</code></pre><p>路径没有问题后运行</p>
<pre><code>$ pod install  将Podfile文件中的第三方库集成在项目中。
</code></pre><p>安装结束以后会有如下提示</p>
<pre><code>Analyzing dependencies
Downloading dependencies
Installing MJRefresh (3.0.8)
Generating Pods project
Integrating client project

[!] Please close any current Xcode sessions and use     `CocoaPodsTest.xcworkspace` for this project from now on.
Sending stats
Pod installation complete! There is 1 dependency from the Podfile and 1 total
pod installed.
</code></pre><p>最重要的是这句话：</p>
<pre><code>请关闭Xcode，从此使用CocoapodsTest.xcworkspace打开项目
Please close any current Xcode sessions and use     `CocoaPodsTest.xcworkspace` for this project from now on. 
</code></pre><h2 id="通过xcoworkspace打开项目"><a href="#通过xcoworkspace打开项目" class="headerlink" title="通过xcoworkspace打开项目"></a>通过xcoworkspace打开项目</h2><p><img src="http://upload-images.jianshu.io/upload_images/1338564-59b24a5f8156aa11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过xcoworkspace打开项目的目录结果"></p>
<p>会多出一个名为Pods的依赖工程，打开/Pods/Pods文件夹后，能找到我们在Podfile写的各种第三方库。</p>
<h2 id="至此用Cocoapods管理第三方框架的所有工作做完。"><a href="#至此用Cocoapods管理第三方框架的所有工作做完。" class="headerlink" title="至此用Cocoapods管理第三方框架的所有工作做完。"></a>至此用Cocoapods管理第三方框架的所有工作做完。</h2><p>　　如果需要依赖多个第三方类库，只需要修改Podfile文件的配置，然后运行pod update命令即可，比如新增一个AFNetworking的依赖库，首先执行pod search AFNetworking查看一下AFNetworking的配置信息，修改Podfile文件，在后面增加AFNetworking的对应配置信息，然后运行pod update命令就完成了对AFNetworking的集成。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/Block/" itemprop="url">
                  Block
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T15:55:45+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/Block/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/Block/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>block是一个从iOS4后开始引入的代码块语法，能够代替代理来实现反向传值。接下来我将从以下几个方面介绍block,帮助大家一点一点揭开block的神秘面纱。</p>
<ul>
<li><p>block基础 </p>
</li>
<li><p>block作为参数</p>
</li>
<li><p>block和delegate</p>
</li>
<li><p>block的内存管理</p>
</li>
</ul>
<hr>
<h1 id="block基础"><a href="#block基础" class="headerlink" title="block基础"></a>block基础</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-2ec0b58c7856882b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="声明block"></p>
<p>1、返回值类型可以是nil，block名字随意，参数只需数据类型就可，多个参数用逗号隔开。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-0964b465896f0680.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现block"></p>
<p>1、因为我在定义oneFrom这个block的时候，设置了一个返回值，所以我实现这个block的时候需要return一下。</p>
<p>2、我在这里写的是加法运算，如果我想做其他运算，我只需要修改一下这个block块便可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-ba1994d8990bdbf2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用block"></p>
<p>1、oneFrame这个block在声明时设置什么类型的返回值就要用什么来接收。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-2f8c4fe250cde147.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="block基础用法总结"></p>
<h1 id="block作为参数"><a href="#block作为参数" class="headerlink" title="block作为参数"></a>block作为参数</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p><img src="http://upload-images.jianshu.io/upload_images/1338564-d14b346695ca3a3d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="将block作为参数的方式1"></p>
<p>1、 在blockParameterTwo的参数里我直接声明了一个无返回值无参数的block。<br>如果想要设置有参数有返回值的，按照如下声明便可。</p>
<pre><code>- (void)blockParameterTwo:(int (^)(int a,int b))clickView
</code></pre><p>2、当我点击屏幕时，调用blockParameterTwo的同时会将我的代码块也给传入到该方法中。最终在这个方法中调用我的传入的block,才会执行我调用该方法时设置的代码块。</p>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p><img src="http://upload-images.jianshu.io/upload_images/1338564-6dea73364eb1e3b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过typedef将block转会为一种数据类型使用"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-a780814ac7f071cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过步骤1创建的block数据类型申明一个对象"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-6d2385ff6957b2ea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现一个带block参数的方法"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-461448cdf35c6171.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用第三步实现的方法"></p>
<p>1、通过第二种方式，能够方便的同时声明多个同样的block。</p>
<h1 id="block与代理"><a href="#block与代理" class="headerlink" title="block与代理"></a>block与代理</h1><blockquote>
<p>我分别采用delegate和block两种方式自定义一个能够被点击的label</p>
<p>DelegateTapLabel: 采用代理来监听Label的点击事件(代理的具体实现方式，在这里我就不写了,在我给的demo已经写好)</p>
<p>BlockTapLabel:采用block来监听Label的点击事件</p>
</blockquote>
<p>BlockTapLabel.h</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-092edf99c80f5eff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BlockTapLabel.h"></p>
<p>1、我这里声明的是无参无返回值的一个block</p>
<p>BlockTapLabel.m<br><img src="http://upload-images.jianshu.io/upload_images/1338564-a3ce98f80429a16a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BlockTapLabel.m"></p>
<p>使用这个能点击的label</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-ca04b8ba22be2dd3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用这个能点击的label"></p>
<p>1、使用block来实现反向传值，不用遵守协议不用挂代理，不用再去实现代理方法。</p>
<h1 id="block的内存管理"><a href="#block的内存管理" class="headerlink" title="block的内存管理"></a>block的内存管理</h1><p><img src="http://upload-images.jianshu.io/upload_images/1338564-cf47a585b0c65ca5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="block的内存管理"></p>
<p>1、建议自己可以试试如果把<strong>__</strong>block修饰去掉或者不对self做处理会报什么样的错误。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/响应式编程RAC/" itemprop="url">
                  响应式编程RAC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T15:48:52+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/响应式编程RAC/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/响应式编程RAC/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ReactiveCocoa是什么"><a href="#ReactiveCocoa是什么" class="headerlink" title="ReactiveCocoa是什么"></a>ReactiveCocoa是什么</h1><ul>
<li><p>ReactiveCocoa（简称为<code>RAC</code>）,响应式框架,是由Github开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。</p>
</li>
<li><p>在我们iOS开发过程中，经常会响应某些事件来处理某些业务逻辑，例如按钮的点击，上下拉刷新，网络请求，属性的变化（通过KVO）或者用户位置的变化（通过CoreLocation）。但是这些事件都用不同的方式来处理，比如action、delegate、KVO、callback(回调)等。  </p>
</li>
<li><p>其实这些事件，都可以通过RAC处理，ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中<code>高聚合，低耦合</code>的思想。</p>
</li>
</ul>
<h1 id="这个框架能为我们带来什么样的便利"><a href="#这个框架能为我们带来什么样的便利" class="headerlink" title="这个框架能为我们带来什么样的便利"></a>这个框架能为我们带来什么样的便利</h1><ul>
<li>能使业务逻辑变得更加清晰</li>
<li>大量减少开发代码量</li>
<li>大量使用block块</li>
</ul>
<h1 id="什么时候能用到这个RAC呢"><a href="#什么时候能用到这个RAC呢" class="headerlink" title="什么时候能用到这个RAC呢"></a>什么时候能用到这个RAC呢</h1><ol>
<li><p>当你需要用到代理的时候开始使用它。例如用RAC检测textfiled的实时输入，不需要繁琐的遵守协议、挂代理、实现方法</p>
</li>
<li><p>涉及到点击事件的时候可以用，不需要再addtarget及实现方法。</p>
</li>
<li>还有通知、KVO、回调等。</li>
</ol>
<h1 id="具体怎么使用"><a href="#具体怎么使用" class="headerlink" title="具体怎么使用"></a>具体怎么使用</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><p>创建一个新项目，使用<a href="http://www.jianshu.com/p/24e0a451bca1" target="_blank" rel="external">Cocoapods</a>在项目中导入该框架。将下面的代码复制到Podfile文件然后更新。</p>
<pre><code>use_frameworks!
pod &apos;ReactiveCocoa&apos;, &apos;~&gt; 4.0.4-alpha-4&apos;
</code></pre><p>PS：因为这个框架是采用Swift和OC混编的，所以在Podfile文件的最上面要写上use_frameworks</p>
</li>
<li><p>建pch文件，在pch文件中导入该框架。</p>
<pre><code>#import &quot;ReactiveCocoa.h&quot;
</code></pre></li>
<li><p>利用这个框架实现下面需求，来具体说明他该如何使用。</p>
<ul>
<li>两个输入框内都有内容时，下面的按钮是红色。</li>
<li>两个输入框内都没内容时，下面的按钮是灰色。</li>
</ul>
</li>
<li><p>将下面代码粘贴到项目中的ViewController.m中。</p>
<pre><code>#import &quot;ViewController.h&quot;

#define kMargin 100
#define kScreenWidth [UIScreen mainScreen].bounds.size.width
#define kScreenheight [UIScreen mainScreen].bounds.size.height

@interface ViewController ()

@property (nonatomic,strong) UITextField *passwordTextFiled;

@property (nonatomic,strong) UITextField *accountTextFiled;

@property (nonatomic,strong) UIButton *OKBtn;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    //账号输入框
    self.accountTextFiled = [[UITextField alloc]initWithFrame:CGRectMake(kMargin, kMargin, kScreenWidth-kMargin*2, 50)];
    self.accountTextFiled.placeholder = @&quot;账号&quot;;
    self.accountTextFiled.layer.masksToBounds = YES;
    self.accountTextFiled.layer.cornerRadius = 5;
    self.accountTextFiled.textAlignment = NSTextAlignmentCenter;
    self.accountTextFiled.backgroundColor = [UIColor grayColor];
    [self.view addSubview:self.accountTextFiled];

    //密码输入框
    self.passwordTextFiled = [[UITextField alloc]initWithFrame:CGRectMake(kMargin, kMargin*2, kScreenWidth-kMargin*2, 50)];
    self.passwordTextFiled.backgroundColor = [UIColor grayColor];
    self.passwordTextFiled.placeholder = @&quot;密码&quot;;
    self.passwordTextFiled.textAlignment = NSTextAlignmentCenter;
    self.passwordTextFiled.layer.masksToBounds = YES;
    self.passwordTextFiled.layer.cornerRadius = 5;

    [self.view addSubview:self.passwordTextFiled];

    //确定按钮
    self.OKBtn = [UIButton buttonWithType:UIButtonTypeCustom];
    self.OKBtn.frame = CGRectMake((kScreenWidth-150)/2, kMargin*3, 150, 50);
    self.OKBtn.backgroundColor = [UIColor grayColor];
    [self.view addSubview:self.OKBtn];
    self.OKBtn.layer.masksToBounds = YES;
    self.OKBtn.layer.cornerRadius = 5;
    [self.OKBtn setTitle:@&quot;登录&quot; forState:UIControlStateNormal];

}

@end
</code></pre></li>
</ol>
<p>运行显示如下图：<br> <img src="http://upload-images.jianshu.io/upload_images/1338564-1e6e2436dce366cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p>
<h2 id="不适用RAC来实现上面的需求-不写具体代码了，只写一些过程"><a href="#不适用RAC来实现上面的需求-不写具体代码了，只写一些过程" class="headerlink" title="不适用RAC来实现上面的需求(不写具体代码了，只写一些过程)"></a>不适用RAC来实现上面的需求(不写具体代码了，只写一些过程)</h2><p>1、遵守协议<br>2、挂代理<br>3、实现相应的代理方法<br>4、在方法内写业务逻辑</p>
<h2 id="使用RAC来实现该业务逻辑"><a href="#使用RAC来实现该业务逻辑" class="headerlink" title="使用RAC来实现该业务逻辑"></a>使用RAC来实现该业务逻辑</h2><p><img src="http://upload-images.jianshu.io/upload_images/1338564-1984290c516ae19a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ol>
<li>将上面方法写入ViewController.m中。上面的RAC()其实就是一个宏定义</li>
<li>之前咱们说过RAC能帮助我们大量的减少代码而且逻辑更加清晰，在这里我们不需要在.m中找遵守协议的地方，不需要找控件挂代理，不需要去实现方法。</li>
</ol>
<h2 id="RAC的深入学习"><a href="#RAC的深入学习" class="headerlink" title="RAC的深入学习"></a>RAC的深入学习</h2><p>1、 使用RAC给按钮添加事件</p>
<pre><code>//老办法，还要实现clickBtn方法
[self.OKBtn addTarget:self action:@selector(clickBtn) forControlEvents:UIControlEventTouchUpInside];

//rac方法
[[self.OKBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {

NSLog(@&quot;OK按钮被点击&quot;);

}];
</code></pre><ul>
<li>通过rac_signalForControlEvents给按钮创建一个信号流，然后给这个信号指定一个subscribeNext(订阅者)。如果这个信号流的状态发生改变，订阅者便会受到他的改变。不仅仅button可以，segmentcontrol也同样可以。这样操作。</li>
<li>订阅者受到信息以后的操作都在block中操作。block返回来的参数(id x)其实就是用户所点击的按钮。程序员可以直接将（id x）改为（UIButton *sender）。</li>
<li><p>在找subcribeNext时，会看到这么一个方法</p>
<pre><code>subscribeNext:nil error:nil completed:nil];
</code></pre><p>第一个参数咱已经说过了，另外事件处理有问题会回调这个error这个block块，点击事件执行完毕以后会调用completed这个block块。</p>
</li>
</ul>
<p>2、使用RAC监听TextFiled的输入变化</p>
<pre><code>[self.accountTextFiled.rac_textSignal subscribeNext:^(id x) {

 NSLog(@&quot;%@&quot;,x);

}];
</code></pre><ul>
<li>self.accountTextFiled.rac_textSignal获得到textfiled的信号流。然后给这个信号指定一个（subscribeNext）订阅者。</li>
<li>subscribeNext:^(id x)如果输入框发生变化，订阅者会收到信息，subscribeNext后的参数，便是输入框的内容。</li>
</ul>
<p>3、RAC的过滤效果</p>
<pre><code>[[self.passwordTextfiled.rac_textSignal filter:^BOOL(id value) {

    NSString *text = value;

    BOOL k = [text isEqualToString:@&quot;123&quot;];

    return k;

}] subscribeNext:^(id x) {

    NSLog(@&quot;======&quot;);
}];
</code></pre><ul>
<li>这段代码最终实现的效果是，只有密码输入框输入的值是123的时候，subscribe中的代码才能执行。    </li>
<li>之前我们已经接触过.rac_textSignal(信号流)和subscirbeNext(订阅者)。上面他们之间的filter的block块便是一个过滤器。在subscriber(订阅者)接受到文本信号变化之前，filter(过滤器)会首先拦截到这个信号。在这个filter进行一个判断，如果filter内返回一个yes，subscribe才会收到文本变化的信号流，返回NO，订阅者就不会收到信息。就好比一个母亲在给自己待嫁的女儿找婆家，只有这名母亲相中了，她才会让女儿去相亲。</li>
</ul>
<p>4、改变订阅者收到的信息。</p>
<pre><code>[[self.passwordTextFiled.rac_textSignal map:^id(NSString  *str) {

    return[str boolValue] ? [UIColor clearColor]:[UIColor yellowColor];


}] subscribeNext:^(UIColor *x) {

    self.view.backgroundColor = x;
}];
</code></pre><ul>
<li>实现的功能：输入框有变化时改变self.view的背景颜色</li>
<li>之前我们subscribe收到的都是输入框的文本内容，现在我们要做的就是改变订阅者收到的信息。</li>
<li>在3中我们提到一个filter(过滤器),在这里我们要用一个map(映射)来改变订阅者收到的信息。之前咱们说filter的时候，在订阅者收到信息之前filter会进行一个拦截。map(映射)其实也拦截一下，拦截的时候同样会收到文本框的变化。他两唯一的不同是在map(映射)中返回的是订阅者收到的东西。上面的母亲给女儿找到了一个对象，已经结婚了。老公的第一个月工资发了，老婆（map）拿着。她那里给老公（subscribe）给你买什么东西，老公用什么东西。</li>
</ul>
<p>5、对4优化</p>
<pre><code>//对上面的优化
RAC(self.view, backgroundColor) = [self.passwordTextFiled.rac_textSignal map:^id(NSString *passwordValid){


    return[passwordValid boolValue] ? [UIColor clearColor]:[UIColor yellowColor];

}];
</code></pre><ul>
<li>刚开始咱们使用RAC实现咱们刚开始说的需求时，大家已经见到了RAC()。现在我们做的就是讲map(映射)中返回的颜色。赋值给RAC()中对象控件的对应属性。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>起初咱们说到RAC框架有以下几个特点：<br>1、能够使业务逻辑更清晰<br>2、减少代码量<br>3、大量使用block</p>
<p>最后必须要记住的一点是它能做到这一步最为重要的一个原因是</p>
<blockquote>
<p>将代理、KVO、通知、callBack等一系列事件，做了一个统一管理。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/通知中心、KVC、KVO/" itemprop="url">
                  通知中心、KVC、KVO
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T15:30:05+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/通知中心、KVC、KVO/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/通知中心、KVC、KVO/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   本文的内容可能跟之前相比会比较长，主要因为讲了通知、KVO、KVC三个知识点，但我自认为条理还算清晰。建议学完一个敲一下，再进行下一个知识点的学习。</p>
<h1 id="通知中心"><a href="#通知中心" class="headerlink" title="通知中心"></a>通知中心</h1><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>  是一种一对多的信息广播机制,一个应用程序同时只能有一个NSNotificationCenter(通知中心)对象，因为如果有多个通知，发送通知的时候就不知道是该给谁发送了。</p>
<h2 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h2><p>  delegate和block也属于一种信息传递机制，但这两种都是一对一的，每次执行的方法都不一样，而通知是一对多，只要有地方触发通知，执行的是同一个方法。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><ol>
<li><p>添加一个通知</p>
<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(paySalary) name:@&quot;发工资啦&quot; object:nil];
</code></pre></li>
<li><p>实现添加通知时方法选择器选择的方法</p>
</li>
<li><p>在需要发送通知的类中采用下面方法发送通知，发送成功便会执行步骤二实现的方法</p>
<pre><code>[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;发工资啦&quot; object:nil];
</code></pre></li>
<li><p>移除通知，个人习惯在delloc中释放</p>
<pre><code>[[NSNotificationCenter defaultCenter] postNotificationName:nil object:nil userInfo:nil]; 
</code></pre></li>
</ol>
<p>##代码示例</p>
<ol>
<li><p>在viewController.m的viewDidLoad方法中注册一个通知 </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-368c9b1fa38a70e6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注册通知"></p>
</li>
<li><p>在viewController.m实现在注册通知时方法选择器选择的方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-3bfcde362f56fce7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>在NSNotificationViewController.m中的按钮点击事件方法中发送通知</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-75fe25ec0e2a2160.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送通知"></p>
</li>
<li>在viewController.m中重写delloc方法，在方法移除通知。</li>
</ol>
<p>   <img src="http://upload-images.jianshu.io/upload_images/1338564-f212cb4b2c467146.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移除通知"></p>
<h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><h2 id="What-1"><a href="#What-1" class="headerlink" title="What"></a>What</h2><p>  全称，key valued coding(键值编码)</p>
<h2 id="Where-1"><a href="#Where-1" class="headerlink" title="Where"></a>Where</h2><p>  最常用的是将字典数据转model</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>  特殊情况下，更加简便，下文会进行分析。</p>
<h2 id="How-1"><a href="#How-1" class="headerlink" title="How"></a>How</h2><p>  见代码</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>   <strong>该类中用到的Parent和Children类里面只有.h里面有东西，.m文件内什么都没。详情看最后附录。</strong></p>
<pre><code>//
//  KVCViewController.m
//  NSNotification、KVC、KVO
//
//  Created by GG on 16/1/20.
//  Copyright © 2016年 王立广. All rights reserved.
//

#import &quot;KVCViewController.h&quot;
#import &quot;Parent.h&quot;
@implementation KVCViewController

/*

- (void)viewDidLoad{

    [super viewDidLoad];

    self.title = @&quot;KVC&quot;;

    /*

     * 将字典@{@&quot;name&quot;:@&quot;红红&quot;,@&quot;children&quot;:@{@&quot;name&quot;:@&quot;小红&quot;}}采用多种方式转化为model.

     */

     NSDictionary *dict = @{@&quot;name&quot;:@&quot;红   红&quot;,@&quot;children&quot;:@{@&quot;name&quot;:@&quot;小红&quot;}};

     #pragma mark -------------------老方式-------------------

     //该类中用到的Parent和Children类里面只有.h里面有东西，.m文件内什么都没。详情看最后附录。

     Parent *oldWayparent = [Parent new];

     //给parent起名字
     oldWayparent.name = dict[@&quot;name&quot;];

     Children *children1 = [Children new];

     children1.name = dict[@&quot;children&quot;][@&quot;name&quot;];

     //给parent的孩子起名字
     oldWayparent.children = children1;

     NSLog(@&quot;oldWay ======= %@的孩子叫做%@&quot;,oldWayparent.name,oldWayparent.children.name);

     #pragma mark -------------------KVC 方式-------------------

     /*

      * 采用kvc将字典转化为model的三种方式

      * 方式一 : 存值：[id setValue:&lt;#value#&gt; forKey:&lt;#key#&gt;];

                取值：[id valueForKey:&lt;#key#&gt;];

                给id对象的key属性赋值value。此处key的值一定必须要和在id对象key属性一模一样。

      * 方式二 : 存值：[id setValue:&lt;#value#&gt; forKeyPath:&lt;#key.key#&gt;];

                取值：[id valueForKeyPath:&lt;#key#&gt;];

                同样是给id对象的相应属性赋值，但此时后面将不再直接给出键，而是按照键值路径来查找出相应的键，系统会按『.』,自动进入对象内部，查找对象属性。坑①。

      * 方式三 : [id setValuesForKeysWithDictionary:&lt;#NSDictionary#&gt;];

      上面的两种方式都需要取出来字典中的值，赋值给对象的相应属性。如果该对象要是有八九十来个属性，就要写八九十来行代码。这样太麻烦。碰到这样情况直接采用方式三便可。直接将整个字典作为参数传进来，便可将字典转化为model对象。

      * 温馨提示 ： 这三种方式并不是完全独立，不是不可混合使用的，要根据字典内容做决定，接下来我用上面的那个字典做一下简单分析。

      */

      Parent *kvcWayParent = [Parent new];  

      //采用方式一给属性赋值，如果属性是用@property声明的可以直接用self.name = dict[@&quot;name&quot;]，如果没有用@property，而是在大括号内声明的属性要用这种方式。

     [kvcWayParent setValue:dict[@&quot;name&quot;] forKey:@&quot;name&quot;];

     Children *children2 = [Children new];

     [kvcWayParent setValue:children2 forKey:@&quot;children&quot;];

     /*
      * 采用方式二给属性赋值。此时要注意以下两点：
      *
      * 1、是forKeyPath，不是forkey
        2、forkeyPath后childeren一定必须要和kvcWayParent里面的children属性名字一样，它后面的name必须一定要和children里面的name属性名一样。

      */

      [kvcWayParent setValue:dict[@&quot;children&quot;][@&quot;name&quot;] forKeyPath:@&quot;children.name&quot;];

      NSLog(@&quot;kvcWay ======= %@的孩子叫做%@&quot;,kvcWayParent.name,kvcWayParent.children.name);

      Parent *newKvcWayParent = [Parent new];

      /* 
       * 采用第三种方式将字典转化为model,此时我们要注意以下几点：
       * 1、字典里面有什么东西，挑出我们需要用的（一般都需要）在model类中给声明出来。例如字典里有name,我就要在model类中声明该属性。
       * 2、声明属性的时候要注意匹配数据类型。如果是数字，建议声明成NSNumber,因为在进行编码的时候，kvc会自动将字典中的数字转化为NSNumber类型。

       */
       [newKvcWayParent setValuesForKeysWithDictionary:dict];

       //坑②
       NSLog(@&quot;newsKvcWay ======= %@你太伟大了%@&quot;,newKvcWayParent.name,newKvcWayParent.children);    

 }

 @end
</code></pre><p>   坑①： 如果model类中还有其他自定义对象，在赋值之前一定要先给该自定义对象赋值，在给其属性赋值。如果直接按下面的方式赋值，是错误的。</p>
<pre><code>Parent *testParent = [Parent new];
//给children.name赋值之前没有给children赋值
[testParent setValue:dict[@&quot;children&quot;][@&quot;name&quot;] forKeyPath:@&quot;children.name&quot;];
</code></pre><p>   坑②：最后一句输出如下：</p>
<pre><code>&gt; newsKvcWay =======   红红你太伟大了  {

    name = &quot;\U5c0f\U7ea2&quot;;
  }
</code></pre><p>   出现这种情况的原因是我用一个Children的对象来接受字典里面的字典了。</p>
<h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><h2 id="What-2"><a href="#What-2" class="headerlink" title="What"></a>What</h2><p>Key-Value Observing（键值观察），它提供一种机制，当指定的对象的属性被修改后（<strong>指的是属性的内存地址被修改</strong>），则对象就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。</p>
<h2 id="Where-2"><a href="#Where-2" class="headerlink" title="Where"></a>Where</h2><p>需要监听某对象某一属性的变化时</p>
<h2 id="Why-1"><a href="#Why-1" class="headerlink" title="Why"></a>Why</h2><p> 能够实时监听对象属性的变化</p>
<h2 id="How-2"><a href="#How-2" class="headerlink" title="How"></a>How</h2><ol>
<li><p>采用下面这个方法给属性添加观察者,各参数详情见下文</p>
<pre><code>- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;
</code></pre></li>
<li><p>观察者实现下面方法，如果监听的属性发生变化，便会调用该方法。</p>
<pre><code>- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSString*, id&gt; *)change context:(nullable void *)context;
</code></pre></li>
<li><p>适时调用下面方法移除观察者,个人习惯在delloc中释放。</p>
<pre><code>- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context;
</code></pre></li>
</ol>
<h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><pre><code>//
//  KVOViewController.m
//  NSNotification、KVC、KVO
//
//  Created by GG on 16/2/12.
//  Copyright © 2016年 王立广. All rights reserved.
//

#import &quot;KVOViewController.h&quot;
#import &quot;Parent.h&quot;
@interface KVOViewController ()
{
    Parent *parent;

    UILabel *label;
}
@end

@implementation KVOViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.title = @&quot;KVO&quot;;

    parent = [Parent new];

    Children *children = [Children new];

    parent.children = children;

    //给parent的起名字，给parent的children起名字
    parent.children.name = @&quot;闪闪&quot;;
    parent.name = @&quot;小闪&quot;;

    /*
     * 监听parent的children的名字

     * observer: 设置观察者

     * forkeyPath: 设置对象的属性，要注意这里传入的是字符串。在这里我传入的是&quot;children.name&quot;。也就是说我要监听的是parent对象的children属性的name属性。所以说KVO是在KVC的基础上实现的。

     * options: 
         NSKeyValueObservingOptionNew：当options中包括了这个参数的时候，观察者收到的change参数中就会包含NSKeyValueChangeNewKey和它对应的值，也就是说，观察者可以得知这个property在被改变之后的新值。

         NSKeyValueObservingOptionOld：和NSKeyValueObservingOptionNew的意思类似，当包含了这个参数的时候，观察者收到的change参数中就会包含NSKeyValueChangeOldKey和它对应的值。

         NSKeyValueObservingOptionInitial：当包含这个参数的时候，在addObserver的这个过程中，就会有一个notification被发送到观察者那里，反之则没有。

         NSKeyValueObservingOptionPrior：当包含这个参数的时候，在被观察的property的值改变前和改变后，系统各会给观察者发送一个change notification；在property的值改变之前发送的change notification中，change参数会包含NSKeyValueChangeNotificationIsPriorKey并且值为@YES，但不会包含NSKeyValueChangeNewKey和它对应的值。

         可以指定多个NSKeyValueObservingOptions，将他们用“或”连接后，作为options参数。常用的就前三种，第四种知道便可。目前我们只需知道前三种便可。

      * content: 可以将任意对象作为参数在这里传递。

     */
    [parent addObserver:self forKeyPath:@&quot;children.name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld | NSKeyValueObservingOptionInitial context:nil];

    label = [[UILabel alloc]initWithFrame:CGRectMake(100, 200, kScreenWidth-200, 40)];
    label.text = [NSString stringWithFormat:@&quot;%@的孩子名字叫做%@&quot;,parent.name,parent.children.name];
    [self.view addSubview:label];

    UITextField *textfiled = [[UITextField alloc]initWithFrame:CGRectMake(100, 300, kScreenWidth-200, 40)];
    textfiled.placeholder = @&quot;重新输入孩子的名字&quot;;
    [textfiled addTarget:self action:@selector(textfiledChanged:) forControlEvents:UIControlEventEditingChanged];
    [self.view addSubview:textfiled];

}

- (void)textfiledChanged:(UITextField *)textfiled{

    parent.children.name = textfiled.text;
}

/*
 * 如果监听的属性发生了变化，调用该方法。

 * keyPath: 传进来发生变化的属性。

 * object: 所监听的对象

 * change：是一个字典，包含了与property的值变化相关的信息。其中可能会有这样几个键值对，

    NSKeyValueChangeKindKey：这是change中永远会包含的键值对，它的值时一个NSNumber对象，具体的数值有NSKeyValueChangeSetting(对属性进行赋值操作)、NSKeyValueChangeInsertion(对属性进行插入操作)、NSKeyValueChangeRemoval(对属性进行移除操作)、NSKeyValueChangeReplacement(对属性进行替换操作)这几个，其中后三个是针对于一对多关系的。

    NSKeyValueChangeNewKey：只有当addObserver的时候在optional参数中加入NSKeyValueObservingOptionNew，这个键值对才会被change参数包含；它表示这个property改变后的新值。

    NSKeyValueChangeNewOld：只有当addObserver的时候在optional参数中加入NSKeyValueObservingOptionOld，这个键值对才会被change参数包含；它表示这个property改变前的值。

    NSKeyValueChangeIndexesKey：当被观察的property是一个ordered to-many relationship时，这个键值对才会被change参数包含；它的值是一个NSIndexSet对象。

    NSKeyValueChangeNotificationIsPriorKey：只有当addObserver的时候在optional参数中加入NSKeyValueObservingOptionPrior，这个键值对才会被change参数包含；它的值是@YES。

    用[change objectForKey:@&quot;old&quot;]获取变化前的值
    用[change objectForKey:@&quot;new&quot;]获取变化后的值

 *
 */
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context{

    label.text = [NSString stringWithFormat:@&quot;%@的孩子叫做%@&quot;,parent.name, [change objectForKey:@&quot;new&quot;]];

    NSLog(@&quot;上次的名字是%@&quot;,[change objectForKey:@&quot;old&quot;]);

}

- (void)dealloc{

    [parent removeObserver:self forKeyPath:@&quot;children.name&quot;];

}

@end
</code></pre><p>1、 添加观察者时的options参数，目前我们最为常用的就是前三种，其他两种可不做深究。<br>2、属性发生变化，调用相应的方法，change字典参数最常用的两个键是『new』和『old』,其他暂不考虑。</p>
<h1 id="附录-Parent-h和Children-h"><a href="#附录-Parent-h和Children-h" class="headerlink" title="附录 Parent.h和Children.h"></a>附录 Parent.h和Children.h</h1><h2 id="Parent-h，-m里什么都没有"><a href="#Parent-h，-m里什么都没有" class="headerlink" title="Parent.h，.m里什么都没有"></a>Parent.h，.m里什么都没有</h2><pre><code>#import &lt;Foundation/Foundation.h&gt;
#import &quot;Children.h&quot;

@interface Parent : NSObject

@property (nonatomic,copy) NSString *name;

@property (nonatomic,retain) Children *children;

@end
</code></pre><h2 id="Children-h-m里什么都没有"><a href="#Children-h-m里什么都没有" class="headerlink" title="Children.h .m里什么都没有"></a>Children.h .m里什么都没有</h2><pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface Children : NSObject

@property (nonatomic,copy) NSString *name;

@end
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://i1.buimg.com/8311/e0cc1a1fed3a4bda.jpg"
               alt="涅槃广广" />
          <p class="site-author-name" itemprop="name">涅槃广广</p>
          <p class="site-description motion-element" itemprop="description">说不定世界上根本就没有偶然，就如一切都是必然那样</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">25</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wangliguang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5987686599/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">涅槃广广</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"gg-ios"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
