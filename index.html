<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Robot Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="说不定世界上根本就没有偶然，就如一切都是必然那样">
<meta property="og:type" content="website">
<meta property="og:title" content="广广的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="广广的技术博客">
<meta property="og:description" content="说不定世界上根本就没有偶然，就如一切都是必然那样">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="广广的技术博客">
<meta name="twitter:description" content="说不定世界上根本就没有偶然，就如一切都是必然那样">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> 广广的技术博客 - 说不定世界上根本就没有偶然，就如一切都是必然那样 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">广广的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">说不定世界上根本就没有偶然，就如一切都是必然那样</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/H5杂项面试题/" itemprop="url">
                  H5杂项面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T14:39:59+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/H5面试题/" itemprop="url" rel="index">
                    <span itemprop="name">H5面试题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/H5杂项面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/H5杂项面试题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="你能描述一下渐进增强和优雅降级之间的不同吗"><a href="#你能描述一下渐进增强和优雅降级之间的不同吗" class="headerlink" title="你能描述一下渐进增强和优雅降级之间的不同吗?"></a>你能描述一下渐进增强和优雅降级之间的不同吗?</h1><ul>
<li><p><strong>优雅降级</strong></p>
<p>  Web站点在所有新式浏览器中都能正常工作，如果用户使用的 是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功 能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</p>
</li>
<li><p><strong>渐进增强</strong></p>
<p>  从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p>
</li>
</ul>
<h1 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h1><ul>
<li><p>一个程序至少有一个进程，一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
</li>
<li><p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
</li>
<li><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
</li>
<li><p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
</li>
</ul>
<h1 id="说说你对语义化的理解？"><a href="#说说你对语义化的理解？" class="headerlink" title="说说你对语义化的理解？"></a>说说你对语义化的理解？</h1><ul>
<li><p>去掉或样式丢失的时候能让页面呈现清晰的结构：html本身是没有表现的，我们看到例如h1是粗体，字体大小2em，加 粗；strong是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面 呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和 语义化的HTML结构是不可分割的。</p>
</li>
<li><p>屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页。</p>
</li>
<li><p>PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）。</p>
</li>
<li><p>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。</p>
</li>
<li><p>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p>
</li>
</ul>
<h1 id="你如何对网站的文件和资源进行优化？"><a href="#你如何对网站的文件和资源进行优化？" class="headerlink" title="你如何对网站的文件和资源进行优化？"></a>你如何对网站的文件和资源进行优化？</h1><p>   期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。</p>
<h1 id="为什么利用多个域名来提供网站资源会更有效？"><a href="#为什么利用多个域名来提供网站资源会更有效？" class="headerlink" title="为什么利用多个域名来提供网站资源会更有效？"></a>为什么利用多个域名来提供网站资源会更有效？</h1><ol>
<li><p>CDN缓存更方便</p>
</li>
<li><p>突破浏览器并发限制（一般每个域名建立的链接不超过6个）</p>
</li>
<li><p>Cookieless，节省带宽，尤其是上行带宽一般比下行要慢</p>
</li>
<li><p>对于UGC的内容和主站隔离，防止不必要的安全问题(上传js窃取主站cookie之类的)。正是这个原因要求用户内容的域名必须不是自己主站的子域名，而是一个完全独立的第三方域名。</p>
</li>
<li><p>数据做了划分，甚至切到了不同的物理集群，通过子域名来分流比较省事。这个可能被用的不多。</p>
<p>PS: 关于Cookie的问题，带宽是次要的，安全隔离才是主要的。关于多域名，也不是越多越好，虽然服务器端可以做泛解释，浏览器做dns解释也是耗时间的，而且太多域名，如果要走https的话，还有要多买证书和部署的问题。</p>
</li>
</ol>
<h1 id="请说出三种减少页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）"><a href="#请说出三种减少页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）" class="headerlink" title="请说出三种减少页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）"></a>请说出三种减少页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）</h1><ol>
<li>优化图片</li>
<li>图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）</li>
<li>优化CSS（压缩合并css，如margin-top,margin-left…)</li>
<li>网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）</li>
<li>标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速 度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏 览体验也更好了。）</li>
<li>减少http请求（合并文件，合并图片）。</li>
</ol>
<h1 id="如果你参与到一个项目中，发现他们使用Tab来缩进代码，但是你喜欢空格，你会怎么做？"><a href="#如果你参与到一个项目中，发现他们使用Tab来缩进代码，但是你喜欢空格，你会怎么做？" class="headerlink" title="如果你参与到一个项目中，发现他们使用Tab来缩进代码，但是你喜欢空格，你会怎么做？"></a>如果你参与到一个项目中，发现他们使用Tab来缩进代码，但是你喜欢空格，你会怎么做？</h1><ol>
<li>建议这个项目使用像<a href="http://editorconfig.org/" target="_blank" rel="external">EditorConfig</a> 之类的规范</li>
<li>为了保持一致性，接受项目原有的风格</li>
<li>直接使用VIM的retab命令</li>
</ol>
<h1 id="请写一个简单的幻灯效果页面"><a href="#请写一个简单的幻灯效果页面" class="headerlink" title="请写一个简单的幻灯效果页面"></a>请写一个简单的幻灯效果页面</h1><p>如果不使用JS来完成，可以加分。（如：纯CSS实现的幻灯片效果）</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;style&gt;
    img {
      display: none;
      width: 100px;
      height: 100px;
    }

    input:checked + img {
      display: block;
    }

    input {
      position: absolute;
      left: -9999px;
    }

    label {
      cursor: pointer;
    }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;cont&quot;&gt;
      &lt;input id=&quot;img1&quot; name=&quot;img&quot; type=&quot;radio&quot; checked=&quot;checked&quot;&gt;
      &lt;img src=&quot;a.png&quot;&gt;
      &lt;input id=&quot;img2&quot; name=&quot;img&quot; type=&quot;radio&quot;&gt;
      &lt;img src=&quot;b.png&quot;&gt;
    &lt;/div&gt;
    &lt;div id=&quot;nav&quot;&gt;
      &lt;label for=&quot;img1&quot;&gt;第一张&lt;/label&gt;
      &lt;label for=&quot;img2&quot;&gt;第二张&lt;/label&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h1 id="你都使用哪些工具来测试代码的性能？"><a href="#你都使用哪些工具来测试代码的性能？" class="headerlink" title="你都使用哪些工具来测试代码的性能？"></a>你都使用哪些工具来测试代码的性能？</h1><p>Profiler,<a href="http://jsperf.com/nexttick-vs-setzerotimeout-vs-settimeout" target="_blank" rel="external">JSPerf</a>,Dromaeo。</p>
<h1 id="如果今年你打算熟练掌握一项新技术，那会是什么？"><a href="#如果今年你打算熟练掌握一项新技术，那会是什么？" class="headerlink" title="如果今年你打算熟练掌握一项新技术，那会是什么？"></a>如果今年你打算熟练掌握一项新技术，那会是什么？</h1><p>nodejs，html5，css3，less等。</p>
<h1 id="请谈一下你对网页标准和标准制定机构重要性的理解。"><a href="#请谈一下你对网页标准和标准制定机构重要性的理解。" class="headerlink" title="请谈一下你对网页标准和标准制定机构重要性的理解。"></a>请谈一下你对网页标准和标准制定机构重要性的理解。</h1><p>w3c存在的意义就是让浏览器兼容性问题尽量小，首先是他们对浏览器开发者的约束，然后是对开发者的约束。</p>
<h1 id="什么是FOUC（无样式内容闪烁）？你如何来避免FOUC？"><a href="#什么是FOUC（无样式内容闪烁）？你如何来避免FOUC？" class="headerlink" title="什么是FOUC（无样式内容闪烁）？你如何来避免FOUC？"></a>什么是FOUC（无样式内容闪烁）？你如何来避免FOUC？</h1><blockquote>
<p>FOUC(Flash Of Unstyled Content)–文档样式闪烁<br>style type=”text/css”media=”all”&gt;@import”../fouc.css”;&lt; /style&gt;而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文 件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。解决方法简单的出奇，只要在<head>之间加入一个link或者script元素就可以了。</head></p>
</blockquote>
<h1 id="如果网页内容需要支持多语言，你会怎么做？"><a href="#如果网页内容需要支持多语言，你会怎么做？" class="headerlink" title="如果网页内容需要支持多语言，你会怎么做？"></a>如果网页内容需要支持多语言，你会怎么做？</h1><p>下面这些问题需要考虑</p>
<ul>
<li>应用字符集的选择，选择UTF-8编码</li>
<li>语言书写习惯&amp;导航结构</li>
<li>数据库驱动型网站</li>
</ul>
<h1 id="data-属性的作用是什么？"><a href="#data-属性的作用是什么？" class="headerlink" title="data-属性的作用是什么？"></a>data-属性的作用是什么？</h1><ul>
<li><p>data-<em> 属性用于存储页面或应用程序的私有自定义数据。data-</em> 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。存储的（自定义）数据能够被页面的 JavaScript 中利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。</p>
</li>
<li><p>data-* 属性包括两部分：</p>
<ul>
<li>属性名不应该包含任何大写字母，并且在前缀 “data-“ 之后必须有至少一个字符</li>
<li>属性值可以是任意字符串 </li>
</ul>
</li>
</ul>
<h1 id="请描述一下cookies，sessionStorage和localStorage的区别？"><a href="#请描述一下cookies，sessionStorage和localStorage的区别？" class="headerlink" title="请描述一下cookies，sessionStorage和localStorage的区别？"></a>请描述一下cookies，sessionStorage和localStorage的区别？</h1><p>sessionStorage和localStorage是HTML5 Web Storage API提供的，可以方便的在web请求之间保存数 据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。sessionStorage、localStorage、cookie都是在浏 览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念。sessionStorage是在同源的同窗口（或 tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口 后，sessionStorage即被销毁。同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的cookies会 发送到服务器端。其余两个不会。Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每 个域名50个cookie。</p>
<ul>
<li>Firefox每个域名cookie限制为50个。</li>
<li>Opera每个域名cookie限制为30个。</li>
<li>Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。</li>
<li>Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。</li>
<li>InternetExplorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。</li>
</ul>
<h1 id="你最喜欢的图片替换方法是什么，你如何选择使用。"><a href="#你最喜欢的图片替换方法是什么，你如何选择使用。" class="headerlink" title="你最喜欢的图片替换方法是什么，你如何选择使用。"></a>你最喜欢的图片替换方法是什么，你如何选择使用。</h1><pre><code>&lt;h2&gt;&lt;span图片丢这里&gt;&lt;/span&gt;Hello World&lt;/h2&gt;
</code></pre><p>   把span背景设成文字内容，这样又可以保证seo，也有图片的效果在上面。一般都是：alt，title，onerror。</p>
<h1 id="如何视觉隐藏网页内容，只让它们在屏幕阅读器中可用？"><a href="#如何视觉隐藏网页内容，只让它们在屏幕阅读器中可用？" class="headerlink" title="如何视觉隐藏网页内容，只让它们在屏幕阅读器中可用？"></a>如何视觉隐藏网页内容，只让它们在屏幕阅读器中可用？</h1><ul>
<li><p>display:none;的缺陷搜索引擎可能认为被隐藏的文字属于垃圾信息而被忽略屏幕阅读器（是为视觉上有障碍的人设计的读取屏幕内容的程序）会忽略被隐藏的文字。</p>
</li>
<li><p>visibility:hidden;的缺陷这个大家应该比较熟悉就是隐藏的内容会占据他所应该占据物理空间 </p>
</li>
<li><p>overflow:hidden;一个比较合理的方法.texthidden{display:block;/<em>统一转化为块级元素</em> /overflow:hidden;width:0;height:0;}就像上面的一段CSS所展示的方法，将宽度和高度设定为0，然后超过部分隐藏， 就会弥补上述一、二方法中的缺陷，也达到了隐藏内容的目的。</p>
</li>
</ul>
<h1 id="你用过栅格系统吗？如果使用过，你最喜欢哪种？"><a href="#你用过栅格系统吗？如果使用过，你最喜欢哪种？" class="headerlink" title="你用过栅格系统吗？如果使用过，你最喜欢哪种？"></a>你用过栅格系统吗？如果使用过，你最喜欢哪种？</h1><p>比如：Bootstrap，流式栅格系统，<a href="http://960.gs/，栅格系统延续美学。" target="_blank" rel="external">http://960.gs/，栅格系统延续美学。</a></p>
<h1 id="你用过媒体查询，或针对移动端的布局-CSS吗？"><a href="#你用过媒体查询，或针对移动端的布局-CSS吗？" class="headerlink" title="你用过媒体查询，或针对移动端的布局/CSS吗？"></a>你用过媒体查询，或针对移动端的布局/CSS吗？</h1><ul>
<li><p>媒体查询，就是响应式布局。通过不同的媒介类型和条件定义样式表规则。媒介查询让CSS可以更精确作用于不同的媒介类型和同一媒介的不同条件。</p>
</li>
<li><p>语法结构及用法：@media 设备名 only （选取条件） not （选取条件） and（设备选取条件），设备二{sRules}。</p>
</li>
<li><p>示例</p>
</li>
</ul>
<pre><code>/* 当浏览器的可视区域小于980px */
@media screen and （max-width： 980px） {
#wrap {width： 90%; margin:0 auto;}
#content {width： 60%;padding： 5%;}
#sidebar {width： 30%;}
#footer {padding： 8% 5%;margin-bottom： 10px;}
}
/* 当浏览器的可视区域小于650px */
@media screen and （max-width： 650px） {
#header {height： auto;}
#searchform {position： absolute;top： 5px;right： 0;}
#content {width： auto; float： none; margin： 20px 0;}
#sidebar {width： 100%; float： none; margin： 0;}
}
</code></pre><h1 id="你熟悉SVG样式的书写吗？"><a href="#你熟悉SVG样式的书写吗？" class="headerlink" title="你熟悉SVG样式的书写吗？"></a>你熟悉SVG样式的书写吗？</h1><ol>
<li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li>
<li>SVG 用来定义用于网络的基于矢量的图形</li>
<li>SVG 使用 XML 格式定义图形</li>
<li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</li>
<li>SVG 是万维网联盟的标准</li>
<li><p>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;
      &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;
      &lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
          &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot;/&gt;
      &lt;/svg&gt;
</code></pre></li>
</ol>
<h1 id="如何优化网页的打印样式？"><a href="#如何优化网页的打印样式？" class="headerlink" title="如何优化网页的打印样式？"></a>如何优化网页的打印样式？</h1><pre><code>&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; media = &quot;screen&quot; href = &quot;xxx.css&quot;/&gt;
</code></pre><p>   其中media指定的属性就是设备，显示器上就是screen，打印机则是print，电视是tv，投影仪是projection。打印样式示例如下：</p>
<pre><code>&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; media = &quot;print&quot; href = &quot;yyy.css&quot;/&gt;
</code></pre><p>   但打印样式表也应注意以下事项：</p>
<ol>
<li>打印样式表中最好不要用背景图片，因为打印机不能打印CSS中的背景。如要显示图片，请使用html插入到页面中。</li>
<li>最好不要使用像素作为单位，因为打印样式表要打印出来的会是实物，所以建议使用pt和cm。</li>
<li>隐藏掉不必要的内容。（@print div{display:none;}）</li>
<li>打印样式表中最好少用浮动属性，因为它们会消失。如果想要知道打印样式表的效果如何，直接在浏览器上选择打印预览就可以了。</li>
</ol>
<h1 id="如果设计中使用了非标准的字体，你该如何去实现？"><a href="#如果设计中使用了非标准的字体，你该如何去实现？" class="headerlink" title="如果设计中使用了非标准的字体，你该如何去实现？"></a>如果设计中使用了非标准的字体，你该如何去实现？</h1><p>所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。</p>
<p>方法：</p>
<ul>
<li>用图片代替</li>
<li><p>web fonts在线字库，如Google Webfonts，Typekit等等；http://- www.chinaz.com/free/2012/0815/269267.shtml</p>
</li>
<li><p>@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)</p>
</li>
</ul>
<h1 id="解释下浏览器是如何判断元素是否匹配某个CSS选择器？"><a href="#解释下浏览器是如何判断元素是否匹配某个CSS选择器？" class="headerlink" title="解释下浏览器是如何判断元素是否匹配某个CSS选择器？"></a>解释下浏览器是如何判断元素是否匹配某个CSS选择器？</h1><p>从后往前判断。浏览器先产生一个元素集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，如果不符合上一个部分，就把元素从集合中删除，直到真个选择器都匹配完，还在集合中的元素就匹配这个选择器了。举个例子，有选择器：</p>
<pre><code>body.ready#wrapper&gt;.lol233
</code></pre><p>先把所有class中有lol233的元素拿出来组成一个集合，然后上一层，对每一个集合中的元素，如果元素的parent id不 为#wrapper则把元素从集合中删去。再向上，从这个元素的父元素开始向上找，没有找到一个tagName为body且class中有ready的元 素，就把原来的元素从集合中删去。至此这个选择器匹配结束，所有还在集合中的元素满足。大体就是这样，不过浏览器还会有一些奇怪的优化。为什么从后往前匹 配因为效率和文档流的解析方向。效率不必说，找元素的父亲和之前的兄弟比遍历所哟儿子快而且方便。关于文档流的解析方向，是因为现在的CSS，一个元素只 要确定了这个元素在文档流之前出现过的所有元素，就能确定他的匹配情况。应用在即使html没有载入完成，浏览器也能根据已经载入的这一部分信息完全确定 出现过的元素的属性。为什么是用集合主要也还是效率。基于CSS Rule数量远远小于元素数量的假设和索引的运用，遍历每一条CSS Rule通过集合 筛选，比遍历每一个元素再遍历每一条Rule匹配要快得多。</p>
<h1 id="解释一下你对盒模型的理解，以及如何在CSS中告诉浏览器使用不同的盒模型来渲染你的布局。"><a href="#解释一下你对盒模型的理解，以及如何在CSS中告诉浏览器使用不同的盒模型来渲染你的布局。" class="headerlink" title="解释一下你对盒模型的理解，以及如何在CSS中告诉浏览器使用不同的盒模型来渲染你的布局。"></a>解释一下你对盒模型的理解，以及如何在CSS中告诉浏览器使用不同的盒模型来渲染你的布局。</h1><p><a href="http://www.cnblogs.com/syfwhu/p/4319236.html" target="_blank" rel="external">关于盒模型请看文章CSS之布局与定位</a></p>
<h1 id="请解释一下relative、fixed、absolute和static元素的区别？请解释一下inline和inline-block的区别？"><a href="#请解释一下relative、fixed、absolute和static元素的区别？请解释一下inline和inline-block的区别？" class="headerlink" title="请解释一下relative、fixed、absolute和static元素的区别？请解释一下inline和inline-block的区别？"></a>请解释一下relative、fixed、absolute和static元素的区别？请解释一下inline和inline-block的区别？</h1><p><a href="http://www.cnblogs.com/syfwhu/p/4319236.html" target="_blank" rel="external">关于第一个问题请看文章CSS之布局与定位</a></p>
<p><strong>inline:</strong>此元素会被显示为内联元素，元素前后没有换行符。</p>
<p><strong>inline-block:</strong>行内块元素。</p>
<h1 id="解释下事件代理。"><a href="#解释下事件代理。" class="headerlink" title="解释下事件代理。"></a>解释下事件代理。</h1><p>JavaScript事件代理则是一种简单的技巧，通过它你可以把事件处理器添加到一个父级元素上，这样就避免了把事件处理器添加到多个子级元素 上。当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制。事 件代理用到了两个在JavaSciprt事件中常被忽略的特性：事件冒泡以及目标元素。</p>
<pre><code>function getEventTarget(e) {
  e=e||window.event;
  return e.target||e.srcElement;
}
</code></pre><h1 id="AMD-vs-CommonJS？"><a href="#AMD-vs-CommonJS？" class="headerlink" title="AMD vs.CommonJS？"></a>AMD vs.CommonJS？</h1><p><a href="http://www.cnblogs.com/syfwhu/p/4883532.html" target="_blank" rel="external">请看文章JavaScript之模块化编程</a></p>
<h1 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h1><p>散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<h1 id="描述以下变量的区别：null，undefined或undeclared？"><a href="#描述以下变量的区别：null，undefined或undeclared？" class="headerlink" title="描述以下变量的区别：null，undefined或undeclared？"></a>描述以下变量的区别：null，undefined或undeclared？</h1><p>JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</p>
<p>但是，上面这样的区分，在实践中很快就被证明不可行。目前，null和undefined基本是同义的，只有一些细微的差别。</p>
<p>null表示”没有对象”，即该处不应该有值。典型用法是：</p>
<ul>
<li>用来初始化一个变量，这个变量可能被赋值为一个对象。</li>
<li>用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。</li>
<li>当函数的参数期望是对象时，被用作参数传入。</li>
<li>当函数的返回值期望是对象时，被用作返回值传出。</li>
<li>作为对象原型链的终点。</li>
</ul>
<p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<ul>
<li>变量被声明了，但没有赋值时，就等于undefined。</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>
<li>对象没有赋值的属性，该属性的值为undefined。</li>
<li>函数没有返回值时，默认返回undefined。</li>
</ul>
<p>该如何检测它们？</p>
<p>null：表示无值；undefined：表示一个未声明的变量，或已声明但没有赋值的变量，或一个并不存在的对象属性。</p>
<p>==运算符将两者看作相等。如果要区分两者，要使用===或typeof运算符。</p>
<p>以下是不正确的用法：</p>
<pre><code>var exp = undefined;

if (exp == undefined) {
    alert(&quot;undefined&quot;);
}
</code></pre><p>exp为null时，也会得到与undefined相同的结果，虽然null和undefined不一样。注意：要同时判断undefined和null时可使用本法。</p>
<p>typeof返回的是字符串，有六种可能：”number”、”string”、”boolean”、”object”、”function”、”undefined”。</p>
<p>以下是正确的用法：</p>
<pre><code>var exp = undefined;

if(typeof(exp) == undefined) {
    alert(&quot;undefined&quot;);
}
</code></pre><p>JS中如何判断null？</p>
<p>以下是不正确的用法：</p>
<pre><code>var exp = null;

if(exp == null) {
    alert(&quot;is null&quot;);
}
</code></pre><p>exp为undefined时，也会得到与null相同的结果，虽然null和undefined不一样。注意：要同时判断null和undefined时可使用本法。</p>
<pre><code>var exp=null;

if(!exp) {
    alert(&quot;is null&quot;);
}
</code></pre><p>如果exp为undefined或者数字零，也会得到与null相同的结果，虽然null和二者不一样。注意：要同时判断null、undefined和数字零时可使用本法。</p>
<pre><code>var exp = null;

if(typeof(exp) == &quot;null&quot;) {
    alert(&quot;is null&quot;);
}
</code></pre><p>为了向下兼容，exp为null时，typeof总返回object。这种方式也不太好。</p>
<p>以下是正确的用法：</p>
<pre><code>var exp = null;

if(!exp&amp;&amp;typeof(exp) != &quot;undefined&quot; &amp;&amp; exp != 0) {
    alert(&quot;is null&quot;);
}
</code></pre><h1 id="请指出浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别？"><a href="#请指出浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别？" class="headerlink" title="请指出浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别？"></a>请指出浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别？</h1><p><strong>特性检测：</strong>为特定浏览器的特性进行测试，并仅当特性存在时即可应用特性。</p>
<p><strong>User-Agent检测：</strong>最早的浏览器嗅探即用户代理检测，服务端（以及后来的客户端）根据UA字符串屏蔽某些特定的浏览器查看网站内容。</p>
<p><strong>特性推断：</strong>尝试使用多个特性但仅验证了其中之一。根据一个特性的存在推断另一个特性是否存在。问题是，推断是假设并非事实，而且可能导致可维护性的问题。</p>
<h1 id="请尽可能详尽的解释AJAX的工作原理。"><a href="#请尽可能详尽的解释AJAX的工作原理。" class="headerlink" title="请尽可能详尽的解释AJAX的工作原理。"></a>请尽可能详尽的解释AJAX的工作原理。</h1><p><a href="http://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html" target="_blank" rel="external">请参考文章AJAX工作原理</a></p>
<h1 id="请解释JSONP的工作原理，以及它为什么不是真正的AJAX。"><a href="#请解释JSONP的工作原理，以及它为什么不是真正的AJAX。" class="headerlink" title="请解释JSONP的工作原理，以及它为什么不是真正的AJAX。"></a>请解释JSONP的工作原理，以及它为什么不是真正的AJAX。</h1><p>JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的javascript，于是我们可以通过script标 记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA 需要的数据，然后在 pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后 会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行， 那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。</p>
<p>AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！</p>
<h1 id="请描述下事件冒泡机制。"><a href="#请描述下事件冒泡机制。" class="headerlink" title="请描述下事件冒泡机制。"></a>请描述下事件冒泡机制。</h1><p>冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。</p>
<p>捕获型事件：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。</p>
<p>支持W3C标准的浏览器在添加事件时用addEventListener(event,fn,useCapture)方法，基中第3个参数 useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行。而不兼容W3C的浏览器(IE)用 attachEvent()方法，此方法没有相关设置，不过IE的事件模型默认是在事件冒泡时执行的，也就是在useCapture等于false的时候 执行，所以把在处理事件时把useCapture设置为false是比较安全，也实现兼容浏览器的效果。</p>
<p><img src="http://images2015.cnblogs.com/blog/716683/201510/716683-20151013185212819-847014694.jpg" alt=""></p>
<h1 id="请解释-end-的用途。"><a href="#请解释-end-的用途。" class="headerlink" title="请解释.end()的用途。"></a>请解释.end()的用途。</h1><p>在官方的API上是这样描述end()方法的：“回到最近的一个”破坏性”操作之前。即，将匹配的元素列表变为前一次的状态。”；看样子好像是找到最后一次操作的元素的上一元素，在如下的例子中：html代码：</p>
<p>复制代码代码如下:</p>
<pre><code>&lt;div&gt;测试内容1&lt;/div&gt;&lt;div&gt;测试内容2&lt;/div&gt;
</code></pre><p>jQuery代码：</p>
<pre><code>$(&apos;&lt;p&gt;新增内容&lt;/p&gt;&apos;).appendTo(&apos;div&apos;).addClass(&apos;c1&apos;).end().addClass(&apos;c2&apos;);
</code></pre><p>复制代码代码如下:</p>
<pre><code>&lt;div&gt;测试内容1
    &lt;p class=&quot;c1 c2&quot;&gt;新增内容&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;测试内容2
    &lt;p class=&quot;c1&quot;&gt;新增内容&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>这里我就有一点不太明白了，怎么只有第一个</p><p>标签有两个样式，end()方法后返回的是什么,在火狐里添加了监控，得到如下结 果：1.$(‘</p><p>新增内容</p>‘).appendTo(‘div’)返回的是：[p,p]对象数组，即新增后的两个p标 签；2.$(‘<p>新增内容</p>‘).appendTo(‘div’).addClass(‘c1’)返回的是： [p.c1,p.c1]对象数组，即添加了c1类样式后的p对象数组；3.$(‘<p>新增内 容</p>‘).appendTo(‘div’).addClass(‘c1’).end()返回的是[p.c1],是第1 个<div>中的<p>,在2操作中，最后“破坏”的是第2个<div>中的<p>,所以他的前一次操 作的对象是第1个<div>中的<p>,返回的就是它;4.$(‘</p><p>新增内 容</p>‘).appendTo(‘div’).addClass(‘c1’).end().addClass(‘c2’)返回的仍然是第 1个<div>中的<p>;现在算是有点明白了，关键是要搞清楚最后一次操作的元素的上一元素是什么。</p>
<h1 id="你如何给一个事件处理函数命名空间，为什么要这样做？"><a href="#你如何给一个事件处理函数命名空间，为什么要这样做？" class="headerlink" title="你如何给一个事件处理函数命名空间，为什么要这样做？"></a>你如何给一个事件处理函数命名空间，为什么要这样做？</h1><p>任何作为type参数的字符串都是合法的；如果一个字符串不是原生的JavaScript事件名，那么这个事件处理函数会绑定到一个自定义事件上。 这些自定义事件绝对不会由浏览器触发，但可以通过使用.trigger()或者.triggerHandler()在其他代码中手动触发。如果type参 数的字符串中包含一个点(.)字符，那么这个事件就看做是有命名空间的了。这个点字符就用来分隔事件和他的命名空间。举例来说，如果执 行.bind(‘click.name’,handler)，那么字符串中的click是事件类型，而字符串name就是命名空间。命名空间允许我们取消 绑定或者触发一些特定类型的事件，而不用触发别的事件。参考unbind()来获取更多信息。</p>
<p>jQuery的bind/unbind方法应该说使用很简单，而且大多数时候可能并不会用到，取而代之的是直接用click/keydown之类的事件名风格的方法来做事件绑定操作。</p>
<p>但假设如下情况：需要在运行时根据用户交互的结果进行不同click事件处理逻辑的绑定，因而理论上会无数次对某一个事件进行 bind/unbind操作。但又希望unbind的时候只把自己绑上去的处理逻辑给释放掉而不是所有其他地方有可能的额外的同一事件绑定逻辑。这时候如 果直接用.click()/.bind(‘click’)加上.unbind(‘click’)来进行重复绑定的话，被unbind掉的将是所有绑定在元 素上的click处理逻辑，潜在会影响到该元素其他第三方的行为。</p>
<p>当然如果在bind的时候是显示定义了function变量的话，可以在unbind的时候提供function作为第二个参数来指定只 unbind其中一个处理逻辑，但实际应用中很可能会碰到各种进行匿名函数绑定的情况。对于这种问题，jQuery的解决方案是使用事件绑定的命名空间。 即在事件名称后添加.something来区分自己这部分行为逻辑范围。</p>
<p>比如用.bind(‘click.myCustomRoutine’,function(){…});同样是把匿名函数绑定到click事件 （你可以用自己的命名空间多次绑定不同的行为方法上去），当unbind的时候用.unbind(‘click.myCustomRoutine’)即可 释放所有绑定到.myCustomRoutine命名空间的click事件，而不会解除其他通过.bind(‘click’)或另外的命名空间所绑定的事 件行为。同时，使用命令空间还可以让你一次性unbind所有此命名空间下的自定义事件绑定，通 过.unbind(‘.myCustomRoutine’)即可。要注意的是，jQuery的命名空间并不支持多级空间。</p>
<p>因为在jQuery里面，如果用.unbind(‘click.myCustomRoutine.myCustomSubone’)，解除的是命名 空间分别为myCustomRoutine和myCustomSubone的两个并列命名空间下的所有click事件，而不 是”myCustomRoutine下的myCustomSubone子空间”。</p>
</div></div></p></div></p></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/CSS面试题/" itemprop="url">
                  CSS面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T14:37:54+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/H5面试题/" itemprop="url" rel="index">
                    <span itemprop="name">H5面试题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/CSS面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/CSS面试题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="描述下“reset”CSS文件的作用和使用它的好处。"><a href="#描述下“reset”CSS文件的作用和使用它的好处。" class="headerlink" title="描述下“reset”CSS文件的作用和使用它的好处。"></a>描述下“reset”CSS文件的作用和使用它的好处。</h1><p>因为浏览器的品种很多，每个浏览器的默认样式也是不同的，所以定义一个css reset可以使各浏览器的默认样式统一。</p>
<h1 id="解释下浮动和它的工作原理。"><a href="#解释下浮动和它的工作原理。" class="headerlink" title="解释下浮动和它的工作原理。"></a>解释下浮动和它的工作原理。</h1><p>关于浮动我们需要了解，浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。要想使元素浮动，必须为元素设置一个宽度（width）。虽然浮动元素不是文档流之中，但是它浮动后所处的位置依然是在浮动之前的水平方向上。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样，下面的元素填补原来的位置。有些元素会在浮动元素的下方，但是这些元素的内容并不一定会被浮动的元素所遮盖，对内联元素进行定位时，这些元素会考虑浮动元素的边界，会围绕着浮动元素放置。也可以把浮动元素想象成是被块元素忽略的元素，而内联元素会关注浮动元素的。  </p>
<h1 id="列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。"><a href="#列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。" class="headerlink" title="列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。"></a>列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。</h1><ol>
<li><p>使用空标签清除浮动。这种方法是在所有浮动标签后面添加一个空标签定义css clear:both.弊端就是增加了无意义标签。</p>
</li>
<li><p>使用overflow。给包含浮动元素的父标签添加css属性overflow:auto;zoom:1;zoom:1用于兼容IE6。</p>
</li>
<li><p>使用after伪对象清除浮动。该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮 动元素的伪对象中设置height:0，否则该元素会比实际高出若干像素；二、content属性是必须的，但其值可以为空，content属性的值设 为”.”，空亦是可以的。</p>
</li>
<li><p>浮动外部元素</p>
</li>
</ol>
<p><strong>此三种方法各有利弊，使用时应择优选择，比较之下第二种方法更为可取。</strong></p>
<h1 id="解释下CSS-sprites，以及你要如何在页面或网站中使用它。"><a href="#解释下CSS-sprites，以及你要如何在页面或网站中使用它。" class="headerlink" title="解释下CSS sprites，以及你要如何在页面或网站中使用它。"></a>解释下CSS sprites，以及你要如何在页面或网站中使用它。</h1><p>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background- image”，“background-repeat”，“background-position”的组合进行背景定位，background- position可以用数字能精确的定位出背景图片的位置。</p>
<h1 id="讨论CSS-hacks，条件引用或者其他。"><a href="#讨论CSS-hacks，条件引用或者其他。" class="headerlink" title="讨论CSS hacks，条件引用或者其他。"></a>讨论CSS hacks，条件引用或者其他。</h1><pre><code>各个浏览器都认识，这里给firefox用；

background-color:red\9;\9所有的ie浏览器可识别；

background-color:yellow\0;\0是留给ie8的+background-color:pink;+ie7定了；

_background-color:orange;_专门留给神奇的ie6；:root#test{background-color:purple\9;}:root是给ie9的，

@media all and(min-width:0px){#test{background-color:black\0;}}这个是老是跟ie抢着认\0的神奇的opera，必须加个\0,不然firefox，chrome，safari也都认识。

@media screen and(-webkit-min-device-pixel-ratio:0){#test{background-color:gray;}}最后这个是浏览器新贵chrome和safari的。
</code></pre><h1 id="在书写高效CSS时会有哪些问题需要考虑？"><a href="#在书写高效CSS时会有哪些问题需要考虑？" class="headerlink" title="在书写高效CSS时会有哪些问题需要考虑？"></a>在书写高效CSS时会有哪些问题需要考虑？</h1><ol>
<li>样式是：从右向左的解析一个选择器；</li>
<li>ID最快，Universal最慢有四种类型的key selector，解析速度由快到慢依次是：ID、class、tag和universal ；</li>
<li>不要tag-qualify（永远不要这样做ul#main-navigation{}ID已经是唯一的，不需要Tag来标识，这样做会让选择器变慢。）；</li>
<li>后代选择器最糟糕（换句话说，下面这个选择器是很低效的：html body ul li a{}）；</li>
<li>想清楚你为什么这样写；</li>
<li>CSS3的效率问题（CSS3选择器（比如:nth-child）能够漂亮的定位我们想要的元素，又能保证我们的CSS整洁易读。但是这些神奇的选择器会浪费很多的浏览器资源。）；</li>
<li>我们知道#ID速度是最快的，那么我们都用ID，是不是很快。但是我们不应该为了效率而牺牲可读性和可维护性。</li>
</ol>
<h1 id="使用CSS预处理器的优缺点有哪些？"><a href="#使用CSS预处理器的优缺点有哪些？" class="headerlink" title="使用CSS预处理器的优缺点有哪些？"></a>使用CSS预处理器的优缺点有哪些？</h1><ul>
<li><p>LESS&amp;SassLESS是受Sass启发而开发的工具，它列出了如下开发的理由：</p>
<p>  “为什么要开发一个Sass的替代品呢？原因很简单：首先是语法。Sass的一个关键特性是缩进式的语法，这种语法可以产生柱式外观的代码。但是你需要 花费时间学习一门新的语法以及重新构建你现在的样式表。LESS给CSS带来了很多特性，使得LESS能够和CSS无缝地紧密结合在一起。因此，你可以平 滑地由CSS迁移到LESS，如果你只是对使用变量或者操作感兴趣的话，你不需要学习一整门全新的语言。”</p>
</li>
<li><p>StylusStylus相对前两者较新，可以看官方文档介绍的功能。</p>
<ol>
<li>来自NodeJS社区，所以和NodeJS走得很近，与JavaScript联系非常紧密。还有专门JavaScript API：<a href="http://learnboost.github.io/stylus/docs/js.html" target="_blank" rel="external">http://learnboost.github.io/stylus/docs/js.html</a></li>
<li>支持Ruby之类等等框架；</li>
<li>更多更强大的支持和功能总结：Sass看起来在提供的特性上占有优势，但是LESS能够让开发者平滑地从现存CSS文件过渡到LESS，而不需要像Sass那样需要将CSS文件转换成Sass格式。Stylus功能上更为强壮，和js联系更加紧密。</li>
</ol>
</li>
</ul>
<h1 id="请解释一下-box-sizing-border-box-的作用-并且说明使用它有什么好处？"><a href="#请解释一下-box-sizing-border-box-的作用-并且说明使用它有什么好处？" class="headerlink" title="请解释一下*{box-sizing:border-box;}的作用,并且说明使用它有什么好处？"></a>请解释一下*{box-sizing:border-box;}的作用,并且说明使用它有什么好处？</h1><p>说到IE的bug，在IE6以前的版本中，IE对盒模型的解析出现一些问题，跟其它浏览器不同，将border与padding都包含在width之内。而另外一些浏览器则与它相反，是不包括border和padding的。</p>
<p>在我们开发的过程中会发现，有时候，如果对页面中的大区域进行设置时，将border、padding计算到width和height之内，反而更 灵活。但W3C的CSS2.1规范却规定了他们并不能被包含其中。考虑到这个问题，css3中引入了一个新的属性：box-sizing，它具有 “content-box”和”border-box“两个值。</p>
<pre><code>box-sizing:content-box
</code></pre><p>当我们设置box-sizing:content-box;时，浏览器对盒模型的解释遵从我们之前认识到的W3C标准，当它定义width和height时，它的宽度不包括border和padding。</p>
<pre><code>box-sizing:border-box
</code></pre><p>当我们设置box-sizing:border-box;时，浏览器对盒模型的解释与IE6之前的版本相同，当它定义width和height 时，border和padding则是被包含在宽高之内的。内容的宽和高可以通过定义的“width”和“height”减去相应方向的 “padding”和“border”的宽度得到。内容的宽和高必须保证不能为负，必要时将自动增大该元素border box的尺寸以使其内容的宽或高 最小为0。</p>
<h1 id="请罗列出你所知道的display属性的全部值"><a href="#请罗列出你所知道的display属性的全部值" class="headerlink" title="请罗列出你所知道的display属性的全部值"></a>请罗列出你所知道的display属性的全部值</h1><p><img src="http://images2015.cnblogs.com/blog/716683/201510/716683-20151013142822460-1264753317.jpg" alt="jlkjklj"></p>
<h1 id="你目前在使用哪一套CSS框架，或者在产品线上使用过哪一套？"><a href="#你目前在使用哪一套CSS框架，或者在产品线上使用过哪一套？" class="headerlink" title="你目前在使用哪一套CSS框架，或者在产品线上使用过哪一套？"></a>你目前在使用哪一套CSS框架，或者在产品线上使用过哪一套？</h1><p>Bootstrap,PureCSS,Foundation等等</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/JavaScript面试题/" itemprop="url">
                  JavaScript面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T14:37:42+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/H5面试题/" itemprop="url" rel="index">
                    <span itemprop="name">H5面试题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/JavaScript面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/JavaScript面试题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在js中如何判断当前浏览器正在以何种方式解析？"><a href="#在js中如何判断当前浏览器正在以何种方式解析？" class="headerlink" title="在js中如何判断当前浏览器正在以何种方式解析？"></a>在js中如何判断当前浏览器正在以何种方式解析？</h1><p>document对象有个属性compatMode,它有两个值：BackCompat对应quirks mode，CSS1Compat对应strict mode。</p>
<h1 id="解释下JavaScript中this是如何工作的。"><a href="#解释下JavaScript中this是如何工作的。" class="headerlink" title="解释下JavaScript中this是如何工作的。"></a>解释下JavaScript中this是如何工作的。</h1><p>this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。匿名函数或不处于任何对象中的函数指向window 。</p>
<ol>
<li><p>如果是call，apply,with，指定的this是谁，就是谁。</p>
</li>
<li><p>普通的函数调用，函数被谁调用，this就是谁。</p>
</li>
</ol>
<h1 id="解释下原型继承的原理。"><a href="#解释下原型继承的原理。" class="headerlink" title="解释下原型继承的原理。"></a>解释下原型继承的原理。</h1><p>以下代码展示了JS引擎如何查找属性：</p>
<pre><code>function getProperty(obj,prop) {
    if (obj.hasOwnProperty(prop)) {
        return obj[prop];
    } else if (obj.__proto__!==null) {
        return getProperty(obj.__proto__,prop);
    } else {
        return undefined;
    }
}
</code></pre><p><img src="http://images.cnitblog.com/blog2015/716683/201504/171011349018292.jpg" alt=""></p>
<h1 id="什么是闭包，如何使用它，为什么要使用它？"><a href="#什么是闭包，如何使用它，为什么要使用它？" class="headerlink" title="什么是闭包，如何使用它，为什么要使用它？"></a>什么是闭包，如何使用它，为什么要使用它？</h1><p>包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>使用闭包的注意点：</p>
<p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<p><a href="http://www.cnblogs.com/syfwhu/p/4839562.html" target="_blank" rel="external">关于闭包，详细了解请看JavaScript之作用域与闭包详解</a></p>
<h1 id="请举出一个匿名函数的典型用例？"><a href="#请举出一个匿名函数的典型用例？" class="headerlink" title="请举出一个匿名函数的典型用例？"></a>请举出一个匿名函数的典型用例？</h1><p>自执行函数，用闭包模拟私有变量、特权函数等。</p>
<h1 id="解释“JavaScript模块模式”以及你在何时使用它。"><a href="#解释“JavaScript模块模式”以及你在何时使用它。" class="headerlink" title="解释“JavaScript模块模式”以及你在何时使用它。"></a>解释“JavaScript模块模式”以及你在何时使用它。</h1><pre><code>如果有提到无污染的命名空间，可以考虑加分。

如果你的模块没有自己的命名空间会怎么样？
</code></pre><p>请看文章-<a href="http://www.cnblogs.com/syfwhu/p/4883532.html" target="_blank" rel="external">JavaScript之模块化编程</a>和<a href="http://www.cnblogs.com/syfwhu/p/4415586.html" target="_blank" rel="external">JavaScript之命名空间模式 浅析</a></p>
<h1 id="请指出JavaScript宿主对象和原生对象的区别？"><a href="#请指出JavaScript宿主对象和原生对象的区别？" class="headerlink" title="请指出JavaScript宿主对象和原生对象的区别？"></a>请指出JavaScript宿主对象和原生对象的区别？</h1><p><strong>原生对象</strong></p>
<p>ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。</p>
<p>“本地对象”包含哪些内容：Object、Function、Array、String、Boolean、Number、Date、RegExp、 Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、 URIError。</p>
<p>由此可以看出，简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。</p>
<p><strong>内置对象</strong></p>
<p>ECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。</p>
<p>同样是“独立于宿主环境”。根据定义我们似乎很难分清“内置对象”与“本地对象”的区别。而 ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。如此就可以理解了。内置对象是本地对象的一种。</p>
<p><strong>宿主对象</strong></p>
<p>何为“宿主对象”？主要在这个“宿主”的概念上，ECMAScript中的“宿主”当然就是我们网页的运行环境，即“操作系统”和“浏览器”。</p>
<p>所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的BOM和DOM都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象。</p>
<h1 id="call和-apply的区别是什么？"><a href="#call和-apply的区别是什么？" class="headerlink" title="call和.apply的区别是什么？"></a>call和.apply的区别是什么？</h1><p><strong>call方法: </strong></p>
<p>语法：call(thisObj，Object)<br>定义：调用一个对象的一个方法，以另一个对象替换当前对象。<br>说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 </p>
<p><strong>apply方法： </strong><br>语法：apply(thisObj，[argArray])<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象。<br>说 明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p>
<p>对于apply和call两者在作用上是相同的，但两者在参数上有以下区别：<br>对于第一个参数意义都一 样，但对第二个参数：apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开 始）。如 func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1, [var1,var2,var3])同时使用apply的好处是可以直接将当前函数的arguments对象作为apply的第二个参数传入。</p>
<h1 id="你何时优化自己的代码？"><a href="#你何时优化自己的代码？" class="headerlink" title="你何时优化自己的代码？"></a>你何时优化自己的代码？</h1><p>请看文章<a href="http://www.cnblogs.com/syfwhu/p/4438810.html" target="_blank" rel="external">JavaScript之高效编程</a> 及<a href="http://www.cnblogs.com/syfwhu/p/4814435.html" target="_blank" rel="external">JavaScript编码风格指南</a></p>
<h1 id="你能解释一下JavaScript中的继承是如何工作的吗？"><a href="#你能解释一下JavaScript中的继承是如何工作的吗？" class="headerlink" title="你能解释一下JavaScript中的继承是如何工作的吗？"></a>你能解释一下JavaScript中的继承是如何工作的吗？</h1><p> 原型链等。</p>
<h1 id="在什么时候你会使用document-write-？"><a href="#在什么时候你会使用document-write-？" class="headerlink" title="在什么时候你会使用document.write()？"></a>在什么时候你会使用document.write()？</h1><p>大多数生成的广告代码依旧使用document.write()，虽然这种用法会让人很不爽。</p>
<h1 id="请解释变量声明提升。"><a href="#请解释变量声明提升。" class="headerlink" title="请解释变量声明提升。"></a>请解释变量声明提升。</h1><p>在JS里定义的变量，存在于作用域链里，而在函数执行时会先把变量的声明进行提升，仅仅是把声明进行了提升，而其值的定义还在原来位置。示例如下：</p>
<pre><code>var test = function() {
    console.log(name); // 输出：undefined
    var name = &quot;jeri&quot;;
    console.log(name); // 输出：jeri
}

test();
</code></pre><p>上述代码与下述代码等价。</p>
<pre><code>var test = function() {
    var name;
    console.log(name); // 输出：undefined
    name = &quot;jeri&quot;;
    console.log(name); // 输出：jeri
}

test();
</code></pre><p>由以上代码可知，在函数执行时，把变量的声明提升到了函数顶部，而其值定义依然在原来位置。</p>
<h1 id="“attribute”和”property”的区别是什么？"><a href="#“attribute”和”property”的区别是什么？" class="headerlink" title="“attribute”和”property”的区别是什么？"></a>“attribute”和”property”的区别是什么？</h1><ol>
<li><strong>定义</strong></li>
</ol>
<p>Property：属性，所有的HTML元素都由HTMLElement类型表示，HTMLElement类型 直接继承自Element并添加了一些属性，添加的这些属性分别对应于每个HTML元素都有下面的这5个标准特性: id,title,lang,dir,className。DOM节点是一个对象，因此，他可以和其他的JavaScript对象一样添加自定义的属性以 及方法。property的值可以是任何的数据类型，对大小写敏感，自定义的property不会出现在html代码中，只存在js中。</p>
<p>Attribute：特性，区别于property，attribute只能是字符串，大小写不敏感，出现在innerHTML中，通过类数组attributes可以罗列所有的attribute。</p>
<ol>
<li><strong>相同之处</strong></li>
</ol>
<p>标准的 DOM properties 与 attributes 是同步的。公认的（非自定义的）特性会被以属性的形式添加到DOM对象中。如，id，align，style等，这时候操作property或者使用操作 特性的DOM方法如getAttribute()都可以操作属性。不过传递给getAttribute()的特性名与实际的特性名相同。因此对于 class的特性值获取的时候要传入“class”。</p>
<ol>
<li><strong>不同之处</strong></li>
</ol>
<p>1).对于有些标准的特性的操作，getAttribute与点号(.)获取的值存在差异性。如href，src，value，style，onclick等事件处理程序。<br>2).href：getAttribute获取的是href的实际值，而点号获取的是完整的url，存在浏览器差异。</p>
<h1 id="请指出document-onload和document-ready两个事件的区别。"><a href="#请指出document-onload和document-ready两个事件的区别。" class="headerlink" title="请指出document.onload和document.ready两个事件的区别。"></a>请指出document.onload和document.ready两个事件的区别。</h1><p>页面加载完成有两种事件，</p>
<ol>
<li>ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），</li>
<li>onload，指示页面包含图片等文件在内的所有元素都加载完成。</li>
</ol>
<h1 id="和-有什么不同？"><a href="#和-有什么不同？" class="headerlink" title="==和===有什么不同？"></a>==和===有什么不同？</h1><p>首先，== equality 等同，=== identity 恒等。 ==， 两边值类型不同的时候，要先进行类型转换，再比较。 ===，不做类型转换，类型不同的一定不等。</p>
<p>先说 ===，这个比较简单。下面的规则用来判断两个值是否===相等： </p>
<ol>
<li>如果类型不同，就[不相等] </li>
<li>如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断） </li>
<li>如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。 </li>
<li>如果两个值都是true，或者都是false，那么[相等]。 </li>
<li>如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。 </li>
<li>如果两个值都是null，或者都是undefined，那么[相等]。 </li>
</ol>
<p>再说 ==，根据以下规则： </p>
<p>如果两个值类型相同，进行 === 比较。<br>如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： </p>
<ol>
<li>如果一个是null、一个是undefined，那么[相等]。 </li>
<li>如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 </li>
<li>如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 </li>
<li>如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方 法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。非js核心的对象，令说（比 较麻烦，我也不大懂） </li>
<li>任何其他组合，都[不相等]。 </li>
</ol>
<h1 id="你如何从浏览器的URL中获取查询字符串参数。"><a href="#你如何从浏览器的URL中获取查询字符串参数。" class="headerlink" title="你如何从浏览器的URL中获取查询字符串参数。"></a>你如何从浏览器的URL中获取查询字符串参数。</h1><p>以下函数把获取一个key的参数。</p>
<pre><code>function parseQueryString ( name ){
    name = name.replace(/[\[]/,&quot;\\\[&quot;);
    var regexS = &quot;[\\?&amp;]&quot;+name+&quot;=([^&amp;#]*)&quot;;
    var regex = new RegExp( regexS );
    var results = regex.exec( window.location.href );

    if(results == null) {
        return &quot;&quot;;
    } else { 
        return results[1];
    }
}
</code></pre><h1 id="请解释一下JavaScript的同源策略。"><a href="#请解释一下JavaScript的同源策略。" class="headerlink" title="请解释一下JavaScript的同源策略。"></a>请解释一下JavaScript的同源策略。</h1><p>在客户端编程语言中，如javascript和 ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚 本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的 HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。</p>
<h1 id="请描述一下JavaScript的继承模式"><a href="#请描述一下JavaScript的继承模式" class="headerlink" title="请描述一下JavaScript的继承模式"></a>请描述一下JavaScript的继承模式</h1><p> <a href="http://www.cnblogs.com/syfwhu/p/4415586.html" target="_blank" rel="external">关于继承请看文章JavaScript之对象的继承</a></p>
<h1 id="什么是三元表达式？“三元”表示什么意思？"><a href="#什么是三元表达式？“三元”表示什么意思？" class="headerlink" title="什么是三元表达式？“三元”表示什么意思？"></a>什么是三元表达式？“三元”表示什么意思？</h1><p>三元表达式：? :。三元–三个操作对象。</p>
<p>在表达式boolean-exp ? value0 : value1 中，如果“布尔表达式”的结果为true，就计算“value0”，而且这个计算结果也就是操作符最终产生的值。如果“布尔表达式”的结果为false， 就计算“value1”，同样，它的结果也就成为了操作符最终产生的值。</p>
<h1 id="JavaScript里函数参数arguments是数组吗？"><a href="#JavaScript里函数参数arguments是数组吗？" class="headerlink" title="JavaScript里函数参数arguments是数组吗？"></a>JavaScript里函数参数arguments是数组吗？</h1><p>在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，通过使用下标就可以访问相应的参数。</p>
<p>arguments虽然有一些数组的性质，但其并非真正的数组，只是一个类数组对象。其并没有数组的很多方法，不能像真正的数组那样调用.jion(),.concat(),.pop()等方法。</p>
<h1 id="什么是”use-strict”-使用它的好处和坏处分别是什么？"><a href="#什么是”use-strict”-使用它的好处和坏处分别是什么？" class="headerlink" title="什么是”use strict”;?使用它的好处和坏处分别是什么？"></a>什么是”use strict”;?使用它的好处和坏处分别是什么？</h1><p>在代码中出现表达式-“use strict”; 意味着代码按照严格模式解析，这种模式使得Javascript在更严格的条件下运行。</p>
<p>好处：</p>
<ul>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>
</ul>
<p>坏处：</p>
<p>同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。</p>
<h1 id="解释”chaining”。"><a href="#解释”chaining”。" class="headerlink" title="解释”chaining”。"></a>解释”chaining”。</h1><p>jQuery方法链接。直到现在，我们都是一次写一条jQuery语句（一条接着另一条）。不过，有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条jQuery命令，一条接着另一条。</p>
<p>提示：这样的话，浏览器就不必多次查找相同的元素。</p>
<p>如需链接一个动作，您只需简单地把该动作追加到之前的动作上。</p>
<h1 id="解释”deferreds”。"><a href="#解释”deferreds”。" class="headerlink" title="解释”deferreds”。"></a>解释”deferreds”。</h1><p>开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。</p>
<p>通常的做法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。</p>
<p>但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了deferred对象。</p>
<p>简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行</p>
<h1 id="你知道哪些针对jQuery的优化方法？"><a href="#你知道哪些针对jQuery的优化方法？" class="headerlink" title="你知道哪些针对jQuery的优化方法？"></a>你知道哪些针对jQuery的优化方法？</h1><h2 id="1-总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById-方法。"><a href="#1-总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById-方法。" class="headerlink" title="1. 总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById()方法。"></a>1. 总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById()方法。</h2><p>例如有一段HTML代码：</p>
<pre><code>&lt;div id=&quot;content&quot;&gt;
    &lt;form method=&quot;post&quot;action=&quot;#&quot;&gt;
        &lt;h2&gt;交通信号灯&lt;/h2&gt;
        &lt;ul id=&quot;traffic_light&quot;&gt;
            &lt;li&gt;
                &lt;input type=&quot;radio&quot;class=&quot;on&quot;name=&quot;light&quot;value=&quot;red&quot;/&gt;红色
            &lt;/li&gt;
            &lt;li&gt;
                &lt;input type=&quot;radio&quot;class=&quot;off&quot;name=&quot;light&quot;value=&quot;yellow&quot;/&gt;黄色
            &lt;/li&gt;
            &lt;li&gt;
                &lt;input type=&quot;radio&quot;class=&quot;off&quot;name=&quot;light&quot;value=&quot;green&quot;/&gt;绿色
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;input class=&quot;button&quot;id=&quot;traffic_button&quot;type=&quot;submit&quot;value=&quot;Go&quot;/&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre><p>比如需要选择红绿单选框，那么可以使用一个tag name来限制(修饰)class，如下所 示：var active_light=$(“input.on”);当然也可以结合就近的ID，如下所 示：var active_light=$(“#traffic_light input.on”);  如果采用下面的选择器，那么效率是低效的。var traffic_button=$(“#content.button”);因为button已经有 ID了，我们可以直接使用ID选择器。如下所示：var traffic_button=$(“#traffic_button”);当然这只是对于单一 的元素来讲。如果你需要选择多个元素，这必然会涉及到DOM遍历和循环，为了提高性能，建议从最近的ID开始继承。如下所示：</p>
<pre><code>var traffic_lights=$(“#traffic_light input”); 
</code></pre><h2 id="2-在class前使用tag-标签名-在jQuery中第二快的选择器是tag-标签-选择器-比如：-“head”"><a href="#2-在class前使用tag-标签名-在jQuery中第二快的选择器是tag-标签-选择器-比如：-“head”" class="headerlink" title="2. 在class前使用tag(标签名)在jQuery中第二快的选择器是tag(标签)选择器(比如：$(“head”))"></a>2. 在class前使用tag(标签名)在jQuery中第二快的选择器是tag(标签)选择器(比如：$(“head”))</h2><p>跟ID选择器累时，因为它来自原生的getElementsByTagName()方法。继续看刚才那段HTML代码：</p>
<p>在使用tag来修饰class的时候，我们需要注意以下几点：</p>
<pre><code>（1）不要使用tag来修饰ID，如下所 示：var content=$(“div#content”);这样一来，选择器会先遍历所有的div元素，然后匹配#content。（好像 jQuery从1.3.1开始改变了选择器核心后，不存在这个问题了。暂时无法考证。）
（2）不要画蛇添足的使用ID来修饰ID，如下所 示：var traffic_light=$(“#content#traffic_light”);
</code></pre><h2 id="3-将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。"><a href="#3-将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。" class="headerlink" title="3. 将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。"></a>3. 将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。</h2><p>下面是一个jQuery新手写的一段代码：</p>
<pre><code>$(&quot;#traffic_light input.on&quot;).bind(&quot;click&quot;,function(){});
$(&quot;#traffic_light input.on&quot;).css(&quot;border&quot;,&quot;1px dashed yellow&quot;);
$(&quot;#traffic_light input.on&quot;).css(&quot;background-color&quot;,&quot;orange&quot;);
$(&quot;#traffic_light input.on&quot;).fadeIn(&quot;slow&quot;);
</code></pre><p>但切记不要这么做。我们应该先将对象缓存进一个变量然后再操作，如下所示：</p>
<p>记住，永远不要让相同的选择器在你的代码里出现多次.注：</p>
<pre><code>（1）为了区分普通的JavaScript对象和jQuery对象，可以在变量首字母前加上$符号。
（2）上面代码可以使用jQuery的链式操作加以改善。如下所示：


     var $active_light = $(&quot;#traffic_light input.on&quot;);

     $active_light.bind(&quot;click&quot;,function(){})
     .css(&quot;border&quot;,&quot;1px dashed yellow&quot;)
     .css(&quot;background-color&quot;,&quot;orange&quot;)
     .fadeIn(&quot;slow&quot;);
</code></pre><h2 id="4-如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。"><a href="#4-如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。" class="headerlink" title="4. 如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。"></a>4. 如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。</h2><p>如下代码所示：</p>
<pre><code>// 在全局范围定义一个对象(例如:window对象)
window.$my = {
    head:$(&quot;head&quot;),
    trafficLight:$(&quot;#trafficLight&quot;),
    trafficButton:$(&quot;#trafficButton&quot;)
};

function doSomething(){
    // 现在你可以引用存储的结果并操作它们
    var script=document.createElement(&quot;script&quot;);
    $my.head.append(script);

    // 当你在函数内部操作是,可以继续将查询存入全局对象中去.
    $my.coolResults=$(&quot;#some_ul li&quot;);
    $my.otherResults=$(&quot;#some_table td&quot;);

    // 将全局函数作为一个普通的jquery对象去使用.
    $my.otherResults.css(&quot;border-color&quot;,&quot;red&quot;);
    $my.trafficLight.css(&quot;border-color&quot;,&quot;green&quot;);
}
// 你也可以在其他函数中使用它.
</code></pre><p>这里的基本思想是在内存中建立你确实想要的东西，然后更新DOM。这并不是一个jQuery最佳实践，但必须进行有效的JavaScript操作。直接的DOM操作速度很慢。例如，你想动态的创建一组列表元素，千万不要这样做,如下所示：对直接的DOM操作进行限制。</p>
<pre><code>var top_100_list = [];// 假设这里是100个独一无二的字符串
var $mylist = $(&quot;#mylist&quot;);// jQuery选择到&lt;ul&gt;元素

for(var i = 0,l = top_100_list.length;i&lt;l;i++) {
    $mylist.append(&quot;&lt;li&gt;&quot; + top_100_list[i] + &quot;&lt;/li&gt;&quot;);
}
</code></pre><p>我们应该将整套元素字符串在插入进dom中之前先全部创建好，如下所示：</p>
<pre><code>$(&quot;#entryform input&quot;).bind(&quot;focus&quot;,function() {
    $(this).addClass(&quot;selected&quot;);
}).bind(&quot;blur&quot;,function(){
    $(this).removeClass(&quot;selected&quot;);
});
</code></pre><h2 id="5-冒泡除非在特殊情况下-否则每一个js事件-例如-click-mouseover等-都会冒泡到父级节点。"><a href="#5-冒泡除非在特殊情况下-否则每一个js事件-例如-click-mouseover等-都会冒泡到父级节点。" class="headerlink" title="5. 冒泡除非在特殊情况下,否则每一个js事件(例如:click,mouseover等.)都会冒泡到父级节点。"></a>5. 冒泡除非在特殊情况下,否则每一个js事件(例如:click,mouseover等.)都会冒泡到父级节点。</h2><p>当我们需要给多个元素调用同个函数时这点会很有用。代替这种效率很差的多元素事件监听的方法就是,你只需向它们的父节点绑定一次。比如,我们要为一 个拥有很多输入框的表单绑定这样的行为:当输入框被选中时为它添加一个class传统的做法是，直接选中input，然后绑定focus等，如下所示：</p>
<pre><code>$(&quot;#entryform&quot;).bind(&quot;focus&quot;,function(e) {
    var $cell = $(e.target); // e.target捕捉到触发的目标元素
    $cell.addClass(&quot;selected&quot;);
}).bind(&quot;blur&quot;,function(e) {
    var $cell = $(e.target);
    $cell.removeClass(&quot;selected&quot;);
});
</code></pre><p>当然上面代码能帮我们完成相应的任务，但如果你要寻求更高效的方法，请使用如下代码：</p>
<p>通过在父级监听获取焦点和失去焦点的事件，对目标元素进行操作。在上面代码中，父级元素扮演了一个调度员的角色,它可以基于目标元素绑定事件。如果你发现你给很多元素绑定了同一个事件监听,那么现在的你肯定知道哪里做错了。</p>
<h2 id="6-推迟到-window-load。"><a href="#6-推迟到-window-load。" class="headerlink" title="6. 推迟到$(window).load。"></a>6. 推迟到$(window).load。</h2><p>jQuery对于开发者来说有一个很诱人的东西,可以把任何东西挂到$(document).ready下。尽管$(document).rady 确实很有用，它可以在页面渲染时，其它元素还没下载完成就执行。如果你发现你的页面一直是载入中的状态，很有可能就是$(document).ready 函数引起的。你可以通过将jQuery函数绑定到$(window).load事件的方法来减少页面载入时的cpu使用率。它会在所有的html(包括 iframe)被下载完成后执行。一些特效的功能，例如拖放,视觉特效和动画,预载入隐藏图像等等，都是适合这种技术的场合。</p>
<h2 id="7-压缩JavaScript。"><a href="#7-压缩JavaScript。" class="headerlink" title="7. 压缩JavaScript。"></a>7. 压缩JavaScript。</h2><p>在线压缩地址:<a href="http://dean.edwards.name/packer/" target="_blank" rel="external">http://dean.edwards.name/packer/</a> 压缩之前，请保证你的代码的规范性，否则可能失败，导致Js错误。</p>
<h2 id="8-尽量使用ID代替Class。"><a href="#8-尽量使用ID代替Class。" class="headerlink" title="8. 尽量使用ID代替Class。"></a>8. 尽量使用ID代替Class。</h2><p> 前面性能优化已经说过，ID选择器的速度是最快的。所以在HTML代码中，能使用ID的尽量使用ID来代替class。看下面的一个例子：</p>
<pre><code>// 创建一个list
var $myList = $(&apos;#myList&apos;);
var myListItems = &apos;&lt;ul&gt;&apos;;

for(var i = 0; i &lt; 1000; i ++) {
    myListItems += &apos;&lt;li class = &quot;listItem&apos;+i+&apos;&quot;&gt;This is a list item&lt;/li&gt;&apos;;
    // 这里使用的是class
}

myListItems += &apos;&lt;/ul&gt;&apos;;
$myList.html(myListItems);
// 选择每一个li

for(var i = 0; i&lt;1000; i++) {
    var selectedItem = $(&apos;.listItem&apos; + i);
}
</code></pre><p>在上段代码中，选择每个li总共只用了61毫秒，相比class的方式，将近快了100倍。       在代码最后，选择每个li的过程中，总共用了5066毫秒，超过5秒了。接着我们做一个对比，用ID代替class：</p>
<h2 id="9-给选择器一个上下文。"><a href="#9-给选择器一个上下文。" class="headerlink" title="9. 给选择器一个上下文。"></a>9. 给选择器一个上下文。</h2><p>jQuery选择器中有一个这样的选择器，它能指定上下文。jQuery(expression,context);通过它，能缩小选择器在DOM 中搜索的范围，达到节省时间，提高效率。普通方式：$(‘.myDiv’)改进方式：$(‘.myDiv’,$(“#listItem”))。</p>
<h2 id="10-慎用-live-方法（应该说尽量不要使用）。"><a href="#10-慎用-live-方法（应该说尽量不要使用）。" class="headerlink" title="10. 慎用.live()方法（应该说尽量不要使用）。"></a>10. 慎用.live()方法（应该说尽量不要使用）。</h2><p>这是jQuery1.3.1版本之后增加的方法，这个方法的功能就是为新增的DOM元素动态绑定事件。但对于效率来说，这个方法比较占用资源。所以请尽量不要使用它。例如有这么一段代码:</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    $(function(){

        $(&quot;p&quot;).click(function(){
            alert($(this).text());
        });

        $(&quot;button&quot;).click(function(){
            $(&quot;&lt;p&gt;this is second p&lt;/p&gt;&quot;).appendTo(&quot;body&quot;);
        });
    })
&lt;/script&gt;
&lt;body&gt;
    &lt;p&gt;this is first p&lt;/p&gt;
    &lt;button&gt;add&lt;/button&gt;
&lt;/body&gt;
</code></pre><p>运行后，你会发现新增的p元素，并没用被绑定click事件。你可以改成.live(“click”)方式解决此问题，代码如下：</p>
<pre><code>$(function() {
    $(&quot;p&quot;).live(&quot;click&quot;,function() {
        // 改成live方式
        alert($(this).text());
    });

    $(&quot;button&quot;).click(function() {
        $(&quot;&lt;p&gt;this is second p&lt;/p&gt;&quot;).appendTo(&quot;body&quot;);
    });
})
</code></pre><p>但我并不建议大家这么做，我想用另一种方式去解决这个问题，代码如下：</p>
<pre><code>$(function() {
    $(&quot;p&quot;).click(function() {
        alert($(this).text());
    });

    $(&quot;button&quot;).click(function() {
        $(&quot;&lt;p&gt;this is second p&lt;/p&gt;&quot;).click(function() {
            // 为新增的元素重新绑定一次
            alert($(this).text());
        }).appendTo(&quot;body&quot;);
    });
})
</code></pre><p>虽然我把绑定事件重新写了一次，代码多了点，但这种方式的效率明显高于live()方式，特别是在频繁的DOM操作中，这点非常明显。</p>
<h1 id="请说出你可以传递给jQuery方法的四种不同值。"><a href="#请说出你可以传递给jQuery方法的四种不同值。" class="headerlink" title="请说出你可以传递给jQuery方法的四种不同值。"></a>请说出你可以传递给jQuery方法的四种不同值。</h1><p>选择器（字符串），HTML（字符串），回调函数，HTML元素，对象，数组，元素数组，jQuery对象等。</p>
<h1 id="什么是效果队列？"><a href="#什么是效果队列？" class="headerlink" title="什么是效果队列？"></a>什么是效果队列？</h1><p>jQuery中有个动画队列的机制。当我们对一个对象添加多次动画效果时后添加的动作就会被放入这个动画队列中，等前面的动画完成后再开始执行。可 是用户的操作往往都比动画快，如果用户对一个对象频繁操作时不处理动画队列就会造成队列堆积，影响到效果。jQuery中有stop这个方法可以停止当前 执行的动画，并且它有两个布尔参数，默认值都为false。第一个参数为true时会清空动画队列，第二个参数为true时会瞬间完成掉当前动画。所以， 我们经常使用obj.stop(true,true)来停止动画。但是这还不够！正如jQuery文档中的说法，即使第二个参数为true，也仅仅是把当 前在执行的动画跳转到完成状态。这时第一个参数如果也为true，后面的队列就会被清空。如果一个效果需要多个动画同时处理，我们仅完成其中的一个而把后 面的队列丢弃了，这就会出现意料之外的结果。</p>
<h1 id="请指出-get-，-，eq-的区别。"><a href="#请指出-get-，-，eq-的区别。" class="headerlink" title="请指出.get()，[]，eq()的区别。"></a>请指出.get()，[]，eq()的区别。</h1><p><strong>eq:</strong> 返回是一个jquery对象作用是将匹配的元素集合缩减为一个元素。这个元素在匹配元素集合中的位置变为0，而集合长度变成1。</p>
<p><strong>get:</strong> 是一个html对象数组作用是取得其中一个匹配的元素。num表示取得第几个匹配的元素。</p>
<h1 id="请指出-bind-，-live-和-delegate-的区别。"><a href="#请指出-bind-，-live-和-delegate-的区别。" class="headerlink" title="请指出.bind()，.live()和.delegate()的区别。"></a>请指出.bind()，.live()和.delegate()的区别。</h1><p>在操纵DOM的语境中，document是根节点。现在我们可以较容易地说明.bind()、.live()和.delegate()的不同之处了。</p>
<p><strong>.bind()</strong></p>
<pre><code>$(&apos;a&apos;).bind(&apos;click&apos;, function() {alert(&quot;That tickles!&quot;)});
</code></pre><p>这是最简单的绑定方法了。JQuery扫描文档找出所有的$(‘a’)元素，并把alert函数绑定到每个元素的click事件上。</p>
<p><strong>.live()</strong></p>
<pre><code>$(&apos;a&apos;).live(&apos;click&apos;, function() {alert(&quot;That tickles!&quot;)});
</code></pre><p>JQuery把alert函数绑定到$(document)元素上，并使用’click’和’a’作为参数。任何时候只要有事件冒泡到 document节点上，它就查看该事件是否是一个click事件，以及该事件的目标元素与’a’这一CSS选择器是否匹配，如果都是的话，则执行函数。</p>
<p>live方法还可以被绑定到具体的元素(或context)而不是document上，像这样：</p>
<pre><code>$(&apos;a&apos;, $(&apos;#container&apos;)[0]).live(...);
</code></pre><p><strong>.delegate()</strong></p>
<pre><code>$(&apos;#container&apos;).delegate(&apos;a&apos;, &apos;click&apos;, function() {alert(&quot;That tickles!&quot;)});
</code></pre><p>JQuery扫描文档查找$(‘#container’)，并使用click事件和’a’这一CSS选择器作为参数把alert函数绑定 到$(‘#container’)上。任何时候只要有事件冒泡到$(‘#container’)上，它就查看该事件是否是click事件，以及该事件的目 标元素是否与CCS选择器相匹配。如果两种检查的结果都为真的话，它就执行函数。</p>
<p>可以注意到，这一过程与.live()类似，但是其把处理程序绑定到具体的元素而非document这一根上。精明的JS’er们可能会做出这样的结论，即$(‘a’).live()==$(document).delegate(‘a’)，是这样吗?嗯，不，不完全是。</p>
<p>为什么.delegate()要比.live()好用？</p>
<p>基于几个原因，人们通常更愿意选用jQuery的delegate方法而不是live方法。考虑下面的例子：</p>
<pre><code>$(&apos;a&apos;).live(&apos;click&apos;, function(){blah()}); // 或者
$(document).delegate(&apos;a&apos;, &apos;click&apos;, function(){blah()});
</code></pre><p><strong>速度</strong></p>
<p>后者实际上要快过前者，因为前者首先要扫描整个的文档查找所有的$(‘a’)元素，把它们存成jQuery对象。尽管live函数仅需要把’a’作 为串参数传递以用做之后的判断，但是$()函数并未知道被链接的方法将会是.live()。而另一方面，delegate方法仅需要查找并存 储$(document)元素。</p>
<p>一种寻求避开这一问题的方法是调用在$(document).ready()之外绑定的live，这样它就会立即执行。在这种方式下，其会在DOM获得填充之前运行，因此就不会查找元素或是创建jQuery对象了。</p>
<p><strong>灵活性和链能力</strong></p>
<p>live函数也挺令人费解的。想想看，它被链到$(‘a’)对象集上，但其实际上是在$(document)对象上发生作用。由于这个原因，它能够 试图以一种吓死人的方式来把方法链到自身上。实际上，我想说的是，以$.live(‘a’,…)这一形式作为一种全局性的jQuery方法，live方法 会更具意义一些。</p>
<p><strong>仅支持CSS选择器</strong></p>
<p>最后一点，live方法有一个非常大的缺点，那就是它仅能针对直接的CSS选择器做操作，这使得它变得非常的不灵活。</p>
<p>为什么选择.live()或.delegate()而不是.bind()？<br>毕竟，bind看起来似乎更加的明确和直接，难道不是吗?嗯，有两个原因让我们更愿意选择delegate或live而不是bind：</p>
<p>为了把处理程序附加到可能还未存在于DOM中的DOM元素之上。因为bind是直接把处理程序绑定到各个元素上，它不能把处理程序绑定到还未存在于页面中的元素之上。</p>
<p>如果你运行了$(‘a’).bind(…)，而后新的链接经由AJAX加入到了页面中，则你的bind处理程序对于这些新加入的链接来说是无效的。 而另一方面live和delegate则是被绑定到另一个祖先节点上，因此其对于任何目前或是将来存在于该祖先元素之内的元素都是有效的。</p>
<p>或者为了把处理程序附加到单个元素上或是一小组元素之上，监听后代元素上的事件而不是循环遍历并把同一个函数逐个附加到DOM中的100个元素上。把处理程序附加到一个(或是一小组)祖先元素上而不是直接把处理程序附加到页面中的所有元素上，这种做法带来了性能上的好处。</p>
<p><strong>停止传播</strong></p>
<p>最后一个我想做的提醒与事件传播有关。通常情况下，我们可以通过使用这样的事件方法来终止处理函数的执行：</p>
<pre><code>$(&apos;a&apos;).bind(&apos;click&apos;, function(e) {
    e.preventDefault();
    // 或者 e.stopPropagation();
});
</code></pre><p>不过，当我们使用live或是delegate方法的时候，处理函数实际上并没有在运行，需要等到事件冒泡到处理程序实际绑定的元素上时函数才会运行。而到此时为止，我们的其他的来自.bind()的处理函数早已运行了。</p>
<h1 id="请指出-和-fn的区别，或者说出-fn的用途。"><a href="#请指出-和-fn的区别，或者说出-fn的用途。" class="headerlink" title="请指出$和$.fn的区别，或者说出$.fn的用途。"></a>请指出$和$.fn的区别，或者说出$.fn的用途。</h1><p>Jquery为开发插件提供了两个方法，分别是：</p>
<pre><code>$.extend(obj);
$.fn.extend(obj);
</code></pre><p>1.那么这两个分别是什么意思？</p>
<pre><code>$.extend(obj);是为了扩展jquery本身，为类添加新的方法。

$.fn.extend(obj);给JQUERY对象添加方法。
</code></pre><p>2.$.fn中的fn是什么意思，其实是prototype，即$.fn=$.prototype;<br>具体用法请看下面的例子：</p>
<pre><code>$.extend({

    add:function(a, b) {
        return a+b;
    }
})

$.add(5,8); // return 13
</code></pre><p>注意没有，这边的调用直接调用，前面不用任何对象。直接$.+方法名</p>
<p>$.fn.extend(obj)；对prototype进行扩展，为jquery类添加成员函数，jquery类的实例可以使用这个成员函数。</p>
<pre><code>$.fn.extend({

    clickwhile:function(){

        $(this).click(function(){
            alert($(this).val())
        })
    }
})

$(&apos;input&apos;).clickwhile(); // 当点击输入框会弹出该对象的Value值
</code></pre><p>注意调用时候前面是有对象的。即$(‘input’)这么个东西。</p>
<h1 id="var-foo-foo-push-1-foo-push-2-问题：foo-length的值是什么？"><a href="#var-foo-foo-push-1-foo-push-2-问题：foo-length的值是什么？" class="headerlink" title="var foo=[];foo.push(1);foo.push(2);问题：foo.length的值是什么？"></a>var foo=[];foo.push(1);foo.push(2);问题：foo.length的值是什么？</h1><p> 答案：2</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/HTML面试题/" itemprop="url">
                  HTML面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T11:06:38+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/H5面试题/" itemprop="url" rel="index">
                    <span itemprop="name">H5面试题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/HTML面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/HTML面试题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTML和XHTML有什么区别？"><a href="#HTML和XHTML有什么区别？" class="headerlink" title="HTML和XHTML有什么区别？"></a>HTML和XHTML有什么区别？</h1><h2 id="XHTML-HTML"><a href="#XHTML-HTML" class="headerlink" title="XHTML,HTML"></a>XHTML,HTML</h2><p>   XHTML 与 HTML 4.01 标准没有太多的不同， XHTML1.0 是 XML 风格的 HTML4.01 ,标签的规范更加严格 , W3C一直是推崇XHTML这种严格类型的语法, 但是 XHTML 从 1.0 升级到了 1.1 以后就夭折了。</p>
<h2 id="html和xhtml最主要的不同："><a href="#html和xhtml最主要的不同：" class="headerlink" title="html和xhtml最主要的不同："></a>html和xhtml最主要的不同：</h2><ul>
<li><p>XHTML 元素必须被正确地嵌套。</p>
<pre><code>错误：&lt;Head&gt;&lt;/Head&gt;&lt;Body&gt;&lt;/Body&gt;
正确：&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;
</code></pre></li>
<li><p>XHTML 元素必须被关闭。</p>
<pre><code>错误：&lt;p&gt;xxxx
正确: &lt;p&gt;xxxx&lt;/p&gt;
</code></pre></li>
<li><p>标签名必须用小写字母。</p>
<pre><code>错误：&lt;Div&gt;&lt;/diV&gt;
正确：&lt;div&gt;&lt;/div&gt;
</code></pre></li>
<li><p>XHTML 文档必须拥有根元素。</p>
</li>
<li><p>其他</p>
<p>  不允许使用target=”_blank”</p>
<p>  从XHTML 1.1开始全面禁止target属性，如果想要有开新窗口的功能，就必须改写为rel=”external”，并搭配JavaScript实现此效果。</p>
<pre><code>错误：&lt;a href=&quot;http://blog.mukispace.com&quot; target=&quot;_blank&quot;&gt;MUKI space&lt;/a&gt;

正确：&lt;a href=&quot;http://blog.mukispace.com&quot; rel=&quot;external&quot;&gt;MUKI space&lt;/a&gt;
</code></pre></li>
</ul>
<h1 id="如果页面使用-‘application-xhtml-xml’-会有什么问题吗？"><a href="#如果页面使用-‘application-xhtml-xml’-会有什么问题吗？" class="headerlink" title="如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗？"></a>如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗？</h1><p>一些老的浏览器不支持，实际上，任何最新的浏览器都将支持application/xhtml+xml媒体类型。大多数浏览器也接受以application/xml发送的XHTML文档。</p>
<h1 id="doctype（文档类型）的作用是什么？你知道多少种文档类型？"><a href="#doctype（文档类型）的作用是什么？你知道多少种文档类型？" class="headerlink" title="doctype（文档类型）的作用是什么？你知道多少种文档类型？"></a>doctype（文档类型）的作用是什么？你知道多少种文档类型？</h1><ul>
<li><p>此标签可告知浏览器文档使用哪种HTML或XHTML规范。该标签可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的HTML文档。</p>
</li>
<li><p>HTML 4.01规定了三种文档类型：Strict、Transitional以及Frameset。</p>
</li>
<li><p>XHTML 1.0规定了三种XML文档类型：Strict、Transitional以及Frameset。</p>
</li>
<li><p>Standards（标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>
</li>
</ul>
<h1 id="浏览器标准模式和怪异模式之间的区别是什么？"><a href="#浏览器标准模式和怪异模式之间的区别是什么？" class="headerlink" title="浏览器标准模式和怪异模式之间的区别是什么？"></a>浏览器标准模式和怪异模式之间的区别是什么？</h1><p>W3C标准推出以后，浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编 写的，如果用的标准来渲染，将导致页面显示异常。为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的IE）。 这样浏览器渲染上就产生了Quircks mode和Standars mode，两种渲染方法共存在一个浏览器上。IE盒子模型和标准W3C盒子模 型：ie的width包括：padding\border。标准的width不包括：padding\border</p>
<h1 id="使用XHTML的局限有哪些？"><a href="#使用XHTML的局限有哪些？" class="headerlink" title="使用XHTML的局限有哪些？"></a>使用XHTML的局限有哪些？</h1><p>XHTML 与HTML的区别为：</p>
<p>XHTML 元素必须被正确地嵌套。<br>XHTML 元素必须被关闭。<br>标签名必须用小写字母。<br>XHTML 文档必须拥有根元素。<br>局限：</p>
<p>所有的 XHTML 元素都必须被正确地嵌套，XHTML 必须拥有良好的结构，所有的标签必须小写，并且所有的 XHTML 元素必须被关闭。所有的 XHTML 文档必须拥有 DOCTYPE 声明，并且 html、head、title 和 body 元素必须存在。虽然代码更加的优雅，但缺少容错性，不利于快速开发。</p>
<h1 id="如果把HTML5看作做一个开放平台，那它的构建模块有哪些？"><a href="#如果把HTML5看作做一个开放平台，那它的构建模块有哪些？" class="headerlink" title="如果把HTML5看作做一个开放平台，那它的构建模块有哪些？"></a>如果把HTML5看作做一个开放平台，那它的构建模块有哪些？</h1><p><nav>,<header>,<section>,<footer>等。</footer></section></header></nav></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/多线程理论部分/" itemprop="url">
                  多线程理论部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T10:33:06+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/多线程理论部分/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/多线程理论部分/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><p>线程是用来执行任务的，线程彻底执行完任务A才能去执行任务B。为了同时执行两个任务，产生了多线程。</p>
</li>
<li><p>我打开一个视频软件，我开辟一个线程A让它执行下载任务，我开辟一个线程B，用来播放视频。我开辟两个线程后，这两个任务能同时执行，如果我开辟一个线程，只有下载任务完成，才能去执行播放任务。</p>
</li>
<li><p>线程相当于店里的服务员，一个服务员同时只能做一件事情，多顾几个服务员，就能同时做很多事情。</p>
</li>
</ul>
<h1 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li><p>进程是应用程序的执行实例,简单来说就是在操作系统中<code>运行的</code>程序。例如我在手机上只打开QQ和微信这两个软件，系统中就会有两个进程存在。</p>
</li>
<li><p>进程不能执行任务</p>
</li>
<li><p>进程在运行时创建的资源随着进程的终止而死亡。</p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>进程本身是不能执行任务的,进程想要执行任务必须的有线程,线程是进程内部的一个独立的执行单元，同时只能执行一个任务，相当于一个子程序。线程被分为两种,<code>主线程</code>(用户界面线程)和<code>子线程</code>(工作线程或称为后台线程)。我在望京(操作系统)开了一个橘子产品体验店(进程)，里面有很多工作人员，有店长帮我布置门面(主线程)，咨询人员(子线程)、销售人员(子线程)。</li>
</ul>
<ul>
<li><p>线程执行完毕就会被销毁。</p>
</li>
<li><p><strong><em>主线程(也称父线程)</em></strong>：当应用程序启动时自动创建和启动，通常用来处理用户的输入并响应各种事件和消息。主线程的终止也意味着该程序的结束。</p>
</li>
<li><p><strong><em>子线程</em></strong>：由主线程来创建,用来帮助主线程执行程序的后台处理任务。如果子线程A中又创建一个子线程B，在创建之后，这两者就是相互独立的，多个子线程之间<code>效果上</code>可以同时执行。</p>
</li>
<li><p>一个进程中可以有多个线程，并且所有线程都在该进程的虚拟地址空间中，可以使用进程的全局变量和系统资源。</p>
</li>
<li><p>线程状态：<a href="http://blog.csdn.net/peter_teng/article/details/10197785" target="_blank" rel="external">线程的五种状态</a></p>
</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li><p>目前大多数的app,都需要连接服务器，而访问服务器的速度可能快也可能很慢。如果一个app访问服务器的操作没有在子线程操作的话，在该app访问服务器的过程中，该软件是不能响应用户的操作的，只有该app访问结束以后，app才能响应用户的操作，这就造成线程阻塞，也就是我们常见的卡顿现象。一条线程在同一时间内只能执行一个任务,但是进程可以有多条线程。可以开启多条线程来执行不同的任务,从而提高程序的执行效率，避免线程阻塞。  </p>
</li>
<li><p>操作系统会根据线程的优先级(线程的优先级可以手动设置)来安排CPU的时间，优先级高的线程，优先调用的几率会更大，同级的话，看线程执行的先后。</p>
</li>
<li><p>同一时间内，CPU只能处理一条线程，只有一条线程在工作。多线程并行执行，其实就是各个线程不断切换，因为执行切换的时间很快很快，就造成了同时执行的假象，原理如下，比如A，B两个线程；</p>
<ol>
<li><p>A执行到某一时间段要切换了，可A任务没完成，系统就会把A当前执行的位置和数据以入栈的方式保存起来</p>
</li>
<li><p>然后B线程执行，B执行时间到了，它的位置状态等也会被系统保存到B的栈中。</p>
</li>
<li><p>系统自动找到A的栈，将A之前保存的数据恢复，又可以从A之前断开的状态继续执行下去，如此循环</p>
</li>
</ol>
<ul>
<li>系统每开一个线程都有比较大的开销。若线程开的过多，不仅会占用大量内存和让程序变得更加复杂，而且会加重CPU的负担，这样的软件，会使你的手机在冬天变成暖手宝。</li>
</ul>
</li>
</ul>
<h1 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h1><ul>
<li>提高程序执行效率，避免线程阻塞造成的卡顿现象。</li>
<li><p>能适当提高资源利用率(CPU,内存)。</p>
</li>
<li><p><strong>不可滥用多线程</strong>：</p>
<ol>
<li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB，可以自己设置内存大小，但必须是4的倍数），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>
<li>线程越多，CPU在调度线程上的开销就越大</li>
<li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li>
</ol>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><strong>线程与进程的关系</strong><ol>
<li>线程是CPU执行任务的基本单位，一个进程可以有多个线程，但同时只能执行一个任务。</li>
<li>进程就是运行中的软件，是动态的。</li>
<li>一个操作系统可以对应多个进程,一个进程可以有多条线程,但至少有一个线程</li>
<li>同一个进程内的线程共享进程里的资源</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>主线程</strong></p>
<ol>
<li>进程一启动就自动创建</li>
<li>显示和刷新UI界面</li>
<li>处理UI事件</li>
</ol>
</li>
<li><p><strong>子线程的作用</strong> </p>
<ol>
<li>处理耗时的操作</li>
<li>子线程不能用来刷新UI</li>
</ol>
</li>
</ul>
<h1 id="三种多线程编程技术"><a href="#三种多线程编程技术" class="headerlink" title="三种多线程编程技术"></a>三种多线程编程技术</h1><h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><ul>
<li><p>NSThread是轻量级的多线程开发，使用并不复杂，但使用NSThread需要自己管理线程的声明周期。</p>
</li>
<li><p><a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSThread/" target="_blank" rel="external">NSThread详解</a></p>
</li>
</ul>
<h2 id="Cocoa-NSOperation"><a href="#Cocoa-NSOperation" class="headerlink" title="Cocoa NSOperation"></a>Cocoa NSOperation</h2><ul>
<li><p>使用NSOperation和NSOperationQueue进行多线程开发类似于线程池，只要将一个NSOperation(实际开发中需要使用其子类NSInvocationOperation、NSBlockOperation)放到NSOperationQueue这个队列中线程就会依次启动。NSOperationQueue负责管理、执行所有的NSOperation，在这个过程中可以更加容易管理线程总数和控制线程之间的依赖关系。</p>
</li>
<li><p>NSOperation有两常用子类用于创建线程操作：NSInvocationOperation和NSBlockOperation，两种方式本质没有区别，但后者使用block形式进行代码组织，使用相对方便。</p>
</li>
<li><p><a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSOperation/" target="_blank" rel="external">NSOperation详解</a></p>
</li>
</ul>
<h2 id="GCD-Grand-Central-Dispatch"><a href="#GCD-Grand-Central-Dispatch" class="headerlink" title="GCD(Grand Central Dispatch)"></a>GCD(Grand Central Dispatch)</h2><ul>
<li><p>GCD是基于C语言开发的一套多线程开发机制，也是目前苹果官网推荐的多线程开发方法。</p>
</li>
<li><p>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程），程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</p>
</li>
<li><p>GCD是这三种多线程开发方式中抽象层次最高的，使用起来也是最为方便的，只是基于C语言开发，并不像前两种是面向对象开发，而是完全面向过程的。这种机制相比较于前面两种多线程开发方式最显著的优点就是<code>它对于多核运算更加有效，会自动利用更多的CPU内核(比如双核、四核)</code>。</p>
</li>
<li><p>GCD中也有一个类似于NSOperationQueue的队列，GCD统一管理整个队列中的任务。但是GCD中的队列分为并行队列和串行队列两类：         </p>
<blockquote>
<p>串行队列：只有一个线程，加入到队列中的操作按添加顺序依次执行。<br>并发队列：有多个线程，操作进来以后他会将这些线程安排在可用的处理器上，同时保证先进来的任务优先处理。</p>
<p>其实在GCD中还有一个特殊队列就是主队列，用来执行主线程上的操作任务。</p>
</blockquote>
</li>
</ul>
<ul>
<li><a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BGCD/" target="_blank" rel="external">GCD详解</a></li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><p>无论使用哪种方法进行多线程开发，每个线程启动后并不一定立即执行相应的操作，具体什么时候由系统调度（CPU空闲时就会执行）</p>
</li>
<li><p>更新UI应该在主线程（UI线程）中进行，并且推荐使用同步调用，常用的方法如下：</p>
<pre><code>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait 

- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL) wait;方法传递主线程[NSThread mainThread])

[[NSOperationQueue mainQueue] addOperationWithBlock:^{}];

dispatch_sync(dispatch_get_main_queue(), ^{})  
</code></pre></li>
</ul>
<ul>
<li><p>NSThread适合轻量级多线程开发，控制线程顺序比较难，同时线程总数无法控制（每次创建并不能重用之前的线程，只能创建一个新的线程）。</p>
</li>
<li><p>对于简单的多线程开发建议使用NSObject的扩展方法完成，而不必使用NSThread。</p>
</li>
<li><p>可以使用NSThread的currentThread方法取得当前线程，使用 sleepForTimeInterval:方法让当前线程休眠。</p>
</li>
<li><p>NSOperation进行多线程开发可以控制线程总数及线程依赖关系。</p>
</li>
<li><p>创建一个NSOperation不应该直接调用start方法（如果直接start则会在主线程中调用）而是应该放到NSOperationQueue中启动。</p>
</li>
<li><p>相比NSInvocationOperation推荐使用NSBlockOperation，代码简单，同时由于闭包性使它没有传参问题。</p>
</li>
<li><p>NSOperation是对GCD面向对象的ObjC封装，但是相比GCD基于C语言开发，效率却更高，建议如果任务之间有依赖关系或者想要监听任务完成状态的情况下优先选择NSOperation否则使用GCD。</p>
</li>
<li><p>在GCD中串行队列中的任务被安排到一个单一线程执行（不是主线程），可以方便地控制执行顺序；并发队列在多个线程中执行（前提是使用异步方法），顺序控制相对复杂，但是更高效。</p>
</li>
<li><p>在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并行队列并且使用异步方法执行时才能在多个线程中执行（如果是并行队列使用同步方法调用则会在主线程中执行）。</p>
</li>
<li><p>相比使用NSLock，@synchronized更加简单，推荐使用后者。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/多线程NSThread/" itemprop="url">
                  多线程NSThread
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T10:16:55+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/多线程NSThread/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/多线程NSThread/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 这篇文章主要讲NSThread的使用，相关博客如下：<br> <a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/" target="_blank" rel="external">iOS开发之多线程理论部分</a><br> <a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSOperation/" target="_blank" rel="external">NSOperation</a></p>
<h1 id="什么是NSThread"><a href="#什么是NSThread" class="headerlink" title="什么是NSThread"></a>什么是NSThread</h1><p>NSThread是轻量级的多线程开发，使用并不复杂，但使用NSThread需要自己管理线程的生命周期。</p>
<h1 id="使用NSThread开辟线程的两种方式"><a href="#使用NSThread开辟线程的两种方式" class="headerlink" title="使用NSThread开辟线程的两种方式"></a>使用NSThread开辟线程的两种方式</h1><ol>
<li>创建并手动开启线程<pre><code>NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(compete) object:nil];   
[thread start];
</code></pre></li>
<li>创建并自动开启线程<pre><code>[NSThread detachNewThreadSelector:@selector(compete) toTarget:self withObject:nil];
</code></pre></li>
</ol>
<h1 id="NSThread的常用方法"><a href="#NSThread的常用方法" class="headerlink" title="NSThread的常用方法"></a>NSThread的常用方法</h1><ol>
<li><p><strong>判断当前进程是否是多线程</strong></p>
<pre><code>BOOL isMultiThread = [NSThread isMultiThreaded];
</code></pre></li>
<li><p><strong>获取当前线程对象</strong></p>
<pre><code>//输出当前线程的信息
NSLog(@&quot;当前所在的线程=%@&quot;,[NSThread currentThread]);
</code></pre><p>控制台</p>
<blockquote>
<p>NSThread[10433:1182963] viewDidLoad 方法所在的线程=<nsthread: 0x7fca98507b10="">{number = 1, name = main}</nsthread:></p>
<p><strong>number = 1 ： 线程的编号，由系统设置，主线程的编号为1</strong><br><strong>name = main：指当前所在的线程的名字叫做main,可以自己设置，主线程的名字默认是main，其他线程如果不给他设置名字默认是nil。</strong></p>
</blockquote>
</li>
<li><p><strong>使当前线程睡眠指定的时间，单位为秒</strong></p>
<pre><code>//这句代码在哪个线程执行就让哪个线程睡眠。
[NSThread sleepForTimeInterval:2];
</code></pre><p><strong>线程一旦休眠就进入阻塞状态，就是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。</strong></p>
</li>
<li><p><strong>设置线程的优先级</strong></p>
<pre><code>//取值范围(0.0~1.0),默认为0.5,取值越大,优先级越大。
thread.threadPriority = 1.0;
</code></pre></li>
<li><p><strong>判断当前线程是否为主线程</strong></p>
<pre><code>[NSThread isMainThread];
</code></pre></li>
<li><p><strong>给线程设置名字</strong></p>
<pre><code>[thread setName:@&quot;线程名字&quot;]; 
</code></pre></li>
<li><p><strong>NSThread对象可知的三种状态</strong></p>
<pre><code>isExecuting：是否正在执行，只读
isFinished：是否已经完成，只读
isCancellled：是否已经取消，可通过[thread cancel]手动设置，线程取消意味着该线程处于准备退出状态，但不会影响线程的运行。
</code></pre></li>
<li><strong>退出当前线程</strong><pre><code>//线程退出前，必须要要，该线程之后的代码将不在执行
if (thread.isCancelled == YES) {
    [NSThread exit];
}
</code></pre></li>
</ol>
<h1 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h1><h2 id="使用多线程加载一张url图片"><a href="#使用多线程加载一张url图片" class="headerlink" title="使用多线程加载一张url图片"></a>使用多线程加载一张url图片</h2><ol>
<li>在self.view上放一个UIImageView试图</li>
<li>开辟一条子线程</li>
<li>在<code>子线程</code>中将url图片转成image对象</li>
<li>回到<code>主线程</code></li>
<li><p>在主线程中将image对象给UIImageView试图</p>
<pre><code>//
//  ViewController.m
//  NSThread
//
//  Created by GG on 16/2/18.
//  Copyright © 2016年 GG. All rights reserved.
//

#import &quot;ViewController.h&quot;

#define kUrl @&quot;http://store.storeimages.cdn-apple.com/8748/as-images.apple.com/is/image/AppleInc/aos/published/images/s/38/s38ga/rdgd/s38ga-rdgd-sel-201601?wid=848&amp;hei=848&amp;fmt=jpeg&amp;qlt=80&amp;op_sharpen=0&amp;resMode=bicub&amp;op_usm=0.5,0.5,0,0&amp;iccEmbed=0&amp;layer=comp&amp;.v=1454777389943&quot;

@interface ViewController ()
{
    UIImageView *imageView;
}

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    /*
     * 1、在self.view上放一个UIImageView试图
     */
    imageView = [[UIImageView alloc]initWithFrame:CGRectMake(50, 50, 200, 200)];
    [self.view addSubview:imageView];

    /*
     * 2、 开辟一条子线程(我这里采用创建并手动开启线程的方式)

     * target: 信息发送者

     * selector: 方法选择器选择一个方法

     * object: 如果上面选择的方法有参数，则object便是这个方法的参数

     */
    NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(downloadImage:) object:kUrl];

    //给线程起名字
    thread.name = @&quot;子线程&quot;;

    // 开启线程
    [thread start];

}

/*
 * 3、 在`子线程`中将url图片转成image对象

 *  downloadImage该方法的参数取决于创建线程时传给object的参数

 */
- (void)downloadImage:(NSString *)url{

    //将图片的url地址转化为data对象
    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:kUrl]];

    //将data对象转化为image对象
    UIImage *image = [UIImage imageWithData:data];

    /* 
     * 4. 是NSObject的一个方法，用来回到主线程

     * 方法updataUI将在主线程中执行

     * withObject:updateUI的参数

     * waitUntilDone: 设为YES，会阻塞当前子线程，去主线程执行updateUI方法，也就是更新UI，直到UI更新完毕。设为NO,意味着在主线程updateUI方法执行到一半时可能会被打断去做其他线程的工作，也就是说我主线程的UI还没有显示完就程序就跳出了主线程。
     */
    [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];

    /*

     * 查看打印结果

     * number = 1 ：线程的编号，由系统设置，主线程的编号为1

     * name = main：指当前所在的线程的名字叫做main,可以自己设置，主线程的名字默认是main，其他线程如果不给他设置名字默认是nil

     */
    NSLog(@&quot;downlaodImage方法所在的线程 = %@&quot;,[NSThread currentThread]);

            }

/*
 * 5、 在主线程中将image对象给UIImageView试图
 */

- (void)updateUI:(UIImage *)image{

    imageView.image = image;

    NSLog(@&quot;downlaodImage方法所在的线程 = %@&quot;,[NSThread currentThread]);

}

@end
</code></pre></li>
</ol>
<h2 id="使用多线程加载多张图片"><a href="#使用多线程加载多张图片" class="headerlink" title="使用多线程加载多张图片"></a>使用多线程加载多张图片</h2><ol>
<li>在self.view上放多个UIImageView试图</li>
<li>开辟多条子线程</li>
<li>在<code>子线程</code>中将url图片转成image对象</li>
<li>回到<code>主线程</code></li>
<li><p>在主线程中将image对象给UIImageView试图</p>
<pre><code>//
//  MoreImageViewViewController.m
//  NSThread
//
//  Created by GG on 16/2/22.
//  Copyright © 2016年 GG. All rights reserved.
//

#pragma mark ------------------NSThread分析详解 http://www.jianshu.com/p/b1c2bd572e81-------------

#import &quot;MoreImageViewViewController.h&quot;

#define kUrl @&quot;http://store.storeimages.cdn-apple.com/8748/as-images.apple.com/is/image/AppleInc/aos/published/images/s/38/s38ga/rdgd/s38ga-rdgd-sel-201601?wid=848&amp;hei=848&amp;fmt=jpeg&amp;qlt=80&amp;op_sharpen=0&amp;resMode=bicub&amp;op_usm=0.5,0.5,0,0&amp;iccEmbed=0&amp;layer=comp&amp;.v=1454777389943&quot;

@interface MoreImageViewViewController ()
{
    int imageIndex;

    NSMutableArray *threadArrays;

    UIImage *image;
}

@end

@implementation MoreImageViewViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    UILabel *lable = [[UILabel alloc]initWithFrame:CGRectMake(100, 300, 0, 0)];
    lable.text = @&quot;点击屏幕停止加载&quot;;
    lable.textColor = [UIColor blackColor];
    [lable sizeToFit];
    [self.view addSubview:lable];

    //创建多个UIImageView
    self.title = @&quot;多线程加载多张图片&quot;;
    self.edgesForExtendedLayout = UIRectEdgeNone;
    self.view.backgroundColor = [UIColor whiteColor];

    imageIndex = 100;

    for (int  row= 0; row&lt;3; row++) {
        for (int list = 0; list&lt;2; list++) {

            UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(10+list*200, 10+row*200, 200, 200)];

            imageView.tag = imageIndex++;

            [self.view addSubview:imageView];

        }
    }

    threadArrays = [NSMutableArray array];

    //创建多个线程
    for (int index = 0; index&lt;6; index++) {
        //此时我传的参数是线程创建的顺序
        NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(downloadImage:) object:@(index)];

        //给线程设置优先级（0-1），优先级越高，被优先调用的几率越高。
//        thread.threadPriority = index/10.0;
        thread.name = [NSString stringWithFormat:@&quot;线程%d&quot;,index];
        [thread start];

        [threadArrays addObject:thread];

    }
}

//每条线程都会走这个方法，来下载相应的图片，在这里为了方便起见，我采用了同一个url图片
- (void)downloadImage:(NSNumber *)index{

    /*

     * 通过线程的休眠来实现图片的顺序加载

        1. 第一个线程，休眠0秒，第二个线程休眠1秒...第六个线程休眠5面

        2. 正常的流程如下（基于线程同时执行的原理，多线程理论部分有介绍到）

           1. 多线程开启，并在线程中写上线程休眠代码
           2. 线程执行到休眠代码，停止执行
           3. 点击屏幕，将为完成的线程设为取消状态
           4. 休眠结束，线程进行判断是否被取消，被取消就退出

        3. 错误流程

           1. 多线程开启，并在线程中写上线程休眠代码
           2. 线程进行判断是否被取消，被取消就退出
           3. 线程执行到休眠代码，停止执行
           4. 点击屏幕，将为完成的线程设为取消状态
           5. 休眠结束，继续执行线程

     */
    [NSThread sleepForTimeInterval:[index integerValue]];

    NSThread *currentThread = [NSThread currentThread];
    //如果当前线程处于取消状态，则退出当前线程
    if (currentThread.isCancelled) {
        NSLog(@&quot;thread(%@) will be cancelled!&quot;,currentThread);
        [NSThread exit];//退出当前线程
    }

    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:kUrl]];

    image = [UIImage imageWithData:data];

    //用index找到相应线程的数据，赋给相应的图片试图。
    [self performSelectorOnMainThread:@selector(updateUI:) withObject:index waitUntilDone:YES];

    NSThread *thread = [NSThread currentThread];
    NSLog(@&quot;当前线程是 = %@&quot;,thread.name);

}

- (void)updateUI:(NSNumber *)ktest{

        UIImageView *imageView = [self.view viewWithTag:100+[ktest integerValue]];

        imageView.image = image;

}

//点击屏幕将没有完成的线程设置为取消状态
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{

    for (int i=0; i&lt;6; i++) {
        NSThread *thread= threadArrays[i];
        //判断线程是否完成，如果没有完成则设置为取消状态
        //注意设置为取消状态仅仅是改变了线程状态而言，并不能终止线程
        if (!thread.isFinished) {
            [thread cancel];

            NSLog(@&quot;============&quot;);

        }
    }

}

@end
</code></pre><p>顺序启动的线程一般不会按照启动顺序执行，这是因为线程都创建好以后，CPU会根据实际情况（网速、启动时间、优先级等）来决定执行线程的先后顺序，<strong>在这里我采用线程sleep的方式实现了线程的顺序执行。</strong></p>
</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p> 为了简化多线程开发过程，苹果官方对NSObject进行分类扩展(本质还是创建NSThread)，对于简单的多线程操作可以直接使用这些扩展方法。</p>
<pre><code>//在后台执行一个操作，本质就是重新创建一个线程执行当前方法。
- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg：

//在指定的线程上执行一个方法，需要用户创建一个线程对象。
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait：

//在主线程上执行一个方法（前面已经使用过）。
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait：
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/01/多线程GCD/" itemprop="url">
                  多线程GCD
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-01T10:00:43+08:00" content="2016-09-01">
              2016-09-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/01/多线程GCD/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/01/多线程GCD/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 这篇文章主要讲GCD的使用，相关博客如下：</p>
<p> <a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/" target="_blank" rel="external">iOS开发之多线程理论部分</a></p>
<p> <a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSOperation/" target="_blank" rel="external">NSOperation</a></p>
<p><a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSThread/" target="_blank" rel="external">NSThread</a></p>
<h1 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h1><p>全称是Grand Central Dispath，纯C语言，提供非常多强大的函数，是目前苹果官网推荐的多线程开发方法，NSOperation便是基于GCD的封装。</p>
<h1 id="GCD的优势所在"><a href="#GCD的优势所在" class="headerlink" title="GCD的优势所在"></a>GCD的优势所在</h1><ol>
<li>为多核的并行运算提出了解决方案</li>
<li>GCD会自动利用更多的CPU内核，比如双核，四核。</li>
<li>GCD会自动管理线程的生命周期(创建线程、调度任务、销毁线程)</li>
<li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li>
</ol>
<h1 id="GCD中有2个核心概念"><a href="#GCD中有2个核心概念" class="headerlink" title="GCD中有2个核心概念"></a>GCD中有2个核心概念</h1><ul>
<li><strong>任务：</strong> 执行什么操作 </li>
<li><strong>队列：</strong> 用来存放任务</li>
</ul>
<h1 id="队列可以分为两大类型"><a href="#队列可以分为两大类型" class="headerlink" title="队列可以分为两大类型"></a>队列可以分为两大类型</h1><ul>
<li>串行队列(Serial Dispatch Queue)：只有一个线程，加入到队列中的操作按添加顺序依次执行，一个任务执行完毕后，才能再执行下一个任务。</li>
<li>并发队列(Concurrent Dispatch Queue)：有多个线程，操作进来以后他会将这些线程安排在可用的处理器上，同时保证先进来的任务优先处理。</li>
<li><strong>其实在GCD中还有一个特殊队列就是主队列，用来执行主线程上的操作任务</strong></li>
</ul>
<h1 id="GCD其实可以抽象为两步"><a href="#GCD其实可以抽象为两步" class="headerlink" title="GCD其实可以抽象为两步"></a>GCD其实可以抽象为两步</h1><h2 id="找到队列"><a href="#找到队列" class="headerlink" title="找到队列"></a>找到队列</h2><pre><code>//这是找到了更新UI的主线程所在的队列
dispatch_queue_t mainQueue= dispatch_get_main_queue(); 

/*
  *  创建一个队列
  *  第一个参数：队列名字
  *  第二个参数：队列类类型
         并行队列：DISPATCH_QUEUE_CONCURRENT
         串行队列：DISPATCH_QUEUE_SERIAL
  *
  */
dispatch_queue_t serialQueue = dispatch_queue_create(&quot;mySerialQueue&quot;, DISPATCH_QUEUE_SERIAL);

/* 
  * 系统内部给我们提供有一个现成的并发队列
  * 第一个参数：线程的优先级, DISPATCH_QUEUE_PRIORITY_BACKGROUND是最低的。
  * 第二个参数：系统保留的参数，永远传0
  */
 dispatch_queue_t queue = dispatch_get_global_queue(0 , 0);
</code></pre><h2 id="在队列中确定想做的事"><a href="#在队列中确定想做的事" class="headerlink" title="在队列中确定想做的事"></a>在队列中确定想做的事</h2><pre><code>//在找到的队列中确定想要做的事情，这里我采用的同步方式执行任务，asyn是异步。 
dispatch_sync(mainQueue, ^{  

});
</code></pre><h2 id="执行队列中任务的两种方式"><a href="#执行队列中任务的两种方式" class="headerlink" title="执行队列中任务的两种方式"></a>执行队列中任务的两种方式</h2><ol>
<li><p><strong>用同步的方式执行任务(同步：synchronization</strong>)，只能在当前线程中执行任务，不具备开启新线程的能力</p>
<pre><code>/*
 *  第一个参数：该任务所在的队列
 *  第二个参数：该任务要做的事情
 */
dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);

假如我指定的队列A是串行队列，则该队列中只能有一个线程，也就是说我放在队列A中的任务，所以必须得一个一个的执行。不仅如此，在上面我们还手动选择了在队列A中用同步的方式执行任务，这也限制了，队列中的任务只能一个一个执行。

假如我指定的队列A是并行队列，则该队列中可以开辟多个线程去执行任务，虽然如此，但由于我们在上面手动选择了在队列A中用同步的方式执行线程，所以队列A中的任务也只能一个一个去执行，**不能开辟多线程同时执行**。
</code></pre></li>
<li><p><strong>用异步的方式执行任务(异步：asynchronous</strong>)，可以在新的线程中执行任务，具备开启新线程的能力。</p>
<pre><code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);

假如此时我指定的队列B是并行队列，则表明该队列中可以存在多个线程，又因为我们采用的是异步的方式执行任务，所以在这个队列的任务可以实现同时运行。

假如此时我指定的队列B是串行队列，则表明该队列中，只能有一个线程，所以尽管我采用异步的方式执行任务，但该队列中的任务还是只能一个一个的运行。
</code></pre></li>
</ol>
<h1 id="GCD创建的线程任务有四种执行方式"><a href="#GCD创建的线程任务有四种执行方式" class="headerlink" title="GCD创建的线程任务有四种执行方式"></a>GCD创建的线程任务有四种执行方式</h1><h2 id="串行队列同步执行任务"><a href="#串行队列同步执行任务" class="headerlink" title="串行队列同步执行任务"></a>串行队列同步执行任务</h2><ul>
<li><p>同步不具有开辟新线程的能力，不会开辟新的线程去执行任务，会在当前程序的主线程中执行任务。</p>
</li>
<li><p>按照串行的方式去执行任务</p>
</li>
</ul>
<pre><code>#pragma mark ------------------串行队列同步执行任务--------------

dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serialQueue&quot;, DISPATCH_QUEUE_SERIAL);

dispatch_sync(serialQueue, ^{

     NSLog(@&quot;-%@&quot;,[NSThread currentThread]);

});

dispatch_sync(serialQueue, ^{

     NSLog(@&quot;1 - %@&quot;, [NSThread currentThread]);

 });

 dispatch_sync(serialQueue, ^{

     NSLog(@&quot;2 - %@&quot;, [NSThread currentThread]);

 });

 dispatch_sync(serialQueue, ^{

      NSLog(@&quot;3 - %@&quot;, [NSThread currentThread]);

 });
</code></pre><p><strong>打印结果</strong></p>
<blockquote>
<p><strong>2016-03-01 11:44:15.071 GCD[22196:2030750] 1 = <nsthread: 0x7fade3707d80="">{number = 1, name = main}</nsthread:></strong><br><br><strong>2016-03-01 11:44:15.071 GCD[22196:2030750] 2 = <nsthread: 0x7fade3707d80="">{number = 1, name = main}</nsthread:></strong><br><br><strong>2016-03-01 11:44:15.071 GCD[22196:2030750] 3 = <nsthread: 0x7fade3707d80="">{number = 1, name = main}</nsthread:></strong><br><br><strong>2016-03-01 11:44:15.071 GCD[22196:2030750] 4 = <nsthread: 0x7fade3707d80="">{number = 1, name = main}</nsthread:></strong></p>
</blockquote>
<pre><code>**由于是同步操作，不能开辟线程，所以都是在主线程并按照顺序执行**
</code></pre><h2 id="串行队列异步执行任务"><a href="#串行队列异步执行任务" class="headerlink" title="串行队列异步执行任务"></a>串行队列异步执行任务</h2><ul>
<li><p>异步具有创建新线程的能力，会开辟新的线程去执行任务</p>
</li>
<li><p>按照串行的方式去执行任务</p>
<pre><code>#pragma mark ------------------串行队列异步执行任务------------

dispatch_queue_t serialQueue1 = dispatch_queue_create(&quot;serialQueue1&quot;, DISPATCH_QUEUE_SERIAL);

dispatch_async(serialQueue1, ^{

    NSLog(@&quot;1 = %@&quot;,[NSThread currentThread]);

});

dispatch_async(serialQueue1, ^{

     NSLog(@&quot;2 = %@&quot;,[NSThread currentThread]);

});

dispatch_async(serialQueue1, ^{

     NSLog(@&quot;3 = %@&quot;,[NSThread currentThread]);

});
</code></pre><p>  <strong>打印结果</strong></p>
<blockquote>
<p><strong>2016-03-01 11:56:04.116 GCD[22310:2039747] 1 = <nsthread: 0x7f90ba60be60="">{number = 2, name = (null)}</nsthread:></strong><br><br><strong>2016-03-01 11:56:04.117 GCD[22310:2039747] 2 = <nsthread: 0x7f90ba60be60="">{number = 2, name = (null)}</nsthread:></strong><br><br><strong>2016-03-01 11:56:04.118 GCD[22310:2039747] 3 = <nsthread: 0x7f90ba60be60="">{number = 2, name = (null)}</nsthread:></strong></p>
</blockquote>
<p> <strong>因为是异步操作，所以有个编号为2的子线程被开辟，但有因为是串行队列，所以只开辟了一个线程。最终造就了三个线程顺序执行。</strong></p>
</li>
</ul>
<h2 id="并行队列同步执行任务"><a href="#并行队列同步执行任务" class="headerlink" title="并行队列同步执行任务"></a>并行队列同步执行任务</h2><ul>
<li><p>同步不具有创建新线程的能力，不会开辟新的线程去执行任务，会在当前程序的主线程去执行任务</p>
</li>
<li><p>按照同步的方式去执行任务</p>
<pre><code>dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);

dispatch_sync(concurrentQueue, ^{

     NSLog(@&quot;1 = %@&quot;,[NSThread currentThread]);

});

dispatch_sync(concurrentQueue, ^{

     NSLog(@&quot;2 = %@&quot;,[NSThread currentThread]);

});

dispatch_sync(concurrentQueue, ^{

     NSLog(@&quot;3 = %@&quot;,[NSThread currentThread]);

});
</code></pre><p>  <strong>虽然并行队列决定了该队列中可以有多个线程，但由于是同步操作，不能开辟线程，所以还都是在主线程中按顺序执行。</strong></p>
</li>
</ul>
<h2 id="并发队列异步执行任务-常用"><a href="#并发队列异步执行任务-常用" class="headerlink" title="并发队列异步执行任务(常用)"></a>并发队列异步执行任务(常用)</h2><ul>
<li><p>异步具有创建新线程的能力，会开辟新的线程去执行任务，不会在当前程序的主线程去执行任务</p>
</li>
<li><p>按照并发的方式去执行任务</p>
<pre><code>dispatch_queue_t concurrentQueue1 = dispatch_queue_create(&quot;concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);

dispatch_async(concurrentQueue1, ^{

     NSLog(@&quot;1 = %@&quot;,[NSThread currentThread]);

});

dispatch_async(concurrentQueue1, ^{

     NSLog(@&quot;2 = %@&quot;,[NSThread currentThread]);

});

dispatch_async(concurrentQueue1, ^{

     NSLog(@&quot;3 = %@&quot;,[NSThread currentThread]);

});
</code></pre><p> <strong>打印结果</strong></p>
<blockquote>
<p><strong>2016-03-01 14:32:35.880 GCD[22990:2122064] 2 = <nsthread: 0x7f997ae09f00="">{number = 3, name = (null)}</nsthread:></strong><br><br><strong>2016-03-01 14:32:35.880 GCD[22990:2122063] 1 = <nsthread: 0x7f997af25510="">{number = 2, name = (null)}</nsthread:></strong><br><br><strong>2016-03-01 14:32:35.880 GCD[22990:2122065] 3 = <nsthread: 0x7f997ac02a10="">{number = 4, name = (null)}</nsthread:></strong></p>
</blockquote>
<p> <strong>并行队列可以里可以有多个线程，同步执行的方式又可以开辟多个线程，所以这里实现了多个线程并行执行。</strong></p>
</li>
</ul>
<h1 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h1><p>   <strong>没线程锁的情况下：</strong>  我走进购票大厅，买票的人都没有排队，我好不容易挤到窗口前，正打算掏钱买票的时候，旁边有人已经把钱给了售票员。虽然你的线程已经开始执行买票的方法，但当你去拿票时，也就是将票数减一时，CPU将你的线程给中断，开始执行其他的线程，CPU返回继续执行你的线程的时候，票已经没了。</p>
<p>  <strong>有线程锁的情况下：*</strong> 我走进购票大厅，买票的人都在排队，当我到柜台能保证我买票的关键过程，也就是报站、掏钱、拿票过程不受干扰，我采用线程锁将这个关键过程给锁起来，以保证我能顺利的买到票。</p>
<pre><code>//
//  ViewController.m
//  GCD_ Train_Ticket 
//
//  Created by GG on 16/3/2.
//  Copyright © 2016年 GG. All rights reserved.
//

#import &quot;GCDLockViewController.h&quot;

@interface  GCDLockViewController()
{
   NSLock *lock;
}

@end

@implementation GCDLockViewController

- (void)viewDidLoad {

    [super viewDidLoad];

    self.view.backgroundColor = [UIColor whiteColor];
    self.title = @&quot;线程锁&quot;;
    self.edgesForExtendedLayout = UIRectEdgeNone;

    lock = [NSLock new];

    dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);
    __block int ticketNum = 10;

    for (int index = 0; index&lt;15; index++) {

          dispatch_async(concurrentQueue, ^{

              #pragma mark *****************不用线程锁，下面的购票的关键      过程就可能会被打断，无法确认剩余的票数***********************
              //            if (ticketNum&gt;0) {
              //
              //                ticketNum--;
              //
              //                NSLog(@&quot;还剩%d张票&quot;,ticketNum);
              //            }

             #pragma  mark *****************NSLock实现线程锁，能保证票数是按照预知的一张一张减少，对比不用线程所的输出可知*******************

             //            //上锁，lock是一个NSLock的对象
             //            [lock lock];
             //
             //            if (ticketNum&gt;0) {
             //
             //                ticketNum--;                   
             //
             //                NSLog(@&quot;还剩%d张票&quot;,ticketNum);
             //            }
             //            //解锁
             //            [lock unlock];

             #pragma mark *****************synchronized方式实现线程锁，能保证票数是按照预知的一张一张减少**********

             //保证此时没有其它线程对self里的对象进行修改
             @synchronized(self){

                if (ticketNum&gt;0) {

                  ticketNum--;

                  NSLog(@&quot;还剩%d张票&quot;,ticketNum);

                }

             }

         });


     }

 }

@end
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/01/多线程NSOperation/" itemprop="url">
                  多线程NSOperation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-01T09:10:35+08:00" content="2016-09-01">
              2016-09-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/01/多线程NSOperation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/01/多线程NSOperation/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章主要讲NSOperation的使用，相关博客如下：</p>
<p><a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/" target="_blank" rel="external">iOS开发之多线程理论部分</a></p>
<p><a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BGCD/" target="_blank" rel="external">GCD</a></p>
<p><a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSThread/" target="_blank" rel="external">NSThread</a></p>
<h1 id="什么是NSOperation"><a href="#什么是NSOperation" class="headerlink" title="什么是NSOperation"></a>什么是NSOperation</h1><p>使用NSOperation和NSOperationQueue进行多线程开发类似于线程池，只要将一个<strong>NSOperation(实际开发中需要使用其子类NSInvocationOperation、NSBlockOperation)放到NSOperationQueue这个队列中线程就会依次启动。</strong>NSOperationQueue负责管理、执行所有的NSOperation，在这个过程中<code>可以更加容易管理线程总数和控制线程之间的依赖关系。</code></p>
<p><strong>NSOperation</strong>  利用他来创建线程操作，线程操作只有放在线程队列中才会在子线程中执行。</p>
<p><strong>NSOperationQueue</strong>: 线程队列分两种类型。</p>
<ul>
<li><p>主队列</p>
<ul>
<li>[NSOperationQueue mainQueue]</li>
<li>凡是添加到主队列中的任务(NSOperation),都会放到主线程中执行。</li>
</ul>
</li>
<li><p>非主队列</p>
<ul>
<li>[[NSOperationQueue alloc]init]</li>
<li>添加到这种队列中的任务，都会放到子线程中执行。</li>
</ul>
</li>
</ul>
<p>NSOperation常用子类用于创建线程操作：NSInvocationOperation和NSBlockOperation，两种方式本质没有区别，但后者使用block形式进行代码组织，使用相对方便。也可以用自定义的继承于NSOperation的类来创建线程操作。</p>
<h1 id="NSOperation的三种用法"><a href="#NSOperation的三种用法" class="headerlink" title="NSOperation的三种用法"></a>NSOperation的三种用法</h1><p>配合使用NSOperation和NSOperationQueue实现多线程编程，一共有三种方式，但其实这三种方式都是采用NSOperation的子类与NSOperationQueue搭配实现多线程开发。这三个子类分别是NSInvocationOperation、NSBlockOperation和自定义继承于NSOperation的类，前两者是系统提供的子类。</p>
<h2 id="NSInvocationOperation与NSOperationQueue搭配"><a href="#NSInvocationOperation与NSOperationQueue搭配" class="headerlink" title="NSInvocationOperation与NSOperationQueue搭配"></a>NSInvocationOperation与NSOperationQueue搭配</h2><ol>
<li><p>创建一个线程操作，并实现方法选择器选择的方法</p>
<pre><code>//创建一个线程操作
NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(invocationOperation:) object:kurl];

//让线程操作开始执行。但是如果这样做的话这个操作将会在主线程中执行，只有将这个操作放进队列，才会开辟一个子线程让这个操作在子线程中执行。
//[invocationOperation start];
</code></pre></li>
<li><p>创建一个线程队列</p>
<pre><code>NSOperationQueue *operationQueue = [NSOperationQueue new];
</code></pre></li>
<li><p>将创建好的线程操作放在线程队列中</p>
<pre><code>//只有放在线程队列中的线程操作才会在子线程中执行。线程队列负责管理、执行所有的NSOperation
[operationQueue addOperation:invocationOperation];
</code></pre></li>
<li><p>在创建线程操作时选择的方法内更新UI</p>
<pre><code>- (void)invocationOperation:(NSString *)url{

      //虽然没有采用NSThread创建线程，但仍可以使用[NSThread currentThread]来获取当前的线程。
      NSLog(@&quot;invocationOperation方法所在的线程%@&quot;,[NSThread currentThread]);
      NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:kurl]];
      //在子线程中回到主线程更新UI
      [[NSOperationQueue mainQueue] addOperationWithBlock:^{

          imageView.image = [UIImage imageWithData:data];

     }];

}
</code></pre><p>   到目前为止是不是感觉跟NSThread挺相似的，接下来简单分析一下两者的区别。</p>
<pre><code> 1. NSThread需要启动，也就是说需要费心管理声明周期，而采用Operation只需将线程操作放到线程队列中即可，线程队列负责管理、执行所有的NSOperation。

 2. 管理线程的最大并发数，也就是同时执行的任务数。

      //默认是-1，不能设为0，如果设置为0就不执行任务。
      operationQueue.maxConcurrentOperationCount = 1;

 3. 控制线程之间的依赖关系，NSOperation之间可以设置依赖来保证执行顺序,比如一定要让操作1执行完后，才能执行操作2。线程之间不能相互依赖，不如A依赖于B，B有依赖于A。  

     //操作1依赖于操作2
     [invocationOperation1 addDependency:invocationOperation2];

 4. 队列的取消、暂停、恢复

      只要设置队列的suspended为YES, 那么就会暂停队列中其它任务的执行，也就是说不会再继续执行没有执行到得任务

      self.queue.suspended = YES;

      注意1: 设置为暂停之后, 不会立即暂停,会继续执行当前正在执行的任务, 直到当前任务执行完毕, 就不会执行下一个任务了,也就是说, 暂停其实是暂停下一个任务, 而不能暂停当前任务

      注意2: 暂停是可以恢复的,只要设置队列的suspended为NO, 那么就会恢复队列中其它任务的执行

5. 取消队列中所有的任务的执行

    [self.queue cancelAllOperations];

    取消和暂停一样, 是取消后面的任务, 不能取消当前正在执行的任务，取消是不可以恢复的
</code></pre></li>
</ol>
<h2 id="NSBlockOperation与NSOperationQueue搭配，"><a href="#NSBlockOperation与NSOperationQueue搭配，" class="headerlink" title="NSBlockOperation与NSOperationQueue搭配，"></a>NSBlockOperation与NSOperationQueue搭配，</h2><p>   其实方式一和方式二没有什么本质区别。主要是后者使用block形式进行代码组织，使用相对方便。</p>
<pre><code> - (void)viewDidLoad{

     [super viewDidLoad];

     imageView = [[UIImageView alloc]initWithFrame:CGRectMake(50, 50, 200, 200)];

     [self.view addSubview:imageView];

     //1. 创建线程操作
     NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{

        NSLog(@&quot;blockOperation线程操作所在的线程%@&quot;,[NSThread currentThread]);

        NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:kurl]];

        [[NSOperationQueue mainQueue] addOperationWithBlock:^{

              NSLog(@&quot;更新UI所在的线程%@&quot;,[NSThread currentThread]);

              imageView.image = [UIImage imageWithData:data];

         }];

     }];

     //2. 创建线程队列
     NSOperationQueue *operationQueue = [NSOperationQueue new];

     //3. 将线程操作放到线程队列中
     [operationQueue addOperation:blockOperation];

}
</code></pre><p>   简化以上操作</p>
<pre><code>//1. 创建一个线程队列
NSOperationQueue *operationQueue = [NSOperationQueue new];

//2. 直接利用线程队列的addOperationWithBlock添加线程操作。
[operationQueue addOperationWithBlock:^{

    NSLog(@&quot;更新UI所在的线程%@&quot;,[NSThread currentThread]);

}];
</code></pre><h2 id="继承于NSOperation的子类与NSOperationQueue的搭配"><a href="#继承于NSOperation的子类与NSOperationQueue的搭配" class="headerlink" title="继承于NSOperation的子类与NSOperationQueue的搭配"></a>继承于NSOperation的子类与NSOperationQueue的搭配</h2><ol>
<li><p>创建一个继承于NSOperation的类，并在.m文件中重写main方法，main方法便是该线程要执行的操作。<strong>注意，如果是同步操作，该方法能够自动访问到主线程的自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池，需要再main中再新建一个自动释放池，来帮助管理内存。</strong></p>
</li>
<li><p>创建线程队列，并把线程操作放在线程队列中。</p>
</li>
</ol>
<pre><code>  //
  //  CoustomOperation.h
  //  NSOperation
  //
  //  Created by GG on 16/2/26.
  //  Copyright © 2016年 GG. All rights reserved.
  //

  #import &lt;Foundation/Foundation.h&gt;
  #import &lt;UIKit/UIKit.h&gt;
  @interface CoustomOperation : NSOperation

  //接收传进来的图片对象
  @property (nonatomic,retain) UIImageView *imageView;

  //在该该类对象初始化时，将图片试图对象传到类中。
  - (instancetype)initWithImageView:(UIImageView *)imageView;

  @end


----

  //
  //  CoustomOperation.m
  //  NSOperation
  //
  //  Created by GG on 16/2/26.
  //  Copyright © 2016年 GG. All rights reserved.
  //

  #import &quot;CoustomOperation.h&quot;

  #define kurl @&quot;http://store.storeimages.cdn-apple.com/8748/as-images.apple.com/is/image/AppleInc/aos/published/images/s/38/s38ga/rdgd/s38ga-rdgd-sel-201601?wid=848&amp;hei=848&amp;fmt=jpeg&amp;qlt=80&amp;op_sharpen=0&amp;resMode=bicub&amp;op_usm=0.5,0.5,0,0&amp;iccEmbed=0&amp;layer=comp&amp;.v=1454777389943&quot;

  @implementation CoustomOperation

  - (instancetype)initWithImageView:(UIImageView *)imageView
  {
      self = [super init];
      if (self) {

         self.imageView = imageView;
      }
      return self;
  }

  - (void)main{

        //新建一个自动释放池，因为如果是同步操作，该方法能够自动访问到主线程的自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池。
        @autoreleasepool {

             NSLog(@&quot;获取图片所在的线程%@&quot;,[NSThread currentThread]);
             NSData *imageData = [NSData dataWithContentsOfURL:[NSURL URLWithString:kurl]];

             [[NSOperationQueue mainQueue] addOperationWithBlock:^{

                 NSLog(@&quot;更新UI所在的线程%@&quot;,[NSThread currentThread]);

                 self.imageView.image = [UIImage imageWithData:imageData];

             }];

        }            
   }

   @end  
</code></pre><hr>
<pre><code>ViewController.m
- (void)viewDidLoad{

    [super viewDidLoad];

    imageView = [[UIImageView alloc]initWithFrame:CGRectMake(50, 50, 200, 200)];

    [self.view addSubview:imageView];

    CoustomOperation *coustomOperation = [[CoustomOperation alloc] initWithImageView:(UIImageView *)imageView];

    NSOperationQueue *operationQueue = [NSOperationQueue new];

    [operationQueue addOperation:coustomOperation];

}
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  这三种方式中，感觉方式一是最麻烦的，方式二相对而已简洁不少，而方式三更适合于封装某一个线程操作。</p>
<ol>
<li>是用NSOperation加载一张图片</li>
<li>使用NSOperation加载多张图片，并能使线程暂停，恢复，终止,</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/31/定位-编码与反编码/" itemprop="url">
                  定位/编码与反编码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-31T08:28:39+08:00" content="2016-08-31">
              2016-08-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/31/定位-编码与反编码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/31/定位-编码与反编码/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  学习地图，我们必须要接触两个框架：</p>
<ol>
<li><p>Core Location，主要包含定位、地理编码、反编码功能</p>
</li>
<li><p>MapKit，利用他可以对地图进行精准的控制，如需了解请移步<a href="https://wangliguang.github.io/2016/08/30/iOS%E5%9C%B0%E5%9B%BE-%E5%9C%B0%E5%9B%BE%E6%98%BE%E7%A4%BA:%E5%A4%A7%E5%A4%B4%E9%92%88/" target="_blank" rel="external">iOS开发之地图-地图显示/大头针</a></p>
<p>本文我们主要介绍的是使用Core Location来实现定位、地理编码(包括反编码)功能。</p>
</li>
</ol>
<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p> 定位是一个很常用的功能，打开地图软件后如果用户允许软件定位的话，软件便会自动锁定到手机所在位置，并且地图上的位置会随着手机的移动而移动。定位使用到的类是Core Location框架中的CLLocationManager类。</p>
<h2 id="CLLocationManager中常用的方法"><a href="#CLLocationManager中常用的方法" class="headerlink" title="CLLocationManager中常用的方法"></a>CLLocationManager中常用的方法</h2><pre><code>  *******类方法**********
  //当前系统是否打开定位服务,在设置-&gt;隐私里控制。这是能够控制手机上所有App的定位授权     
  +(BOOL)locationServicesEnabled;

  /* 定位服务授权状态，返回枚举类型，下面是类型解释

   * kCLAuthorizationStatusNotDetermined： 用户尚未做出决定是否启用定位服务

   * kCLAuthorizationStatusRestricted： 没有获得用户授权使用定位服务,可能用户没有自己禁止访问授权

   * kCLAuthorizationStatusDenied ：用户已经明确禁止应用使用定位服务或者当前系统定位服务处于关闭状态

   * kCLAuthorizationStatusAuthorizedAlways： 应用获得授权可以一直使用定位服务，即使应用不在使用状态

   * kCLAuthorizationStatusAuthorizedWhenInUse： 使用此应用过程中允许访问定位服务

   */ 
   +(CLAuthorizationStatus)authorizationStatus;

---

   *******对象方法**********
   //开始定位追踪，开始定位后将按照用户设置的更新频率执行-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations;方法反馈定位信息
   startUpdatingLocation

   //停止定位追踪
   stopUpdatingLocation

   //请求获得应用使用时的定位服务授权，注意使用此方法前在要在info.plist中配置NSLocationWhenInUseUsageDescription
   requestWhenInUseAuthorization

   //请求获得应用一直使用定位服务授权，注意使用此方法前要在info.plist中配置NSLocationAlwaysUsageDescription
   requestAlwaysAuthorization

   //开始导航方向追踪
   startUpdatingHeading

   //停止导航方向追踪
   stopUpdatingHeading

   //开始对某个区域进行定位追踪，开始对某个区域进行定位后。如果用户进入或者走出某个区域会调用相应的代理方法反馈相关信息

   //停止对某区域追踪
   stopMonitoringForRegion:

 ---

   *******代理方法*******
   //位置发生改变后执行（第一次定位到某个位置之后也会执行）
   -(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations;

   //导航方向发生变化后执行
   - (void)locationManager:(CLLocationManager *)manager didUpdateHeading:(CLHeading *)newHeading;

   // 进入某个区域之后执行
   - (void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region;

    //走出某个区域之后执行
     - (void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region
</code></pre><h2 id="实现定位的步骤"><a href="#实现定位的步骤" class="headerlink" title="实现定位的步骤"></a>实现定位的步骤</h2><pre><code>1. 导入框架         
       #import &lt;CoreLocation/CoreLocation.h&gt;

2. **声明全局**的定位管理器，因为定位是持续性动作，如果声明为局部变量，还没有退出这个界面，定位管理器对象就会被释放，从而造成定位失败，而如果声明为全局变量，只有该界面对象被释放，这个定位管理器才会被释放。另外如果是该定位管理器是局部变量，第一次打开的授权提示框会出现闪退现象。
       CLLocationManager *_locationManager;

3. 实例化定位管理器
       _locationManager = [[CLLocationManager alloc]init];

4. 判断当前系统是否打开定位服务,在设置-&gt;隐私里。这是能够控制手机上所有App的定位授权
        if ([CLLocationManager locationServicesEnabled] == NO) {

              //判断是否可以打开设置界面
              if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]]) {

                    //跳转到设置页面
                    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];

              };

              return;
        }

5. **定位授权，如果不授权就无法定位**

       //使用中授权
       [_locationManager requestWhenInUseAuthorization]; 

       //永久授权，这种情况下，有时你应用没打开也会定位,如果苹果手机上有地图软件的话，你没有打开该软件，系统有时也会突然给你个提示框说某应用一直在使用定位功能，是否关闭。
       // [_locationManager requestAlwaysAuthorization];  
6. **在info.plist插入两个字段，不添加就无法定位**

       //都string类型，和第五步的两种授权，写入的内容会出现在定位授权提示框上
       NSLocationWhenInUseUsageDescription//使用中授权描述
       NSLocationAlwaysUsageDescription//永久授权描述

7.  挂上代理
        _locationManager.delegate = self;

8. 使用后台定位
        _locationManager.allowsBackgroundLocationUpdates = YES;

9. 设置定位信息

       //设置定位精度
       _locationManager.desiredAccuracy = 10;

       //设置定位频率定位频率和定位精度并不应当越精确越好，需要视实际情况而定，因为越精确越耗性能，也就越费电。
       CLLocationDistance distance=1.0;//1米定位一次
       _locationManager.distanceFilter = distance;

10. 开始追踪,**如果不需要定位了记得停止定位，要不然会有很大的耗电量**
        [_locationManager startUpdatingLocation];

11. 实现代理方法,**以后我们会常看到一个CLLocation类，它用于表示位置信息，包含地理坐标、海拔等信息，包含在CoreLoaction框架中。**
         #pragma  mark delegate 
        //定位成功，因为定位时刻都在进行，所以苹果将瞬时获得的多个位置信息放在一个数组中，我们只需获取到数组中的最后一个。
        - (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations{

        /*
         * 如果不需要定位了记得停止定位，要不然会有很大的耗电量
         */
        CLLocation *curLoc = locations.lastObject;

        /*
          * 当前位置的经纬度
          *
              typedef struct {
                 CLLocationDegrees latitude;
                 CLLocationDegrees longitude;
              } CLLocationCoordinate2D;
          *
          */
          CLLocationCoordinate2D coordinate = curLoc.coordinate;
          NSLog(@&quot;经度:%f 纬度:%f&quot;,coordinate.longitude,coordinate.latitude);

          //海拔高度
          NSLog(@&quot;海拔高度:%f&quot;,curLoc.altitude);

           //位置的精度，位置精度通过一个圆表示，实际位置可能位于这个圆内的任何地方。这个圆是由coordinate(坐标)和horizontalAccuracy(半径)共同决定的，horizontalAccuracy的值越大，那么定义的圆就越大，因此位置精度就越低。如果horizontalAccuracy的值为负，则表明coordinate的值无效。
          NSLog(@&quot;位置的精度:%f&quot;,curLoc.horizontalAccuracy);

          //海拔高度的精度。为正值表示海拔高度的误差为对应的米数；为负表示altitude(海拔高度)的值无效。
          NSLog(@&quot;海拔的精度:%f&quot;,curLoc.verticalAccuracy);

          //speed — 速度。该属性是通过比较当前位置和前一个位置，并比较它们之间的时间差异和距离计算得到的。鉴于Core Location更新的频率，speed属性的值不是非常精确，除非移动速度变化很小。
          NSLog(@&quot;行驶速度：%f&quot;,curLoc.speed);

          //当前定位的日期
          NSLog(@&quot;定位日期%@&quot;,curLoc.timestamp);

          //得到两个位置之间的距离，通过不断累加，来获取总距离
          //    [curLoc distanceFromLocation:nil];

          //得到两次更新的时间之间的间隔，通过累加来获取行驶总时间
          //    [curLoc.timestamp timeIntervalSinceDate:lastLoc.timestamp];

          //floor 楼层的高度 -&gt; level 几层
          NSLog(@&quot;当前楼层%ld层&quot;,curLoc.floor.level);

        } 

         //定位失败
        - (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error{

           NSLog(@&quot;定位失败%@&quot;,error);

        }
</code></pre><h2 id="总结：如果定位失败，首先检查一下几点："><a href="#总结：如果定位失败，首先检查一下几点：" class="headerlink" title="总结：如果定位失败，首先检查一下几点："></a>总结：如果定位失败，首先检查一下几点：</h2><ol>
<li><p>定位管理器是否为全局变量</p>
</li>
<li><p>info.plist中的字段是否配置</p>
</li>
<li><p>在代码中是否做授权处理</p>
</li>
<li><p><strong> 如果用模拟器的话，可能是因为没有给模拟器设置经纬度，点击模拟器模拟器 -&gt; 菜单栏Debug -&gt; Location -&gt; CustomLocation -&gt; 设置经纬度，如果想要让模拟器自动定位选择Location —&gt; Apple。</strong></p>
</li>
</ol>
<h1 id="编码反编码"><a href="#编码反编码" class="headerlink" title="编码反编码"></a>编码反编码</h1><p>   编码与反编码用到的类都是CLGeocoder</p>
<pre><code>1. 编码：将地址转化为经纬度
2. 反编码：将经纬度转化为地址
</code></pre><p>   <strong>之后我们会接触到一个CLPlacemark类，他是定位框架中地标类，封装了详细的地理信息</strong></p>
<pre><code>  //编码
  - (void)geocodeAddressString:(NSString *)addressString completionHandler:(CLGeocodeCompletionHandler)completionHandler;

//反编码
- (void)reverseGeocodeLocation:(CLLocation *)location completionHandler:(CLGeocodeCompletionHandler)completionHandler;
</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>//
//  CLGeocoderViewController.m
//  Location
//
//  Created by GG on 16/3/9.
//  Copyright © 2016年 GG. All rights reserved.
//

#import &quot;CLGeocoderViewController.h&quot;
#import &lt;CoreLocation/CoreLocation.h&gt;
@interface CLGeocoderViewController ()
{
    CLGeocoder *_geocoder;
}
@end

@implementation CLGeocoderViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    _geocoder=[[CLGeocoder alloc]init];
    [self getCoordinateByAddress:@&quot;北京&quot;];
    [self getAddressByLatitude:39.54 longitude:116.28];
}

#pragma mark 根据地名确定地理坐标
-(void)getCoordinateByAddress:(NSString *)address{
    //地理编码
    [_geocoder geocodeAddressString:address completionHandler:^(NSArray *placemarks, NSError *error) {
        //取得第一个地标，地标中存储了详细的地址信息，注意：一个地名可能搜索出多个地址
        CLPlacemark *placemark=[placemarks firstObject];

        CLLocation *location=placemark.location;//位置
        CLRegion *region=placemark.region;//区域
        NSDictionary *addressDic= placemark.addressDictionary;//详细地址信息字典,包含以下部分信息
        //        NSString *name=placemark.name;//地名
        //        NSString *thoroughfare=placemark.thoroughfare;//街道
        //        NSString *subThoroughfare=placemark.subThoroughfare; //街道相关信息，例如门牌等
        //        NSString *locality=placemark.locality; // 城市
        //        NSString *subLocality=placemark.subLocality; // 城市相关信息，例如标志性建筑
        //        NSString *administrativeArea=placemark.administrativeArea; // 州
        //        NSString *subAdministrativeArea=placemark.subAdministrativeArea; //其他行政区域信息
        //        NSString *postalCode=placemark.postalCode; //邮编
        //        NSString *ISOcountryCode=placemark.ISOcountryCode; //国家编码
        //        NSString *country=placemark.country; //国家
        //        NSString *inlandWater=placemark.inlandWater; //水源、湖泊
        //        NSString *ocean=placemark.ocean; // 海洋
        //        NSArray *areasOfInterest=placemark.areasOfInterest; //关联的或利益相关的地标
        NSLog(@&quot;位置:%@,区域:%@,详细信息:%@&quot;,location,region,addressDic);
    }];
}

#pragma mark 根据坐标取得地名
-(void)getAddressByLatitude:(CLLocationDegrees)latitude longitude:(CLLocationDegrees)longitude{
    //反地理编码
    CLLocation *location=[[CLLocation alloc]initWithLatitude:latitude longitude:longitude];
    [_geocoder reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) {
        CLPlacemark *placemark=[placemarks firstObject];
        NSLog(@&quot;详细信息:%@&quot;,placemark.addressDictionary);
    }];
}

@end
</code></pre><h2 id="总结我们目前在地图上接触到的几个类："><a href="#总结我们目前在地图上接触到的几个类：" class="headerlink" title="总结我们目前在地图上接触到的几个类："></a>总结我们目前在地图上接触到的几个类：</h2><pre><code>1.  CLLocationManager：定位管理器,用来设置管理定位，设置定位的精度、定位频率、后台运行等。

2. CLGeocoder：主要用来编码与反编码。

3. CLLocation：用于表示位置信息，包含地理坐标、海拔等信息，包含在CoreLoaction框架中。

4. CLPlacemark：定位框架中地标类，封装了详细的地理信息。

5. CLLocationCoordinate2D：他是一个结构体，用来表示经纬度。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/30/地图显示:大头针/" itemprop="url">
                  地图显示/大头针
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-30T22:27:07+08:00" content="2016-08-30">
              2016-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/30/地图显示:大头针/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/30/地图显示:大头针/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   学习地图，我们必须要接触两个框架：</p>
<ol>
<li><p>Core Location，主要包含定位、地理编码、反编码功能，如需了解请移步<a href="https://wangliguang.github.io/2016/08/31/iOS%E5%9C%B0%E5%9B%BE-%E5%AE%9A%E4%BD%8D-%E7%BC%96%E7%A0%81%E4%B8%8E%E5%8F%8D%E7%BC%96%E7%A0%81/" target="_blank" rel="external">iOS开发之地图-定位/编码与反编码</a></p>
</li>
<li><p>MapKit，利用他可以对地图进行精准的控制,比如，放置大头针、地图类型切换，导航等等。</p>
<p>本文我们主要介绍的是使用MapKit框架对地图试图进行精准的控制。</p>
</li>
</ol>
<h1 id="MKMapView"><a href="#MKMapView" class="headerlink" title="MKMapView"></a>MKMapView</h1><p>   <strong>MKMapView是地图展示控件。</strong></p>
<h2 id="MKMapView的常用属性"><a href="#MKMapView的常用属性" class="headerlink" title="MKMapView的常用属性"></a>MKMapView的常用属性</h2><pre><code>//跟踪类型，是一个枚举：MKUserTrackingModeNone :不进行用户位置跟踪；MKUserTrackingModeFollow :跟踪用户位置；MKUserTrackingModeFollowWithHeading :跟踪用户位置并且跟踪用户前进方向；
userTrackingMode    

//地图类型，是一个枚举：MKMapTypeStandard :标准地图，一般情况下使用此地图即可满足；MKMapTypeSatellite ：卫星地图；MKMapTypeHybrid ：混合地图，加载最慢比较消耗资源；
mapType

//用户位置，只读属性
userLocation

//当前地图中的所有大头针，只读属性
annotations

// 是否可以缩放 
zoomEnabled = NO; 

// 是否可以滚动 
scrollEnabled = NO; 

// 是否可以旋转  
rotateEnabled = NO; 

// 是否显示3D  
pitchEnabled = NO;

// 是否显示指南针
showsCompass = YES;

// 是否显示比例尺
showsScale = YES;

// 是否显示交通
showsTraffic = YES;

// 是否显示建筑物
showsBuildings = YES;
</code></pre><h2 id="MKMapView的常用方法"><a href="#MKMapView的常用方法" class="headerlink" title="MKMapView的常用方法"></a>MKMapView的常用方法</h2><pre><code>  ******对象方法*****
  //添加大头针，对应的有添加大头针数组
  - (void)addAnnotation:(id &lt;MKAnnotation&gt;)annotation;

  //删除大头针，对应的有删除大头针数组
  - (void)removeAnnotation:(id &lt;MKAnnotation&gt;)annotation;

  //设置地图显示区域，用于控制当前屏幕显示地图范围
  - (void)setRegion:(MKCoordinateRegion)region animated:(BOOL)animated;

  //设置地图中心点位置
  - (void)setCenterCoordinate:(CLLocationCoordinate2D)coordinate animated:(BOOL)animated;

  //将地理坐标（经纬度）转化为数学坐标（UIKit坐标）
  - (CGPoint)convertCoordinate:(CLLocationCoordinate2D)coordinate toPointToView:(UIView *)view;

  //将数学坐标转换为地理坐标
  - (CLLocationCoordinate2D)convertPoint:(CGPoint)point toCoordinateFromView:(UIView *)view;

  //从缓存池中取出大头针，类似于UITableView中取出UITableViewCell，为了进行性能优化而设计
  - (MKAnnotationView *)dequeueReusableAnnotationViewWithIdentifier:(NSString *)identifier;

  //选中指定的大头针
  - (void)selectAnnotation:(id &lt;MKAnnotation&gt;)annotation animated:(BOOL)animated;

  //取消选中指定的大头针
  - (void)deselectAnnotation:(id &lt;MKAnnotation&gt;)annotation animated:(BOOL)animated;

---

  ******代理方法*****

 //用户位置发生改变时触发（第一次定位到用户位置也会触发该方法）
 - (void)mapView:(MKMapView *)mapView didUpdateUserLocation:(MKUserLocation *)userLocation ;

 //显示区域发生改变后触发
 - (void)mapView:(MKMapView *)mapView didUpdateUserLocation:(MKUserLocation *)userLocation ;

 //地图加载完成后触发
 - (void)mapViewDidFinishLoadingMap:(MKMapView *)mapView;

 //显示大头针时触发，返回大头针视图，通常自定义大头针可以通过此方法进行
 - (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id &lt;MKAnnotation&gt;)annotation;

 //点击选中某个大头针时触发
 - (void)mapView:(MKMapView *)mapView didSelectAnnotationView:(MKAnnotationView *)view

 //取消选中大头针时触发
 - (void)mapView:(MKMapView *)mapView didDeselectAnnotationView:(MKAnnotationView *)view

 //渲染地图覆盖物时触发
 - (MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id &lt;MKOverlay&gt;)overlay
</code></pre><h2 id="MKMapView显示当前位置的步骤"><a href="#MKMapView显示当前位置的步骤" class="headerlink" title="MKMapView显示当前位置的步骤"></a>MKMapView显示当前位置的步骤</h2><pre><code>1. 导入MapKit框架

       #import &lt;MapKit/MapKit.h&gt;

2. 使用定位管理器CLLocationManager做定位授权
       _locationManager = [[CLLocationManager alloc]init];
       [_locationManager requestAlwaysAuthorization];//始终授权
       [_locationManager requestWhenInUseAuthorization];// 使用时授权
2. 创建MKMapView地图试图,并添加到他的父试图上面，我的_mapView已设为全局变量

       _mapView = [[MKMapView alloc]initWithFrame:self.view.frame];
       [self.view addSubview:_mapView];

3. 设置相应属性
       //跟踪类型，是一个枚举：MKUserTrackingModeNone :不进行用户位置跟踪；MKUserTrackingModeFollow :跟踪用户位置；MKUserTrackingModeFollowWithHeading :跟踪用户位置并且跟踪用户前进方向；userTrackingMode
       _mapView.userTrackingMode = MKUserTrackingModeFollowWithHeading;

       //地图类型，是一个枚举：MKMapTypeStandard :标准地图，一般情况下使用此地图即可满足；MKMapTypeSatellite ：卫星地图；MKMapTypeHybrid ：混合地图，加载最慢比较消耗资源；mapType
       _mapView.mapType = MKMapTypeStandard;

       // 显示标尺
       _mapView.showsScale = YES;

       // 显示交通状态
       _mapView.showsTraffic = YES;

       //    显示罗盘
       _mapView.showsCompass = YES;
5. 挂上代理

       _mapView.delegate = self;

6. 显示用户位置

       _mapView.showsUserLocation = YES;

7. 实现代理方法，不止有这些还有很多其他的代理方法。

       - (void)mapView:(MKMapView *)mapView didUpdateUserLocation:(MKUserLocation *)userLocation{
              //让用户定位到当前位置       
               _mapView.centerCoordinate = userLocation.coordinate;

                [_mapView setRegion:MKCoordinateRegionMake(userLocation.coordinate, MKCoordinateSpanMake(0.1, 0.1))];

             /*
               * 设置地图上所显示的区域

               *  CLLocationCoordinate2D 设置该区域的中心点

               * MKCoordinateSpan 设置该区域的经纬度跨度

               * 例如：中国经纬度

               经度范围：73.33E 至 135.05E
               纬度范围：2.51N  至 53.33N

               为了简便，我们去掉小数

               中国中心点的纬度是（3 + 53）/ 2 = 北纬28度

               中国中心点的经度是（73 + 135）/ 2 = 东经104度

               中国纬度跨度是53 - 3 = 50度

               中国经度跨度是135 - 73 = 62度

               */
              //    MKCoordinateSpan span = MKCoordinateSpanMake(50, 62);//跨度越大，地图所显示的区域越大
              //    CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake(28, 104);
              //    MKCoordinateRegion regoin = MKCoordinateRegionMake(coordinate, span);
              //    [_mapView setRegion:regoin animated:YES];

       }

       - (void)mapView:(MKMapView *)mapView didFailToLocateUserWithError:(NSError *)error{

           NSLog(@&quot;定位失败%@&quot;,error);
       }
</code></pre><p>  总结，如果无法显示自己的位置，检查以下几点：</p>
<pre><code>0. 是否将定位管理器设为全局变量

1. 是否在项目中进行定位授权，是否在Info.plist中配置

2. 是否将showsUserLocation设为YES。

3. 是否配置模拟器 点击模拟器 -&gt; 菜单栏Dubug -&gt; Location -&gt; Apple来使模拟器定位，然后使用Custom Location配置模拟器的经纬度。
</code></pre><p>   最终效果如下：</p>
<p>   <img src="http://upload-images.jianshu.io/upload_images/1338564-0a79924b88d1bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中间的原点就是用户所在的位置"></p>
<h1 id="自定义用户位置的大头针"><a href="#自定义用户位置的大头针" class="headerlink" title="自定义用户位置的大头针"></a>自定义用户位置的大头针</h1><pre><code>其实上图中间的那个点就是一个大头针。现在我们要做的就是自定义这个大头针的样式，写代码之前需先了解以下知识：

1.  **MKAnnotationView**：大头针试图，能够自定义，用户当前位置的大头针默认样式是一个原点，非用户当前位置的大头针，系统默认用一个类似图钉样式的试图显示。

2. **MKAnnotation**：大头针的数据模型，只要一个NSObject类实现MKAnnotation协议就可以作为一个大头针数据模型，通常会重写协议中coordinate（标记位置）、title（标题）、**subtitle**（子标题）三个属性来自定义大头针的数据模型。

3. **给地图试图添加大头针的原理如下**
   &gt; 0. 准备大头针数据模型
   &gt; 1. 使用地图试图调用addAnnotaion给地图试图添加大头针数据模型。

   &gt; 2. 然后MKMapView会将数据模型传给一个代理方法，该代理方法会将该大头针数据模型包装到一个大头针试图（在该代理方法内可以自定义大头针试图），然后返回该大头针试图，返回的带有数据模型的大头针试图便会显示在地图上，如果返回为nil,则系统会默认一个大头针试图显示在地图上面。

找到你上面所写的项目，我接着那个项目继续。

实现MKMapView的如下代理方法，当一个大头针将要显示是会调用这个代理方法，该方法会返回一个大头针，如果返回为nil,则系统采用默认的大头针。

       - (nullable MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation{

             //查看文档可以发现MKUserLocatio实现了协议MKAnnotation,所以MKUserLocation也是一个大头针数据模型，有名字可知，这个大头针数据模型是用户当前位置大头针上的数据模型，这里判断传进来的数据模型是不是当前位置的数据模型，如果是就将这个数据模型封装一个大头针试图中。
             if ([annotation isKindOfClass:[MKUserLocation class]]) {

                    MKAnnotationView *userAnnotationView = [[MKAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;userAnnotation&quot;];

                    userAnnotationView.image = [UIImage imageNamed:@&quot;person.png&quot;];

                    //自定义大头针后，大头针是不可交互的，需要将canShowCallout设为YES方可再继续交互。
                    userAnnotationView.canShowCallout = YES;

                     //仅仅实现了让用户大头针在地图试图上往右偏了100
                     //userAnnotationView.centerOffset = CGPointMake(100, 0);
                     //让大头针的详情试图在地图试图上偏移，默认是在用户大头针的顶部
                    //userAnnotationView.calloutOffset = CGPointMake(100, 0);

                     //是否可以拖到大头针
                    //userAnnotationView.draggable = YES;

                    //leftCalloutAccessoryView的试图只有高度能够设置
                    userAnnotationView.leftCalloutAccessoryView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;person.png&quot;]];
                    userAnnotationView.rightCalloutAccessoryView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;person.png&quot;]];

                    //会将detail给覆盖
                    //userAnnotationView.detailCalloutAccessoryView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;person.png&quot;]];;

                   return userAnnotationView;
          }

          return nil;

       }
</code></pre><h1 id="长按地图添加大头针"><a href="#长按地图添加大头针" class="headerlink" title="长按地图添加大头针"></a>长按地图添加大头针</h1><pre><code> 首先复习一些上面提到的放置大头针原理
 &gt; 0. 准备大头针数据模型
 &gt; 1. 使用地图试图调用addAnnotaion给地图试图添加大头针数据模型。

&gt; 2. 然后MKMapView会将数据模型传给一个代理方法，该代理方法会将该大头针数据模型包装到一个大头针试图（在该代理方法内可以自定义大头针试图），然后返回该大头针试图，返回的带有数据模型的大头针试图便会显示在地图上，如果返回为nil,则系统会默认一个大头针试图显示在地图上面。

废话不多说，直接上代码，这是所有的代码，建议你新建一个控制器或者项目直接将所有代码考入即可：

  //
  //  ViewController.m
  //  Map
  //
  //  Created by GG on 16/3/9.
  //  Copyright © 2016年 GG. All rights reserved.
  //

  #import &quot;AnnotationViewController.h&quot;
  #import &lt;MapKit/MapKit.h&gt;
  #import &quot;DetailViewController.h&quot;
  @interface AnnotationViewController ()&lt;MKMapViewDelegate,CLLocationManagerDelegate&gt;
  {

      MKMapView *_mapView;

  }

  @property (nonatomic,retain) CLGeocoder *geocoder;
  @property (nonatomic,retain) CLLocationManager *locationManager;
  @end

  @implementation AnnotationViewController

  - (void)viewDidLoad {
      [super viewDidLoad];

      self.title = @&quot;大头针&quot;;
      self.view.backgroundColor = [UIColor whiteColor];

      _locationManager = [[CLLocationManager alloc]init];
      [_locationManager requestAlwaysAuthorization];
      [_locationManager requestWhenInUseAuthorization];
      _mapView = [[MKMapView alloc]initWithFrame:self.view.frame];

      _mapView.delegate = self;

      _mapView.userTrackingMode = MKUserTrackingModeFollowWithHeading;

      _mapView.mapType = MKMapTypeStandard;

      //    显示标尺
      _mapView.showsScale = YES;
      //    显示交通状态
      _mapView.showsTraffic = YES;
      //    显示罗盘
      _mapView.showsCompass = YES;

      _mapView.delegate = self;

      _mapView.showsUserLocation = YES;

      [self.view addSubview:_mapView];

      UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(longPressClick:)];

      [_mapView addGestureRecognizer:longPressGesture];

  }

  - (void)longPressClick:(UIGestureRecognizer *)sender{
      //试试不加这个判断的效果
      if (sender.state != UIGestureRecognizerStateBegan) {

          return;

      }

      //根据在试图上点击的位置获取到所点的坐标位置
      CLLocationCoordinate2D coordinate = [_mapView convertPoint:[sender locationInView:self.view] toCoordinateFromView:sender.view];

      CLLocation *location = [[CLLocation alloc]initWithLatitude:coordinate.latitude longitude:coordinate.longitude];

      // 反编码
      [self.geocoder reverseGeocodeLocation:location completionHandler:^(NSArray&lt;CLPlacemark *&gt; * _Nullable placemarks, NSError * _Nullable error) {

          MKPointAnnotation *annotation = [[MKPointAnnotation alloc]init];

          annotation.coordinate = coordinate;

          annotation.title = placemarks.firstObject.name;

          [_mapView addAnnotation:annotation];
      }];

  }

  - (void)mapView:(MKMapView *)mapView didUpdateUserLocation:(MKUserLocation *)userLocation{

      MKCoordinateSpan span = MKCoordinateSpanMake(0.1, 0.1);//跨度越大，地图所显示的区域越大
      MKCoordinateRegion regoin = MKCoordinateRegionMake(userLocation.location.coordinate, span);
      [mapView setRegion:regoin animated:YES];

  }

  - (void)mapView:(MKMapView *)mapView didFailToLocateUserWithError:(NSError *)error {

      NSLog(@&quot;定位失败：%@&quot;,error);

  }

  - (void)mapView:(MKMapView *)mapView didSelectAnnotationView:(MKAnnotationView *)view{

      DetailViewController *detailVC = [DetailViewController new];

      detailVC.view.backgroundColor = [UIColor whiteColor];

      //获取到该大头针试图的数据模型
      MKPointAnnotation *annotation = view.annotation;

      detailVC.title = annotation.title;

      //判断当前点击的大头针是不是显示当前用户位置的大头针，如果是就让他变色
      /*
       * MKPinAnnotationView是MKAnnotationView的子类，相比MKAnnotationView而言，他能够设置大头针颜色和显示大头针时的动画

       */
      if (![view.annotation isKindOfClass:[MKUserLocation class]]) {

          MKPinAnnotationView *pinView = (MKPinAnnotationView *)view;

          pinView.pinTintColor = [UIColor yellowColor];
      }

      [self.navigationController pushViewController:detailVC animated:YES];

  }

  - (nullable MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation{

      //系统定义的大头针数据模型专门用来表示用户当前位置大头针上的数据模型，遵守了MKAnnotation协议
      if ([annotation isKindOfClass:[MKUserLocation class]]) {

          MKAnnotationView *userAnnotationView = [[MKAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;userAnnotation&quot;];

          userAnnotationView.image = [UIImage imageNamed:@&quot;person.png&quot;];

          //如果将大头针给自定义会变成不可交互，将canShowCallout设为YES便可恢复交互
          userAnnotationView.canShowCallout = YES;

          //仅仅实现了让用户大头针在地图试图上往右偏了100
          //userAnnotationView.centerOffset = CGPointMake(100, 0);

          //让大头针的详情试图在地图试图上偏移，默认是在用户大头针的顶部
          //userAnnotationView.calloutOffset = CGPointMake(100, 0);

          //是否可以移动大头针
          userAnnotationView.draggable = YES;

          //leftCalloutAccessoryView的试图只有高度能够设置
    userAnnotationView.leftCalloutAccessoryView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;person.png&quot;]];
          userAnnotationView.rightCalloutAccessoryView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;person.png&quot;]];

           return userAnnotationView;
      }

      return nil;

  }

  - (CLGeocoder *)geocoder{

      if (_geocoder == nil) {

          _geocoder = [[CLGeocoder alloc]init];

      }

      return _geocoder;
  }

  @end
</code></pre><h1 id="总结：本文地图学习过程中用到的类"><a href="#总结：本文地图学习过程中用到的类" class="headerlink" title="总结：本文地图学习过程中用到的类"></a>总结：本文地图学习过程中用到的类</h1><pre><code>1.  **大头针分有两种类**

  1. MKPinAnnotationView：他是系统自带的大头针，继承于MKAnnotationView，形状跟棒棒糖类似，可以设置糖的颜色，和显示的时候是否有动画效果

  2. MKAnnotationView：可以用指定的图片作为大头针的样式，但显示的时候没有动画效果，如果没有给图片的话会什么都不显示

2. **MKAnnotation**：大头针的数据模型，只要一个NSObject类实现MKAnnotation协议就可以作为一个大头针数据模型，通常会重写协议中coordinate（标记位置）、title（标题）、**subtitle**（子标题）三个属性来自定义大头针的数据模型。

3. **MKUserLocation**：系统定义的大头针数据模型专门用来表示用户当前位置大头针上的数据模型，遵守了MKAnnotation协议。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://i1.buimg.com/8311/e0cc1a1fed3a4bda.jpg"
               alt="涅槃广广" />
          <p class="site-author-name" itemprop="name">涅槃广广</p>
          <p class="site-description motion-element" itemprop="description">说不定世界上根本就没有偶然，就如一切都是必然那样</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wangliguang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5987686599/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">涅槃广广</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"gg-ios"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
