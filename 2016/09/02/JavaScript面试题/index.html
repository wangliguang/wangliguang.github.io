<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Robot Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="在js中如何判断当前浏览器正在以何种方式解析？document对象有个属性compatMode,它有两个值：BackCompat对应quirks mode，CSS1Compat对应strict mode。
解释下JavaScript中this是如何工作的。this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。匿名函数或不处于任何对象中的函数指向window 。

如果是call，ap">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript面试题">
<meta property="og:url" content="http://yoursite.com/2016/09/02/JavaScript面试题/index.html">
<meta property="og:site_name" content="广广的技术博客">
<meta property="og:description" content="在js中如何判断当前浏览器正在以何种方式解析？document对象有个属性compatMode,它有两个值：BackCompat对应quirks mode，CSS1Compat对应strict mode。
解释下JavaScript中this是如何工作的。this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。匿名函数或不处于任何对象中的函数指向window 。

如果是call，ap">
<meta property="og:image" content="http://images.cnitblog.com/blog2015/716683/201504/171011349018292.jpg">
<meta property="og:updated_time" content="2016-09-02T09:46:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript面试题">
<meta name="twitter:description" content="在js中如何判断当前浏览器正在以何种方式解析？document对象有个属性compatMode,它有两个值：BackCompat对应quirks mode，CSS1Compat对应strict mode。
解释下JavaScript中this是如何工作的。this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。匿名函数或不处于任何对象中的函数指向window 。

如果是call，ap">
<meta name="twitter:image" content="http://images.cnitblog.com/blog2015/716683/201504/171011349018292.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/09/02/JavaScript面试题/"/>

  <title> JavaScript面试题 | 广广的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">广广的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">说不定世界上根本就没有偶然，就如一切都是必然那样</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JavaScript面试题
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T14:37:42+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/H5面试题/" itemprop="url" rel="index">
                    <span itemprop="name">H5面试题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/JavaScript面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/JavaScript面试题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="在js中如何判断当前浏览器正在以何种方式解析？"><a href="#在js中如何判断当前浏览器正在以何种方式解析？" class="headerlink" title="在js中如何判断当前浏览器正在以何种方式解析？"></a>在js中如何判断当前浏览器正在以何种方式解析？</h1><p>document对象有个属性compatMode,它有两个值：BackCompat对应quirks mode，CSS1Compat对应strict mode。</p>
<h1 id="解释下JavaScript中this是如何工作的。"><a href="#解释下JavaScript中this是如何工作的。" class="headerlink" title="解释下JavaScript中this是如何工作的。"></a>解释下JavaScript中this是如何工作的。</h1><p>this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。匿名函数或不处于任何对象中的函数指向window 。</p>
<ol>
<li><p>如果是call，apply,with，指定的this是谁，就是谁。</p>
</li>
<li><p>普通的函数调用，函数被谁调用，this就是谁。</p>
</li>
</ol>
<h1 id="解释下原型继承的原理。"><a href="#解释下原型继承的原理。" class="headerlink" title="解释下原型继承的原理。"></a>解释下原型继承的原理。</h1><p>以下代码展示了JS引擎如何查找属性：</p>
<pre><code>function getProperty(obj,prop) {
    if (obj.hasOwnProperty(prop)) {
        return obj[prop];
    } else if (obj.__proto__!==null) {
        return getProperty(obj.__proto__,prop);
    } else {
        return undefined;
    }
}
</code></pre><p><img src="http://images.cnitblog.com/blog2015/716683/201504/171011349018292.jpg" alt=""></p>
<h1 id="什么是闭包，如何使用它，为什么要使用它？"><a href="#什么是闭包，如何使用它，为什么要使用它？" class="headerlink" title="什么是闭包，如何使用它，为什么要使用它？"></a>什么是闭包，如何使用它，为什么要使用它？</h1><p>包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>使用闭包的注意点：</p>
<p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<p><a href="http://www.cnblogs.com/syfwhu/p/4839562.html" target="_blank" rel="external">关于闭包，详细了解请看JavaScript之作用域与闭包详解</a></p>
<h1 id="请举出一个匿名函数的典型用例？"><a href="#请举出一个匿名函数的典型用例？" class="headerlink" title="请举出一个匿名函数的典型用例？"></a>请举出一个匿名函数的典型用例？</h1><p>自执行函数，用闭包模拟私有变量、特权函数等。</p>
<h1 id="解释“JavaScript模块模式”以及你在何时使用它。"><a href="#解释“JavaScript模块模式”以及你在何时使用它。" class="headerlink" title="解释“JavaScript模块模式”以及你在何时使用它。"></a>解释“JavaScript模块模式”以及你在何时使用它。</h1><pre><code>如果有提到无污染的命名空间，可以考虑加分。

如果你的模块没有自己的命名空间会怎么样？
</code></pre><p>请看文章-<a href="http://www.cnblogs.com/syfwhu/p/4883532.html" target="_blank" rel="external">JavaScript之模块化编程</a>和<a href="http://www.cnblogs.com/syfwhu/p/4415586.html" target="_blank" rel="external">JavaScript之命名空间模式 浅析</a></p>
<h1 id="请指出JavaScript宿主对象和原生对象的区别？"><a href="#请指出JavaScript宿主对象和原生对象的区别？" class="headerlink" title="请指出JavaScript宿主对象和原生对象的区别？"></a>请指出JavaScript宿主对象和原生对象的区别？</h1><p><strong>原生对象</strong></p>
<p>ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。</p>
<p>“本地对象”包含哪些内容：Object、Function、Array、String、Boolean、Number、Date、RegExp、 Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、 URIError。</p>
<p>由此可以看出，简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。</p>
<p><strong>内置对象</strong></p>
<p>ECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。</p>
<p>同样是“独立于宿主环境”。根据定义我们似乎很难分清“内置对象”与“本地对象”的区别。而 ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。如此就可以理解了。内置对象是本地对象的一种。</p>
<p><strong>宿主对象</strong></p>
<p>何为“宿主对象”？主要在这个“宿主”的概念上，ECMAScript中的“宿主”当然就是我们网页的运行环境，即“操作系统”和“浏览器”。</p>
<p>所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的BOM和DOM都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象。</p>
<h1 id="call和-apply的区别是什么？"><a href="#call和-apply的区别是什么？" class="headerlink" title="call和.apply的区别是什么？"></a>call和.apply的区别是什么？</h1><p><strong>call方法: </strong></p>
<p>语法：call(thisObj，Object)<br>定义：调用一个对象的一个方法，以另一个对象替换当前对象。<br>说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 </p>
<p><strong>apply方法： </strong><br>语法：apply(thisObj，[argArray])<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象。<br>说 明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p>
<p>对于apply和call两者在作用上是相同的，但两者在参数上有以下区别：<br>对于第一个参数意义都一 样，但对第二个参数：apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开 始）。如 func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1, [var1,var2,var3])同时使用apply的好处是可以直接将当前函数的arguments对象作为apply的第二个参数传入。</p>
<h1 id="你何时优化自己的代码？"><a href="#你何时优化自己的代码？" class="headerlink" title="你何时优化自己的代码？"></a>你何时优化自己的代码？</h1><p>请看文章<a href="http://www.cnblogs.com/syfwhu/p/4438810.html" target="_blank" rel="external">JavaScript之高效编程</a> 及<a href="http://www.cnblogs.com/syfwhu/p/4814435.html" target="_blank" rel="external">JavaScript编码风格指南</a></p>
<h1 id="你能解释一下JavaScript中的继承是如何工作的吗？"><a href="#你能解释一下JavaScript中的继承是如何工作的吗？" class="headerlink" title="你能解释一下JavaScript中的继承是如何工作的吗？"></a>你能解释一下JavaScript中的继承是如何工作的吗？</h1><p> 原型链等。</p>
<h1 id="在什么时候你会使用document-write-？"><a href="#在什么时候你会使用document-write-？" class="headerlink" title="在什么时候你会使用document.write()？"></a>在什么时候你会使用document.write()？</h1><p>大多数生成的广告代码依旧使用document.write()，虽然这种用法会让人很不爽。</p>
<h1 id="请解释变量声明提升。"><a href="#请解释变量声明提升。" class="headerlink" title="请解释变量声明提升。"></a>请解释变量声明提升。</h1><p>在JS里定义的变量，存在于作用域链里，而在函数执行时会先把变量的声明进行提升，仅仅是把声明进行了提升，而其值的定义还在原来位置。示例如下：</p>
<pre><code>var test = function() {
    console.log(name); // 输出：undefined
    var name = &quot;jeri&quot;;
    console.log(name); // 输出：jeri
}

test();
</code></pre><p>上述代码与下述代码等价。</p>
<pre><code>var test = function() {
    var name;
    console.log(name); // 输出：undefined
    name = &quot;jeri&quot;;
    console.log(name); // 输出：jeri
}

test();
</code></pre><p>由以上代码可知，在函数执行时，把变量的声明提升到了函数顶部，而其值定义依然在原来位置。</p>
<h1 id="“attribute”和”property”的区别是什么？"><a href="#“attribute”和”property”的区别是什么？" class="headerlink" title="“attribute”和”property”的区别是什么？"></a>“attribute”和”property”的区别是什么？</h1><ol>
<li><strong>定义</strong></li>
</ol>
<p>Property：属性，所有的HTML元素都由HTMLElement类型表示，HTMLElement类型 直接继承自Element并添加了一些属性，添加的这些属性分别对应于每个HTML元素都有下面的这5个标准特性: id,title,lang,dir,className。DOM节点是一个对象，因此，他可以和其他的JavaScript对象一样添加自定义的属性以 及方法。property的值可以是任何的数据类型，对大小写敏感，自定义的property不会出现在html代码中，只存在js中。</p>
<p>Attribute：特性，区别于property，attribute只能是字符串，大小写不敏感，出现在innerHTML中，通过类数组attributes可以罗列所有的attribute。</p>
<ol>
<li><strong>相同之处</strong></li>
</ol>
<p>标准的 DOM properties 与 attributes 是同步的。公认的（非自定义的）特性会被以属性的形式添加到DOM对象中。如，id，align，style等，这时候操作property或者使用操作 特性的DOM方法如getAttribute()都可以操作属性。不过传递给getAttribute()的特性名与实际的特性名相同。因此对于 class的特性值获取的时候要传入“class”。</p>
<ol>
<li><strong>不同之处</strong></li>
</ol>
<p>1).对于有些标准的特性的操作，getAttribute与点号(.)获取的值存在差异性。如href，src，value，style，onclick等事件处理程序。<br>2).href：getAttribute获取的是href的实际值，而点号获取的是完整的url，存在浏览器差异。</p>
<h1 id="请指出document-onload和document-ready两个事件的区别。"><a href="#请指出document-onload和document-ready两个事件的区别。" class="headerlink" title="请指出document.onload和document.ready两个事件的区别。"></a>请指出document.onload和document.ready两个事件的区别。</h1><p>页面加载完成有两种事件，</p>
<ol>
<li>ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），</li>
<li>onload，指示页面包含图片等文件在内的所有元素都加载完成。</li>
</ol>
<h1 id="和-有什么不同？"><a href="#和-有什么不同？" class="headerlink" title="==和===有什么不同？"></a>==和===有什么不同？</h1><p>首先，== equality 等同，=== identity 恒等。 ==， 两边值类型不同的时候，要先进行类型转换，再比较。 ===，不做类型转换，类型不同的一定不等。</p>
<p>先说 ===，这个比较简单。下面的规则用来判断两个值是否===相等： </p>
<ol>
<li>如果类型不同，就[不相等] </li>
<li>如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断） </li>
<li>如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。 </li>
<li>如果两个值都是true，或者都是false，那么[相等]。 </li>
<li>如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。 </li>
<li>如果两个值都是null，或者都是undefined，那么[相等]。 </li>
</ol>
<p>再说 ==，根据以下规则： </p>
<p>如果两个值类型相同，进行 === 比较。<br>如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： </p>
<ol>
<li>如果一个是null、一个是undefined，那么[相等]。 </li>
<li>如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 </li>
<li>如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 </li>
<li>如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方 法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。非js核心的对象，令说（比 较麻烦，我也不大懂） </li>
<li>任何其他组合，都[不相等]。 </li>
</ol>
<h1 id="你如何从浏览器的URL中获取查询字符串参数。"><a href="#你如何从浏览器的URL中获取查询字符串参数。" class="headerlink" title="你如何从浏览器的URL中获取查询字符串参数。"></a>你如何从浏览器的URL中获取查询字符串参数。</h1><p>以下函数把获取一个key的参数。</p>
<pre><code>function parseQueryString ( name ){
    name = name.replace(/[\[]/,&quot;\\\[&quot;);
    var regexS = &quot;[\\?&amp;]&quot;+name+&quot;=([^&amp;#]*)&quot;;
    var regex = new RegExp( regexS );
    var results = regex.exec( window.location.href );

    if(results == null) {
        return &quot;&quot;;
    } else { 
        return results[1];
    }
}
</code></pre><h1 id="请解释一下JavaScript的同源策略。"><a href="#请解释一下JavaScript的同源策略。" class="headerlink" title="请解释一下JavaScript的同源策略。"></a>请解释一下JavaScript的同源策略。</h1><p>在客户端编程语言中，如javascript和 ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚 本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的 HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。</p>
<h1 id="请描述一下JavaScript的继承模式"><a href="#请描述一下JavaScript的继承模式" class="headerlink" title="请描述一下JavaScript的继承模式"></a>请描述一下JavaScript的继承模式</h1><p> <a href="http://www.cnblogs.com/syfwhu/p/4415586.html" target="_blank" rel="external">关于继承请看文章JavaScript之对象的继承</a></p>
<h1 id="什么是三元表达式？“三元”表示什么意思？"><a href="#什么是三元表达式？“三元”表示什么意思？" class="headerlink" title="什么是三元表达式？“三元”表示什么意思？"></a>什么是三元表达式？“三元”表示什么意思？</h1><p>三元表达式：? :。三元–三个操作对象。</p>
<p>在表达式boolean-exp ? value0 : value1 中，如果“布尔表达式”的结果为true，就计算“value0”，而且这个计算结果也就是操作符最终产生的值。如果“布尔表达式”的结果为false， 就计算“value1”，同样，它的结果也就成为了操作符最终产生的值。</p>
<h1 id="JavaScript里函数参数arguments是数组吗？"><a href="#JavaScript里函数参数arguments是数组吗？" class="headerlink" title="JavaScript里函数参数arguments是数组吗？"></a>JavaScript里函数参数arguments是数组吗？</h1><p>在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，通过使用下标就可以访问相应的参数。</p>
<p>arguments虽然有一些数组的性质，但其并非真正的数组，只是一个类数组对象。其并没有数组的很多方法，不能像真正的数组那样调用.jion(),.concat(),.pop()等方法。</p>
<h1 id="什么是”use-strict”-使用它的好处和坏处分别是什么？"><a href="#什么是”use-strict”-使用它的好处和坏处分别是什么？" class="headerlink" title="什么是”use strict”;?使用它的好处和坏处分别是什么？"></a>什么是”use strict”;?使用它的好处和坏处分别是什么？</h1><p>在代码中出现表达式-“use strict”; 意味着代码按照严格模式解析，这种模式使得Javascript在更严格的条件下运行。</p>
<p>好处：</p>
<ul>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>
</ul>
<p>坏处：</p>
<p>同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。</p>
<h1 id="解释”chaining”。"><a href="#解释”chaining”。" class="headerlink" title="解释”chaining”。"></a>解释”chaining”。</h1><p>jQuery方法链接。直到现在，我们都是一次写一条jQuery语句（一条接着另一条）。不过，有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条jQuery命令，一条接着另一条。</p>
<p>提示：这样的话，浏览器就不必多次查找相同的元素。</p>
<p>如需链接一个动作，您只需简单地把该动作追加到之前的动作上。</p>
<h1 id="解释”deferreds”。"><a href="#解释”deferreds”。" class="headerlink" title="解释”deferreds”。"></a>解释”deferreds”。</h1><p>开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。</p>
<p>通常的做法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。</p>
<p>但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了deferred对象。</p>
<p>简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行</p>
<h1 id="你知道哪些针对jQuery的优化方法？"><a href="#你知道哪些针对jQuery的优化方法？" class="headerlink" title="你知道哪些针对jQuery的优化方法？"></a>你知道哪些针对jQuery的优化方法？</h1><h2 id="1-总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById-方法。"><a href="#1-总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById-方法。" class="headerlink" title="1. 总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById()方法。"></a>1. 总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById()方法。</h2><p>例如有一段HTML代码：</p>
<pre><code>&lt;div id=&quot;content&quot;&gt;
    &lt;form method=&quot;post&quot;action=&quot;#&quot;&gt;
        &lt;h2&gt;交通信号灯&lt;/h2&gt;
        &lt;ul id=&quot;traffic_light&quot;&gt;
            &lt;li&gt;
                &lt;input type=&quot;radio&quot;class=&quot;on&quot;name=&quot;light&quot;value=&quot;red&quot;/&gt;红色
            &lt;/li&gt;
            &lt;li&gt;
                &lt;input type=&quot;radio&quot;class=&quot;off&quot;name=&quot;light&quot;value=&quot;yellow&quot;/&gt;黄色
            &lt;/li&gt;
            &lt;li&gt;
                &lt;input type=&quot;radio&quot;class=&quot;off&quot;name=&quot;light&quot;value=&quot;green&quot;/&gt;绿色
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;input class=&quot;button&quot;id=&quot;traffic_button&quot;type=&quot;submit&quot;value=&quot;Go&quot;/&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre><p>比如需要选择红绿单选框，那么可以使用一个tag name来限制(修饰)class，如下所 示：var active_light=$(“input.on”);当然也可以结合就近的ID，如下所 示：var active_light=$(“#traffic_light input.on”);  如果采用下面的选择器，那么效率是低效的。var traffic_button=$(“#content.button”);因为button已经有 ID了，我们可以直接使用ID选择器。如下所示：var traffic_button=$(“#traffic_button”);当然这只是对于单一 的元素来讲。如果你需要选择多个元素，这必然会涉及到DOM遍历和循环，为了提高性能，建议从最近的ID开始继承。如下所示：</p>
<pre><code>var traffic_lights=$(“#traffic_light input”); 
</code></pre><h2 id="2-在class前使用tag-标签名-在jQuery中第二快的选择器是tag-标签-选择器-比如：-“head”"><a href="#2-在class前使用tag-标签名-在jQuery中第二快的选择器是tag-标签-选择器-比如：-“head”" class="headerlink" title="2. 在class前使用tag(标签名)在jQuery中第二快的选择器是tag(标签)选择器(比如：$(“head”))"></a>2. 在class前使用tag(标签名)在jQuery中第二快的选择器是tag(标签)选择器(比如：$(“head”))</h2><p>跟ID选择器累时，因为它来自原生的getElementsByTagName()方法。继续看刚才那段HTML代码：</p>
<p>在使用tag来修饰class的时候，我们需要注意以下几点：</p>
<pre><code>（1）不要使用tag来修饰ID，如下所 示：var content=$(“div#content”);这样一来，选择器会先遍历所有的div元素，然后匹配#content。（好像 jQuery从1.3.1开始改变了选择器核心后，不存在这个问题了。暂时无法考证。）
（2）不要画蛇添足的使用ID来修饰ID，如下所 示：var traffic_light=$(“#content#traffic_light”);
</code></pre><h2 id="3-将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。"><a href="#3-将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。" class="headerlink" title="3. 将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。"></a>3. 将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。</h2><p>下面是一个jQuery新手写的一段代码：</p>
<pre><code>$(&quot;#traffic_light input.on&quot;).bind(&quot;click&quot;,function(){});
$(&quot;#traffic_light input.on&quot;).css(&quot;border&quot;,&quot;1px dashed yellow&quot;);
$(&quot;#traffic_light input.on&quot;).css(&quot;background-color&quot;,&quot;orange&quot;);
$(&quot;#traffic_light input.on&quot;).fadeIn(&quot;slow&quot;);
</code></pre><p>但切记不要这么做。我们应该先将对象缓存进一个变量然后再操作，如下所示：</p>
<p>记住，永远不要让相同的选择器在你的代码里出现多次.注：</p>
<pre><code>（1）为了区分普通的JavaScript对象和jQuery对象，可以在变量首字母前加上$符号。
（2）上面代码可以使用jQuery的链式操作加以改善。如下所示：


     var $active_light = $(&quot;#traffic_light input.on&quot;);

     $active_light.bind(&quot;click&quot;,function(){})
     .css(&quot;border&quot;,&quot;1px dashed yellow&quot;)
     .css(&quot;background-color&quot;,&quot;orange&quot;)
     .fadeIn(&quot;slow&quot;);
</code></pre><h2 id="4-如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。"><a href="#4-如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。" class="headerlink" title="4. 如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。"></a>4. 如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。</h2><p>如下代码所示：</p>
<pre><code>// 在全局范围定义一个对象(例如:window对象)
window.$my = {
    head:$(&quot;head&quot;),
    trafficLight:$(&quot;#trafficLight&quot;),
    trafficButton:$(&quot;#trafficButton&quot;)
};

function doSomething(){
    // 现在你可以引用存储的结果并操作它们
    var script=document.createElement(&quot;script&quot;);
    $my.head.append(script);

    // 当你在函数内部操作是,可以继续将查询存入全局对象中去.
    $my.coolResults=$(&quot;#some_ul li&quot;);
    $my.otherResults=$(&quot;#some_table td&quot;);

    // 将全局函数作为一个普通的jquery对象去使用.
    $my.otherResults.css(&quot;border-color&quot;,&quot;red&quot;);
    $my.trafficLight.css(&quot;border-color&quot;,&quot;green&quot;);
}
// 你也可以在其他函数中使用它.
</code></pre><p>这里的基本思想是在内存中建立你确实想要的东西，然后更新DOM。这并不是一个jQuery最佳实践，但必须进行有效的JavaScript操作。直接的DOM操作速度很慢。例如，你想动态的创建一组列表元素，千万不要这样做,如下所示：对直接的DOM操作进行限制。</p>
<pre><code>var top_100_list = [];// 假设这里是100个独一无二的字符串
var $mylist = $(&quot;#mylist&quot;);// jQuery选择到&lt;ul&gt;元素

for(var i = 0,l = top_100_list.length;i&lt;l;i++) {
    $mylist.append(&quot;&lt;li&gt;&quot; + top_100_list[i] + &quot;&lt;/li&gt;&quot;);
}
</code></pre><p>我们应该将整套元素字符串在插入进dom中之前先全部创建好，如下所示：</p>
<pre><code>$(&quot;#entryform input&quot;).bind(&quot;focus&quot;,function() {
    $(this).addClass(&quot;selected&quot;);
}).bind(&quot;blur&quot;,function(){
    $(this).removeClass(&quot;selected&quot;);
});
</code></pre><h2 id="5-冒泡除非在特殊情况下-否则每一个js事件-例如-click-mouseover等-都会冒泡到父级节点。"><a href="#5-冒泡除非在特殊情况下-否则每一个js事件-例如-click-mouseover等-都会冒泡到父级节点。" class="headerlink" title="5. 冒泡除非在特殊情况下,否则每一个js事件(例如:click,mouseover等.)都会冒泡到父级节点。"></a>5. 冒泡除非在特殊情况下,否则每一个js事件(例如:click,mouseover等.)都会冒泡到父级节点。</h2><p>当我们需要给多个元素调用同个函数时这点会很有用。代替这种效率很差的多元素事件监听的方法就是,你只需向它们的父节点绑定一次。比如,我们要为一 个拥有很多输入框的表单绑定这样的行为:当输入框被选中时为它添加一个class传统的做法是，直接选中input，然后绑定focus等，如下所示：</p>
<pre><code>$(&quot;#entryform&quot;).bind(&quot;focus&quot;,function(e) {
    var $cell = $(e.target); // e.target捕捉到触发的目标元素
    $cell.addClass(&quot;selected&quot;);
}).bind(&quot;blur&quot;,function(e) {
    var $cell = $(e.target);
    $cell.removeClass(&quot;selected&quot;);
});
</code></pre><p>当然上面代码能帮我们完成相应的任务，但如果你要寻求更高效的方法，请使用如下代码：</p>
<p>通过在父级监听获取焦点和失去焦点的事件，对目标元素进行操作。在上面代码中，父级元素扮演了一个调度员的角色,它可以基于目标元素绑定事件。如果你发现你给很多元素绑定了同一个事件监听,那么现在的你肯定知道哪里做错了。</p>
<h2 id="6-推迟到-window-load。"><a href="#6-推迟到-window-load。" class="headerlink" title="6. 推迟到$(window).load。"></a>6. 推迟到$(window).load。</h2><p>jQuery对于开发者来说有一个很诱人的东西,可以把任何东西挂到$(document).ready下。尽管$(document).rady 确实很有用，它可以在页面渲染时，其它元素还没下载完成就执行。如果你发现你的页面一直是载入中的状态，很有可能就是$(document).ready 函数引起的。你可以通过将jQuery函数绑定到$(window).load事件的方法来减少页面载入时的cpu使用率。它会在所有的html(包括 iframe)被下载完成后执行。一些特效的功能，例如拖放,视觉特效和动画,预载入隐藏图像等等，都是适合这种技术的场合。</p>
<h2 id="7-压缩JavaScript。"><a href="#7-压缩JavaScript。" class="headerlink" title="7. 压缩JavaScript。"></a>7. 压缩JavaScript。</h2><p>在线压缩地址:<a href="http://dean.edwards.name/packer/" target="_blank" rel="external">http://dean.edwards.name/packer/</a> 压缩之前，请保证你的代码的规范性，否则可能失败，导致Js错误。</p>
<h2 id="8-尽量使用ID代替Class。"><a href="#8-尽量使用ID代替Class。" class="headerlink" title="8. 尽量使用ID代替Class。"></a>8. 尽量使用ID代替Class。</h2><p> 前面性能优化已经说过，ID选择器的速度是最快的。所以在HTML代码中，能使用ID的尽量使用ID来代替class。看下面的一个例子：</p>
<pre><code>// 创建一个list
var $myList = $(&apos;#myList&apos;);
var myListItems = &apos;&lt;ul&gt;&apos;;

for(var i = 0; i &lt; 1000; i ++) {
    myListItems += &apos;&lt;li class = &quot;listItem&apos;+i+&apos;&quot;&gt;This is a list item&lt;/li&gt;&apos;;
    // 这里使用的是class
}

myListItems += &apos;&lt;/ul&gt;&apos;;
$myList.html(myListItems);
// 选择每一个li

for(var i = 0; i&lt;1000; i++) {
    var selectedItem = $(&apos;.listItem&apos; + i);
}
</code></pre><p>在上段代码中，选择每个li总共只用了61毫秒，相比class的方式，将近快了100倍。       在代码最后，选择每个li的过程中，总共用了5066毫秒，超过5秒了。接着我们做一个对比，用ID代替class：</p>
<h2 id="9-给选择器一个上下文。"><a href="#9-给选择器一个上下文。" class="headerlink" title="9. 给选择器一个上下文。"></a>9. 给选择器一个上下文。</h2><p>jQuery选择器中有一个这样的选择器，它能指定上下文。jQuery(expression,context);通过它，能缩小选择器在DOM 中搜索的范围，达到节省时间，提高效率。普通方式：$(‘.myDiv’)改进方式：$(‘.myDiv’,$(“#listItem”))。</p>
<h2 id="10-慎用-live-方法（应该说尽量不要使用）。"><a href="#10-慎用-live-方法（应该说尽量不要使用）。" class="headerlink" title="10. 慎用.live()方法（应该说尽量不要使用）。"></a>10. 慎用.live()方法（应该说尽量不要使用）。</h2><p>这是jQuery1.3.1版本之后增加的方法，这个方法的功能就是为新增的DOM元素动态绑定事件。但对于效率来说，这个方法比较占用资源。所以请尽量不要使用它。例如有这么一段代码:</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    $(function(){

        $(&quot;p&quot;).click(function(){
            alert($(this).text());
        });

        $(&quot;button&quot;).click(function(){
            $(&quot;&lt;p&gt;this is second p&lt;/p&gt;&quot;).appendTo(&quot;body&quot;);
        });
    })
&lt;/script&gt;
&lt;body&gt;
    &lt;p&gt;this is first p&lt;/p&gt;
    &lt;button&gt;add&lt;/button&gt;
&lt;/body&gt;
</code></pre><p>运行后，你会发现新增的p元素，并没用被绑定click事件。你可以改成.live(“click”)方式解决此问题，代码如下：</p>
<pre><code>$(function() {
    $(&quot;p&quot;).live(&quot;click&quot;,function() {
        // 改成live方式
        alert($(this).text());
    });

    $(&quot;button&quot;).click(function() {
        $(&quot;&lt;p&gt;this is second p&lt;/p&gt;&quot;).appendTo(&quot;body&quot;);
    });
})
</code></pre><p>但我并不建议大家这么做，我想用另一种方式去解决这个问题，代码如下：</p>
<pre><code>$(function() {
    $(&quot;p&quot;).click(function() {
        alert($(this).text());
    });

    $(&quot;button&quot;).click(function() {
        $(&quot;&lt;p&gt;this is second p&lt;/p&gt;&quot;).click(function() {
            // 为新增的元素重新绑定一次
            alert($(this).text());
        }).appendTo(&quot;body&quot;);
    });
})
</code></pre><p>虽然我把绑定事件重新写了一次，代码多了点，但这种方式的效率明显高于live()方式，特别是在频繁的DOM操作中，这点非常明显。</p>
<h1 id="请说出你可以传递给jQuery方法的四种不同值。"><a href="#请说出你可以传递给jQuery方法的四种不同值。" class="headerlink" title="请说出你可以传递给jQuery方法的四种不同值。"></a>请说出你可以传递给jQuery方法的四种不同值。</h1><p>选择器（字符串），HTML（字符串），回调函数，HTML元素，对象，数组，元素数组，jQuery对象等。</p>
<h1 id="什么是效果队列？"><a href="#什么是效果队列？" class="headerlink" title="什么是效果队列？"></a>什么是效果队列？</h1><p>jQuery中有个动画队列的机制。当我们对一个对象添加多次动画效果时后添加的动作就会被放入这个动画队列中，等前面的动画完成后再开始执行。可 是用户的操作往往都比动画快，如果用户对一个对象频繁操作时不处理动画队列就会造成队列堆积，影响到效果。jQuery中有stop这个方法可以停止当前 执行的动画，并且它有两个布尔参数，默认值都为false。第一个参数为true时会清空动画队列，第二个参数为true时会瞬间完成掉当前动画。所以， 我们经常使用obj.stop(true,true)来停止动画。但是这还不够！正如jQuery文档中的说法，即使第二个参数为true，也仅仅是把当 前在执行的动画跳转到完成状态。这时第一个参数如果也为true，后面的队列就会被清空。如果一个效果需要多个动画同时处理，我们仅完成其中的一个而把后 面的队列丢弃了，这就会出现意料之外的结果。</p>
<h1 id="请指出-get-，-，eq-的区别。"><a href="#请指出-get-，-，eq-的区别。" class="headerlink" title="请指出.get()，[]，eq()的区别。"></a>请指出.get()，[]，eq()的区别。</h1><p><strong>eq:</strong> 返回是一个jquery对象作用是将匹配的元素集合缩减为一个元素。这个元素在匹配元素集合中的位置变为0，而集合长度变成1。</p>
<p><strong>get:</strong> 是一个html对象数组作用是取得其中一个匹配的元素。num表示取得第几个匹配的元素。</p>
<h1 id="请指出-bind-，-live-和-delegate-的区别。"><a href="#请指出-bind-，-live-和-delegate-的区别。" class="headerlink" title="请指出.bind()，.live()和.delegate()的区别。"></a>请指出.bind()，.live()和.delegate()的区别。</h1><p>在操纵DOM的语境中，document是根节点。现在我们可以较容易地说明.bind()、.live()和.delegate()的不同之处了。</p>
<p><strong>.bind()</strong></p>
<pre><code>$(&apos;a&apos;).bind(&apos;click&apos;, function() {alert(&quot;That tickles!&quot;)});
</code></pre><p>这是最简单的绑定方法了。JQuery扫描文档找出所有的$(‘a’)元素，并把alert函数绑定到每个元素的click事件上。</p>
<p><strong>.live()</strong></p>
<pre><code>$(&apos;a&apos;).live(&apos;click&apos;, function() {alert(&quot;That tickles!&quot;)});
</code></pre><p>JQuery把alert函数绑定到$(document)元素上，并使用’click’和’a’作为参数。任何时候只要有事件冒泡到 document节点上，它就查看该事件是否是一个click事件，以及该事件的目标元素与’a’这一CSS选择器是否匹配，如果都是的话，则执行函数。</p>
<p>live方法还可以被绑定到具体的元素(或context)而不是document上，像这样：</p>
<pre><code>$(&apos;a&apos;, $(&apos;#container&apos;)[0]).live(...);
</code></pre><p><strong>.delegate()</strong></p>
<pre><code>$(&apos;#container&apos;).delegate(&apos;a&apos;, &apos;click&apos;, function() {alert(&quot;That tickles!&quot;)});
</code></pre><p>JQuery扫描文档查找$(‘#container’)，并使用click事件和’a’这一CSS选择器作为参数把alert函数绑定 到$(‘#container’)上。任何时候只要有事件冒泡到$(‘#container’)上，它就查看该事件是否是click事件，以及该事件的目 标元素是否与CCS选择器相匹配。如果两种检查的结果都为真的话，它就执行函数。</p>
<p>可以注意到，这一过程与.live()类似，但是其把处理程序绑定到具体的元素而非document这一根上。精明的JS’er们可能会做出这样的结论，即$(‘a’).live()==$(document).delegate(‘a’)，是这样吗?嗯，不，不完全是。</p>
<p>为什么.delegate()要比.live()好用？</p>
<p>基于几个原因，人们通常更愿意选用jQuery的delegate方法而不是live方法。考虑下面的例子：</p>
<pre><code>$(&apos;a&apos;).live(&apos;click&apos;, function(){blah()}); // 或者
$(document).delegate(&apos;a&apos;, &apos;click&apos;, function(){blah()});
</code></pre><p><strong>速度</strong></p>
<p>后者实际上要快过前者，因为前者首先要扫描整个的文档查找所有的$(‘a’)元素，把它们存成jQuery对象。尽管live函数仅需要把’a’作 为串参数传递以用做之后的判断，但是$()函数并未知道被链接的方法将会是.live()。而另一方面，delegate方法仅需要查找并存 储$(document)元素。</p>
<p>一种寻求避开这一问题的方法是调用在$(document).ready()之外绑定的live，这样它就会立即执行。在这种方式下，其会在DOM获得填充之前运行，因此就不会查找元素或是创建jQuery对象了。</p>
<p><strong>灵活性和链能力</strong></p>
<p>live函数也挺令人费解的。想想看，它被链到$(‘a’)对象集上，但其实际上是在$(document)对象上发生作用。由于这个原因，它能够 试图以一种吓死人的方式来把方法链到自身上。实际上，我想说的是，以$.live(‘a’,…)这一形式作为一种全局性的jQuery方法，live方法 会更具意义一些。</p>
<p><strong>仅支持CSS选择器</strong></p>
<p>最后一点，live方法有一个非常大的缺点，那就是它仅能针对直接的CSS选择器做操作，这使得它变得非常的不灵活。</p>
<p>为什么选择.live()或.delegate()而不是.bind()？<br>毕竟，bind看起来似乎更加的明确和直接，难道不是吗?嗯，有两个原因让我们更愿意选择delegate或live而不是bind：</p>
<p>为了把处理程序附加到可能还未存在于DOM中的DOM元素之上。因为bind是直接把处理程序绑定到各个元素上，它不能把处理程序绑定到还未存在于页面中的元素之上。</p>
<p>如果你运行了$(‘a’).bind(…)，而后新的链接经由AJAX加入到了页面中，则你的bind处理程序对于这些新加入的链接来说是无效的。 而另一方面live和delegate则是被绑定到另一个祖先节点上，因此其对于任何目前或是将来存在于该祖先元素之内的元素都是有效的。</p>
<p>或者为了把处理程序附加到单个元素上或是一小组元素之上，监听后代元素上的事件而不是循环遍历并把同一个函数逐个附加到DOM中的100个元素上。把处理程序附加到一个(或是一小组)祖先元素上而不是直接把处理程序附加到页面中的所有元素上，这种做法带来了性能上的好处。</p>
<p><strong>停止传播</strong></p>
<p>最后一个我想做的提醒与事件传播有关。通常情况下，我们可以通过使用这样的事件方法来终止处理函数的执行：</p>
<pre><code>$(&apos;a&apos;).bind(&apos;click&apos;, function(e) {
    e.preventDefault();
    // 或者 e.stopPropagation();
});
</code></pre><p>不过，当我们使用live或是delegate方法的时候，处理函数实际上并没有在运行，需要等到事件冒泡到处理程序实际绑定的元素上时函数才会运行。而到此时为止，我们的其他的来自.bind()的处理函数早已运行了。</p>
<h1 id="请指出-和-fn的区别，或者说出-fn的用途。"><a href="#请指出-和-fn的区别，或者说出-fn的用途。" class="headerlink" title="请指出$和$.fn的区别，或者说出$.fn的用途。"></a>请指出$和$.fn的区别，或者说出$.fn的用途。</h1><p>Jquery为开发插件提供了两个方法，分别是：</p>
<pre><code>$.extend(obj);
$.fn.extend(obj);
</code></pre><p>1.那么这两个分别是什么意思？</p>
<pre><code>$.extend(obj);是为了扩展jquery本身，为类添加新的方法。

$.fn.extend(obj);给JQUERY对象添加方法。
</code></pre><p>2.$.fn中的fn是什么意思，其实是prototype，即$.fn=$.prototype;<br>具体用法请看下面的例子：</p>
<pre><code>$.extend({

    add:function(a, b) {
        return a+b;
    }
})

$.add(5,8); // return 13
</code></pre><p>注意没有，这边的调用直接调用，前面不用任何对象。直接$.+方法名</p>
<p>$.fn.extend(obj)；对prototype进行扩展，为jquery类添加成员函数，jquery类的实例可以使用这个成员函数。</p>
<pre><code>$.fn.extend({

    clickwhile:function(){

        $(this).click(function(){
            alert($(this).val())
        })
    }
})

$(&apos;input&apos;).clickwhile(); // 当点击输入框会弹出该对象的Value值
</code></pre><p>注意调用时候前面是有对象的。即$(‘input’)这么个东西。</p>
<h1 id="var-foo-foo-push-1-foo-push-2-问题：foo-length的值是什么？"><a href="#var-foo-foo-push-1-foo-push-2-问题：foo-length的值是什么？" class="headerlink" title="var foo=[];foo.push(1);foo.push(2);问题：foo.length的值是什么？"></a>var foo=[];foo.push(1);foo.push(2);问题：foo.length的值是什么？</h1><p> 答案：2</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/02/HTML面试题/" rel="next" title="HTML面试题">
                <i class="fa fa-chevron-left"></i> HTML面试题
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/02/CSS面试题/" rel="prev" title="CSS面试题">
                CSS面试题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/09/02/JavaScript面试题/"
           data-title="JavaScript面试题" data-url="http://yoursite.com/2016/09/02/JavaScript面试题/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://i1.buimg.com/8311/e0cc1a1fed3a4bda.jpg"
               alt="涅槃广广" />
          <p class="site-author-name" itemprop="name">涅槃广广</p>
          <p class="site-description motion-element" itemprop="description">说不定世界上根本就没有偶然，就如一切都是必然那样</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wangliguang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5987686599/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#在js中如何判断当前浏览器正在以何种方式解析？"><span class="nav-number">1.</span> <span class="nav-text">在js中如何判断当前浏览器正在以何种方式解析？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解释下JavaScript中this是如何工作的。"><span class="nav-number">2.</span> <span class="nav-text">解释下JavaScript中this是如何工作的。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解释下原型继承的原理。"><span class="nav-number">3.</span> <span class="nav-text">解释下原型继承的原理。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是闭包，如何使用它，为什么要使用它？"><span class="nav-number">4.</span> <span class="nav-text">什么是闭包，如何使用它，为什么要使用它？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请举出一个匿名函数的典型用例？"><span class="nav-number">5.</span> <span class="nav-text">请举出一个匿名函数的典型用例？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解释“JavaScript模块模式”以及你在何时使用它。"><span class="nav-number">6.</span> <span class="nav-text">解释“JavaScript模块模式”以及你在何时使用它。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请指出JavaScript宿主对象和原生对象的区别？"><span class="nav-number">7.</span> <span class="nav-text">请指出JavaScript宿主对象和原生对象的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#call和-apply的区别是什么？"><span class="nav-number">8.</span> <span class="nav-text">call和.apply的区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你何时优化自己的代码？"><span class="nav-number">9.</span> <span class="nav-text">你何时优化自己的代码？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你能解释一下JavaScript中的继承是如何工作的吗？"><span class="nav-number">10.</span> <span class="nav-text">你能解释一下JavaScript中的继承是如何工作的吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在什么时候你会使用document-write-？"><span class="nav-number">11.</span> <span class="nav-text">在什么时候你会使用document.write()？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请解释变量声明提升。"><span class="nav-number">12.</span> <span class="nav-text">请解释变量声明提升。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#“attribute”和”property”的区别是什么？"><span class="nav-number">13.</span> <span class="nav-text">“attribute”和”property”的区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请指出document-onload和document-ready两个事件的区别。"><span class="nav-number">14.</span> <span class="nav-text">请指出document.onload和document.ready两个事件的区别。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#和-有什么不同？"><span class="nav-number">15.</span> <span class="nav-text">==和===有什么不同？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你如何从浏览器的URL中获取查询字符串参数。"><span class="nav-number">16.</span> <span class="nav-text">你如何从浏览器的URL中获取查询字符串参数。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请解释一下JavaScript的同源策略。"><span class="nav-number">17.</span> <span class="nav-text">请解释一下JavaScript的同源策略。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请描述一下JavaScript的继承模式"><span class="nav-number">18.</span> <span class="nav-text">请描述一下JavaScript的继承模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是三元表达式？“三元”表示什么意思？"><span class="nav-number">19.</span> <span class="nav-text">什么是三元表达式？“三元”表示什么意思？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript里函数参数arguments是数组吗？"><span class="nav-number">20.</span> <span class="nav-text">JavaScript里函数参数arguments是数组吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是”use-strict”-使用它的好处和坏处分别是什么？"><span class="nav-number">21.</span> <span class="nav-text">什么是”use strict”;?使用它的好处和坏处分别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解释”chaining”。"><span class="nav-number">22.</span> <span class="nav-text">解释”chaining”。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解释”deferreds”。"><span class="nav-number">23.</span> <span class="nav-text">解释”deferreds”。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你知道哪些针对jQuery的优化方法？"><span class="nav-number">24.</span> <span class="nav-text">你知道哪些针对jQuery的优化方法？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById-方法。"><span class="nav-number">24.1.</span> <span class="nav-text">1. 总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById()方法。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-在class前使用tag-标签名-在jQuery中第二快的选择器是tag-标签-选择器-比如：-“head”"><span class="nav-number">24.2.</span> <span class="nav-text">2. 在class前使用tag(标签名)在jQuery中第二快的选择器是tag(标签)选择器(比如：$(“head”))</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。"><span class="nav-number">24.3.</span> <span class="nav-text">3. 将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。"><span class="nav-number">24.4.</span> <span class="nav-text">4. 如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-冒泡除非在特殊情况下-否则每一个js事件-例如-click-mouseover等-都会冒泡到父级节点。"><span class="nav-number">24.5.</span> <span class="nav-text">5. 冒泡除非在特殊情况下,否则每一个js事件(例如:click,mouseover等.)都会冒泡到父级节点。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-推迟到-window-load。"><span class="nav-number">24.6.</span> <span class="nav-text">6. 推迟到$(window).load。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-压缩JavaScript。"><span class="nav-number">24.7.</span> <span class="nav-text">7. 压缩JavaScript。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-尽量使用ID代替Class。"><span class="nav-number">24.8.</span> <span class="nav-text">8. 尽量使用ID代替Class。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-给选择器一个上下文。"><span class="nav-number">24.9.</span> <span class="nav-text">9. 给选择器一个上下文。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-慎用-live-方法（应该说尽量不要使用）。"><span class="nav-number">24.10.</span> <span class="nav-text">10. 慎用.live()方法（应该说尽量不要使用）。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请说出你可以传递给jQuery方法的四种不同值。"><span class="nav-number">25.</span> <span class="nav-text">请说出你可以传递给jQuery方法的四种不同值。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是效果队列？"><span class="nav-number">26.</span> <span class="nav-text">什么是效果队列？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请指出-get-，-，eq-的区别。"><span class="nav-number">27.</span> <span class="nav-text">请指出.get()，[]，eq()的区别。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请指出-bind-，-live-和-delegate-的区别。"><span class="nav-number">28.</span> <span class="nav-text">请指出.bind()，.live()和.delegate()的区别。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请指出-和-fn的区别，或者说出-fn的用途。"><span class="nav-number">29.</span> <span class="nav-text">请指出$和$.fn的区别，或者说出$.fn的用途。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#var-foo-foo-push-1-foo-push-2-问题：foo-length的值是什么？"><span class="nav-number">30.</span> <span class="nav-text">var foo=[];foo.push(1);foo.push(2);问题：foo.length的值是什么？</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">涅槃广广</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"gg-ios"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
