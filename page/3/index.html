<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Robot Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="说不定世界上根本就没有偶然，就如一切都是必然那样">
<meta property="og:type" content="website">
<meta property="og:title" content="广广的技术博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="广广的技术博客">
<meta property="og:description" content="说不定世界上根本就没有偶然，就如一切都是必然那样">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="广广的技术博客">
<meta name="twitter:description" content="说不定世界上根本就没有偶然，就如一切都是必然那样">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/3/"/>

  <title> 广广的技术博客 - 说不定世界上根本就没有偶然，就如一切都是必然那样 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">广广的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">说不定世界上根本就没有偶然，就如一切都是必然那样</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/HTML面试题/" itemprop="url">
                  HTML面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T11:06:38+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/H5面试题/" itemprop="url" rel="index">
                    <span itemprop="name">H5面试题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/HTML面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/HTML面试题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTML和XHTML有什么区别？"><a href="#HTML和XHTML有什么区别？" class="headerlink" title="HTML和XHTML有什么区别？"></a>HTML和XHTML有什么区别？</h1><h2 id="XHTML-HTML"><a href="#XHTML-HTML" class="headerlink" title="XHTML,HTML"></a>XHTML,HTML</h2><p>   XHTML 与 HTML 4.01 标准没有太多的不同， XHTML1.0 是 XML 风格的 HTML4.01 ,标签的规范更加严格 , W3C一直是推崇XHTML这种严格类型的语法, 但是 XHTML 从 1.0 升级到了 1.1 以后就夭折了。</p>
<h2 id="html和xhtml最主要的不同："><a href="#html和xhtml最主要的不同：" class="headerlink" title="html和xhtml最主要的不同："></a>html和xhtml最主要的不同：</h2><ul>
<li><p>XHTML 元素必须被正确地嵌套。</p>
<pre><code>错误：&lt;Head&gt;&lt;/Head&gt;&lt;Body&gt;&lt;/Body&gt;
正确：&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;
</code></pre></li>
<li><p>XHTML 元素必须被关闭。</p>
<pre><code>错误：&lt;p&gt;xxxx
正确: &lt;p&gt;xxxx&lt;/p&gt;
</code></pre></li>
<li><p>标签名必须用小写字母。</p>
<pre><code>错误：&lt;Div&gt;&lt;/diV&gt;
正确：&lt;div&gt;&lt;/div&gt;
</code></pre></li>
<li><p>XHTML 文档必须拥有根元素。</p>
</li>
<li><p>其他</p>
<p>  不允许使用target=”_blank”</p>
<p>  从XHTML 1.1开始全面禁止target属性，如果想要有开新窗口的功能，就必须改写为rel=”external”，并搭配JavaScript实现此效果。</p>
<pre><code>错误：&lt;a href=&quot;http://blog.mukispace.com&quot; target=&quot;_blank&quot;&gt;MUKI space&lt;/a&gt;

正确：&lt;a href=&quot;http://blog.mukispace.com&quot; rel=&quot;external&quot;&gt;MUKI space&lt;/a&gt;
</code></pre></li>
</ul>
<h1 id="如果页面使用-‘application-xhtml-xml’-会有什么问题吗？"><a href="#如果页面使用-‘application-xhtml-xml’-会有什么问题吗？" class="headerlink" title="如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗？"></a>如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗？</h1><p>一些老的浏览器不支持，实际上，任何最新的浏览器都将支持application/xhtml+xml媒体类型。大多数浏览器也接受以application/xml发送的XHTML文档。</p>
<h1 id="doctype（文档类型）的作用是什么？你知道多少种文档类型？"><a href="#doctype（文档类型）的作用是什么？你知道多少种文档类型？" class="headerlink" title="doctype（文档类型）的作用是什么？你知道多少种文档类型？"></a>doctype（文档类型）的作用是什么？你知道多少种文档类型？</h1><ul>
<li><p>此标签可告知浏览器文档使用哪种HTML或XHTML规范。该标签可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的HTML文档。</p>
</li>
<li><p>HTML 4.01规定了三种文档类型：Strict、Transitional以及Frameset。</p>
</li>
<li><p>XHTML 1.0规定了三种XML文档类型：Strict、Transitional以及Frameset。</p>
</li>
<li><p>Standards（标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>
</li>
</ul>
<h1 id="浏览器标准模式和怪异模式之间的区别是什么？"><a href="#浏览器标准模式和怪异模式之间的区别是什么？" class="headerlink" title="浏览器标准模式和怪异模式之间的区别是什么？"></a>浏览器标准模式和怪异模式之间的区别是什么？</h1><p>W3C标准推出以后，浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编 写的，如果用的标准来渲染，将导致页面显示异常。为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的IE）。 这样浏览器渲染上就产生了Quircks mode和Standars mode，两种渲染方法共存在一个浏览器上。IE盒子模型和标准W3C盒子模 型：ie的width包括：padding\border。标准的width不包括：padding\border</p>
<h1 id="使用XHTML的局限有哪些？"><a href="#使用XHTML的局限有哪些？" class="headerlink" title="使用XHTML的局限有哪些？"></a>使用XHTML的局限有哪些？</h1><p>XHTML 与HTML的区别为：</p>
<p>XHTML 元素必须被正确地嵌套。<br>XHTML 元素必须被关闭。<br>标签名必须用小写字母。<br>XHTML 文档必须拥有根元素。<br>局限：</p>
<p>所有的 XHTML 元素都必须被正确地嵌套，XHTML 必须拥有良好的结构，所有的标签必须小写，并且所有的 XHTML 元素必须被关闭。所有的 XHTML 文档必须拥有 DOCTYPE 声明，并且 html、head、title 和 body 元素必须存在。虽然代码更加的优雅，但缺少容错性，不利于快速开发。</p>
<h1 id="如果把HTML5看作做一个开放平台，那它的构建模块有哪些？"><a href="#如果把HTML5看作做一个开放平台，那它的构建模块有哪些？" class="headerlink" title="如果把HTML5看作做一个开放平台，那它的构建模块有哪些？"></a>如果把HTML5看作做一个开放平台，那它的构建模块有哪些？</h1><p><nav>,<header>,<section>,<footer>等。</footer></section></header></nav></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/多线程理论部分/" itemprop="url">
                  多线程理论部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T10:33:06+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/多线程理论部分/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/多线程理论部分/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><p>线程是用来执行任务的，线程彻底执行完任务A才能去执行任务B。为了同时执行两个任务，产生了多线程。</p>
</li>
<li><p>我打开一个视频软件，我开辟一个线程A让它执行下载任务，我开辟一个线程B，用来播放视频。我开辟两个线程后，这两个任务能同时执行，如果我开辟一个线程，只有下载任务完成，才能去执行播放任务。</p>
</li>
<li><p>线程相当于店里的服务员，一个服务员同时只能做一件事情，多顾几个服务员，就能同时做很多事情。</p>
</li>
</ul>
<h1 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li><p>进程是应用程序的执行实例,简单来说就是在操作系统中<code>运行的</code>程序。例如我在手机上只打开QQ和微信这两个软件，系统中就会有两个进程存在。</p>
</li>
<li><p>进程不能执行任务</p>
</li>
<li><p>进程在运行时创建的资源随着进程的终止而死亡。</p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>进程本身是不能执行任务的,进程想要执行任务必须的有线程,线程是进程内部的一个独立的执行单元，同时只能执行一个任务，相当于一个子程序。线程被分为两种,<code>主线程</code>(用户界面线程)和<code>子线程</code>(工作线程或称为后台线程)。我在望京(操作系统)开了一个橘子产品体验店(进程)，里面有很多工作人员，有店长帮我布置门面(主线程)，咨询人员(子线程)、销售人员(子线程)。</li>
</ul>
<ul>
<li><p>线程执行完毕就会被销毁。</p>
</li>
<li><p><strong><em>主线程(也称父线程)</em></strong>：当应用程序启动时自动创建和启动，通常用来处理用户的输入并响应各种事件和消息。主线程的终止也意味着该程序的结束。</p>
</li>
<li><p><strong><em>子线程</em></strong>：由主线程来创建,用来帮助主线程执行程序的后台处理任务。如果子线程A中又创建一个子线程B，在创建之后，这两者就是相互独立的，多个子线程之间<code>效果上</code>可以同时执行。</p>
</li>
<li><p>一个进程中可以有多个线程，并且所有线程都在该进程的虚拟地址空间中，可以使用进程的全局变量和系统资源。</p>
</li>
<li><p>线程状态：<a href="http://blog.csdn.net/peter_teng/article/details/10197785" target="_blank" rel="external">线程的五种状态</a></p>
</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li><p>目前大多数的app,都需要连接服务器，而访问服务器的速度可能快也可能很慢。如果一个app访问服务器的操作没有在子线程操作的话，在该app访问服务器的过程中，该软件是不能响应用户的操作的，只有该app访问结束以后，app才能响应用户的操作，这就造成线程阻塞，也就是我们常见的卡顿现象。一条线程在同一时间内只能执行一个任务,但是进程可以有多条线程。可以开启多条线程来执行不同的任务,从而提高程序的执行效率，避免线程阻塞。  </p>
</li>
<li><p>操作系统会根据线程的优先级(线程的优先级可以手动设置)来安排CPU的时间，优先级高的线程，优先调用的几率会更大，同级的话，看线程执行的先后。</p>
</li>
<li><p>同一时间内，CPU只能处理一条线程，只有一条线程在工作。多线程并行执行，其实就是各个线程不断切换，因为执行切换的时间很快很快，就造成了同时执行的假象，原理如下，比如A，B两个线程；</p>
<ol>
<li><p>A执行到某一时间段要切换了，可A任务没完成，系统就会把A当前执行的位置和数据以入栈的方式保存起来</p>
</li>
<li><p>然后B线程执行，B执行时间到了，它的位置状态等也会被系统保存到B的栈中。</p>
</li>
<li><p>系统自动找到A的栈，将A之前保存的数据恢复，又可以从A之前断开的状态继续执行下去，如此循环</p>
</li>
</ol>
<ul>
<li>系统每开一个线程都有比较大的开销。若线程开的过多，不仅会占用大量内存和让程序变得更加复杂，而且会加重CPU的负担，这样的软件，会使你的手机在冬天变成暖手宝。</li>
</ul>
</li>
</ul>
<h1 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h1><ul>
<li>提高程序执行效率，避免线程阻塞造成的卡顿现象。</li>
<li><p>能适当提高资源利用率(CPU,内存)。</p>
</li>
<li><p><strong>不可滥用多线程</strong>：</p>
<ol>
<li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB，可以自己设置内存大小，但必须是4的倍数），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>
<li>线程越多，CPU在调度线程上的开销就越大</li>
<li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li>
</ol>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><strong>线程与进程的关系</strong><ol>
<li>线程是CPU执行任务的基本单位，一个进程可以有多个线程，但同时只能执行一个任务。</li>
<li>进程就是运行中的软件，是动态的。</li>
<li>一个操作系统可以对应多个进程,一个进程可以有多条线程,但至少有一个线程</li>
<li>同一个进程内的线程共享进程里的资源</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>主线程</strong></p>
<ol>
<li>进程一启动就自动创建</li>
<li>显示和刷新UI界面</li>
<li>处理UI事件</li>
</ol>
</li>
<li><p><strong>子线程的作用</strong> </p>
<ol>
<li>处理耗时的操作</li>
<li>子线程不能用来刷新UI</li>
</ol>
</li>
</ul>
<h1 id="三种多线程编程技术"><a href="#三种多线程编程技术" class="headerlink" title="三种多线程编程技术"></a>三种多线程编程技术</h1><h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><ul>
<li><p>NSThread是轻量级的多线程开发，使用并不复杂，但使用NSThread需要自己管理线程的声明周期。</p>
</li>
<li><p><a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSThread/" target="_blank" rel="external">NSThread详解</a></p>
</li>
</ul>
<h2 id="Cocoa-NSOperation"><a href="#Cocoa-NSOperation" class="headerlink" title="Cocoa NSOperation"></a>Cocoa NSOperation</h2><ul>
<li><p>使用NSOperation和NSOperationQueue进行多线程开发类似于线程池，只要将一个NSOperation(实际开发中需要使用其子类NSInvocationOperation、NSBlockOperation)放到NSOperationQueue这个队列中线程就会依次启动。NSOperationQueue负责管理、执行所有的NSOperation，在这个过程中可以更加容易管理线程总数和控制线程之间的依赖关系。</p>
</li>
<li><p>NSOperation有两常用子类用于创建线程操作：NSInvocationOperation和NSBlockOperation，两种方式本质没有区别，但后者使用block形式进行代码组织，使用相对方便。</p>
</li>
<li><p><a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSOperation/" target="_blank" rel="external">NSOperation详解</a></p>
</li>
</ul>
<h2 id="GCD-Grand-Central-Dispatch"><a href="#GCD-Grand-Central-Dispatch" class="headerlink" title="GCD(Grand Central Dispatch)"></a>GCD(Grand Central Dispatch)</h2><ul>
<li><p>GCD是基于C语言开发的一套多线程开发机制，也是目前苹果官网推荐的多线程开发方法。</p>
</li>
<li><p>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程），程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</p>
</li>
<li><p>GCD是这三种多线程开发方式中抽象层次最高的，使用起来也是最为方便的，只是基于C语言开发，并不像前两种是面向对象开发，而是完全面向过程的。这种机制相比较于前面两种多线程开发方式最显著的优点就是<code>它对于多核运算更加有效，会自动利用更多的CPU内核(比如双核、四核)</code>。</p>
</li>
<li><p>GCD中也有一个类似于NSOperationQueue的队列，GCD统一管理整个队列中的任务。但是GCD中的队列分为并行队列和串行队列两类：         </p>
<blockquote>
<p>串行队列：只有一个线程，加入到队列中的操作按添加顺序依次执行。<br>并发队列：有多个线程，操作进来以后他会将这些线程安排在可用的处理器上，同时保证先进来的任务优先处理。</p>
<p>其实在GCD中还有一个特殊队列就是主队列，用来执行主线程上的操作任务。</p>
</blockquote>
</li>
</ul>
<ul>
<li><a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BGCD/" target="_blank" rel="external">GCD详解</a></li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><p>无论使用哪种方法进行多线程开发，每个线程启动后并不一定立即执行相应的操作，具体什么时候由系统调度（CPU空闲时就会执行）</p>
</li>
<li><p>更新UI应该在主线程（UI线程）中进行，并且推荐使用同步调用，常用的方法如下：</p>
<pre><code>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait 

- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL) wait;方法传递主线程[NSThread mainThread])

[[NSOperationQueue mainQueue] addOperationWithBlock:^{}];

dispatch_sync(dispatch_get_main_queue(), ^{})  
</code></pre></li>
</ul>
<ul>
<li><p>NSThread适合轻量级多线程开发，控制线程顺序比较难，同时线程总数无法控制（每次创建并不能重用之前的线程，只能创建一个新的线程）。</p>
</li>
<li><p>对于简单的多线程开发建议使用NSObject的扩展方法完成，而不必使用NSThread。</p>
</li>
<li><p>可以使用NSThread的currentThread方法取得当前线程，使用 sleepForTimeInterval:方法让当前线程休眠。</p>
</li>
<li><p>NSOperation进行多线程开发可以控制线程总数及线程依赖关系。</p>
</li>
<li><p>创建一个NSOperation不应该直接调用start方法（如果直接start则会在主线程中调用）而是应该放到NSOperationQueue中启动。</p>
</li>
<li><p>相比NSInvocationOperation推荐使用NSBlockOperation，代码简单，同时由于闭包性使它没有传参问题。</p>
</li>
<li><p>NSOperation是对GCD面向对象的ObjC封装，但是相比GCD基于C语言开发，效率却更高，建议如果任务之间有依赖关系或者想要监听任务完成状态的情况下优先选择NSOperation否则使用GCD。</p>
</li>
<li><p>在GCD中串行队列中的任务被安排到一个单一线程执行（不是主线程），可以方便地控制执行顺序；并发队列在多个线程中执行（前提是使用异步方法），顺序控制相对复杂，但是更高效。</p>
</li>
<li><p>在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并行队列并且使用异步方法执行时才能在多个线程中执行（如果是并行队列使用同步方法调用则会在主线程中执行）。</p>
</li>
<li><p>相比使用NSLock，@synchronized更加简单，推荐使用后者。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/多线程NSThread/" itemprop="url">
                  多线程NSThread
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T10:16:55+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/多线程NSThread/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/多线程NSThread/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 这篇文章主要讲NSThread的使用，相关博客如下：<br> <a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/" target="_blank" rel="external">iOS开发之多线程理论部分</a><br> <a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSOperation/" target="_blank" rel="external">NSOperation</a></p>
<h1 id="什么是NSThread"><a href="#什么是NSThread" class="headerlink" title="什么是NSThread"></a>什么是NSThread</h1><p>NSThread是轻量级的多线程开发，使用并不复杂，但使用NSThread需要自己管理线程的生命周期。</p>
<h1 id="使用NSThread开辟线程的两种方式"><a href="#使用NSThread开辟线程的两种方式" class="headerlink" title="使用NSThread开辟线程的两种方式"></a>使用NSThread开辟线程的两种方式</h1><ol>
<li>创建并手动开启线程<pre><code>NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(compete) object:nil];   
[thread start];
</code></pre></li>
<li>创建并自动开启线程<pre><code>[NSThread detachNewThreadSelector:@selector(compete) toTarget:self withObject:nil];
</code></pre></li>
</ol>
<h1 id="NSThread的常用方法"><a href="#NSThread的常用方法" class="headerlink" title="NSThread的常用方法"></a>NSThread的常用方法</h1><ol>
<li><p><strong>判断当前进程是否是多线程</strong></p>
<pre><code>BOOL isMultiThread = [NSThread isMultiThreaded];
</code></pre></li>
<li><p><strong>获取当前线程对象</strong></p>
<pre><code>//输出当前线程的信息
NSLog(@&quot;当前所在的线程=%@&quot;,[NSThread currentThread]);
</code></pre><p>控制台</p>
<blockquote>
<p>NSThread[10433:1182963] viewDidLoad 方法所在的线程=<nsthread: 0x7fca98507b10="">{number = 1, name = main}</nsthread:></p>
<p><strong>number = 1 ： 线程的编号，由系统设置，主线程的编号为1</strong><br><strong>name = main：指当前所在的线程的名字叫做main,可以自己设置，主线程的名字默认是main，其他线程如果不给他设置名字默认是nil。</strong></p>
</blockquote>
</li>
<li><p><strong>使当前线程睡眠指定的时间，单位为秒</strong></p>
<pre><code>//这句代码在哪个线程执行就让哪个线程睡眠。
[NSThread sleepForTimeInterval:2];
</code></pre><p><strong>线程一旦休眠就进入阻塞状态，就是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。</strong></p>
</li>
<li><p><strong>设置线程的优先级</strong></p>
<pre><code>//取值范围(0.0~1.0),默认为0.5,取值越大,优先级越大。
thread.threadPriority = 1.0;
</code></pre></li>
<li><p><strong>判断当前线程是否为主线程</strong></p>
<pre><code>[NSThread isMainThread];
</code></pre></li>
<li><p><strong>给线程设置名字</strong></p>
<pre><code>[thread setName:@&quot;线程名字&quot;]; 
</code></pre></li>
<li><p><strong>NSThread对象可知的三种状态</strong></p>
<pre><code>isExecuting：是否正在执行，只读
isFinished：是否已经完成，只读
isCancellled：是否已经取消，可通过[thread cancel]手动设置，线程取消意味着该线程处于准备退出状态，但不会影响线程的运行。
</code></pre></li>
<li><strong>退出当前线程</strong><pre><code>//线程退出前，必须要要，该线程之后的代码将不在执行
if (thread.isCancelled == YES) {
    [NSThread exit];
}
</code></pre></li>
</ol>
<h1 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h1><h2 id="使用多线程加载一张url图片"><a href="#使用多线程加载一张url图片" class="headerlink" title="使用多线程加载一张url图片"></a>使用多线程加载一张url图片</h2><ol>
<li>在self.view上放一个UIImageView试图</li>
<li>开辟一条子线程</li>
<li>在<code>子线程</code>中将url图片转成image对象</li>
<li>回到<code>主线程</code></li>
<li><p>在主线程中将image对象给UIImageView试图</p>
<pre><code>//
//  ViewController.m
//  NSThread
//
//  Created by GG on 16/2/18.
//  Copyright © 2016年 GG. All rights reserved.
//

#import &quot;ViewController.h&quot;

#define kUrl @&quot;http://store.storeimages.cdn-apple.com/8748/as-images.apple.com/is/image/AppleInc/aos/published/images/s/38/s38ga/rdgd/s38ga-rdgd-sel-201601?wid=848&amp;hei=848&amp;fmt=jpeg&amp;qlt=80&amp;op_sharpen=0&amp;resMode=bicub&amp;op_usm=0.5,0.5,0,0&amp;iccEmbed=0&amp;layer=comp&amp;.v=1454777389943&quot;

@interface ViewController ()
{
    UIImageView *imageView;
}

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    /*
     * 1、在self.view上放一个UIImageView试图
     */
    imageView = [[UIImageView alloc]initWithFrame:CGRectMake(50, 50, 200, 200)];
    [self.view addSubview:imageView];

    /*
     * 2、 开辟一条子线程(我这里采用创建并手动开启线程的方式)

     * target: 信息发送者

     * selector: 方法选择器选择一个方法

     * object: 如果上面选择的方法有参数，则object便是这个方法的参数

     */
    NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(downloadImage:) object:kUrl];

    //给线程起名字
    thread.name = @&quot;子线程&quot;;

    // 开启线程
    [thread start];

}

/*
 * 3、 在`子线程`中将url图片转成image对象

 *  downloadImage该方法的参数取决于创建线程时传给object的参数

 */
- (void)downloadImage:(NSString *)url{

    //将图片的url地址转化为data对象
    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:kUrl]];

    //将data对象转化为image对象
    UIImage *image = [UIImage imageWithData:data];

    /* 
     * 4. 是NSObject的一个方法，用来回到主线程

     * 方法updataUI将在主线程中执行

     * withObject:updateUI的参数

     * waitUntilDone: 设为YES，会阻塞当前子线程，去主线程执行updateUI方法，也就是更新UI，直到UI更新完毕。设为NO,意味着在主线程updateUI方法执行到一半时可能会被打断去做其他线程的工作，也就是说我主线程的UI还没有显示完就程序就跳出了主线程。
     */
    [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];

    /*

     * 查看打印结果

     * number = 1 ：线程的编号，由系统设置，主线程的编号为1

     * name = main：指当前所在的线程的名字叫做main,可以自己设置，主线程的名字默认是main，其他线程如果不给他设置名字默认是nil

     */
    NSLog(@&quot;downlaodImage方法所在的线程 = %@&quot;,[NSThread currentThread]);

            }

/*
 * 5、 在主线程中将image对象给UIImageView试图
 */

- (void)updateUI:(UIImage *)image{

    imageView.image = image;

    NSLog(@&quot;downlaodImage方法所在的线程 = %@&quot;,[NSThread currentThread]);

}

@end
</code></pre></li>
</ol>
<h2 id="使用多线程加载多张图片"><a href="#使用多线程加载多张图片" class="headerlink" title="使用多线程加载多张图片"></a>使用多线程加载多张图片</h2><ol>
<li>在self.view上放多个UIImageView试图</li>
<li>开辟多条子线程</li>
<li>在<code>子线程</code>中将url图片转成image对象</li>
<li>回到<code>主线程</code></li>
<li><p>在主线程中将image对象给UIImageView试图</p>
<pre><code>//
//  MoreImageViewViewController.m
//  NSThread
//
//  Created by GG on 16/2/22.
//  Copyright © 2016年 GG. All rights reserved.
//

#pragma mark ------------------NSThread分析详解 http://www.jianshu.com/p/b1c2bd572e81-------------

#import &quot;MoreImageViewViewController.h&quot;

#define kUrl @&quot;http://store.storeimages.cdn-apple.com/8748/as-images.apple.com/is/image/AppleInc/aos/published/images/s/38/s38ga/rdgd/s38ga-rdgd-sel-201601?wid=848&amp;hei=848&amp;fmt=jpeg&amp;qlt=80&amp;op_sharpen=0&amp;resMode=bicub&amp;op_usm=0.5,0.5,0,0&amp;iccEmbed=0&amp;layer=comp&amp;.v=1454777389943&quot;

@interface MoreImageViewViewController ()
{
    int imageIndex;

    NSMutableArray *threadArrays;

    UIImage *image;
}

@end

@implementation MoreImageViewViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    UILabel *lable = [[UILabel alloc]initWithFrame:CGRectMake(100, 300, 0, 0)];
    lable.text = @&quot;点击屏幕停止加载&quot;;
    lable.textColor = [UIColor blackColor];
    [lable sizeToFit];
    [self.view addSubview:lable];

    //创建多个UIImageView
    self.title = @&quot;多线程加载多张图片&quot;;
    self.edgesForExtendedLayout = UIRectEdgeNone;
    self.view.backgroundColor = [UIColor whiteColor];

    imageIndex = 100;

    for (int  row= 0; row&lt;3; row++) {
        for (int list = 0; list&lt;2; list++) {

            UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(10+list*200, 10+row*200, 200, 200)];

            imageView.tag = imageIndex++;

            [self.view addSubview:imageView];

        }
    }

    threadArrays = [NSMutableArray array];

    //创建多个线程
    for (int index = 0; index&lt;6; index++) {
        //此时我传的参数是线程创建的顺序
        NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(downloadImage:) object:@(index)];

        //给线程设置优先级（0-1），优先级越高，被优先调用的几率越高。
//        thread.threadPriority = index/10.0;
        thread.name = [NSString stringWithFormat:@&quot;线程%d&quot;,index];
        [thread start];

        [threadArrays addObject:thread];

    }
}

//每条线程都会走这个方法，来下载相应的图片，在这里为了方便起见，我采用了同一个url图片
- (void)downloadImage:(NSNumber *)index{

    /*

     * 通过线程的休眠来实现图片的顺序加载

        1. 第一个线程，休眠0秒，第二个线程休眠1秒...第六个线程休眠5面

        2. 正常的流程如下（基于线程同时执行的原理，多线程理论部分有介绍到）

           1. 多线程开启，并在线程中写上线程休眠代码
           2. 线程执行到休眠代码，停止执行
           3. 点击屏幕，将为完成的线程设为取消状态
           4. 休眠结束，线程进行判断是否被取消，被取消就退出

        3. 错误流程

           1. 多线程开启，并在线程中写上线程休眠代码
           2. 线程进行判断是否被取消，被取消就退出
           3. 线程执行到休眠代码，停止执行
           4. 点击屏幕，将为完成的线程设为取消状态
           5. 休眠结束，继续执行线程

     */
    [NSThread sleepForTimeInterval:[index integerValue]];

    NSThread *currentThread = [NSThread currentThread];
    //如果当前线程处于取消状态，则退出当前线程
    if (currentThread.isCancelled) {
        NSLog(@&quot;thread(%@) will be cancelled!&quot;,currentThread);
        [NSThread exit];//退出当前线程
    }

    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:kUrl]];

    image = [UIImage imageWithData:data];

    //用index找到相应线程的数据，赋给相应的图片试图。
    [self performSelectorOnMainThread:@selector(updateUI:) withObject:index waitUntilDone:YES];

    NSThread *thread = [NSThread currentThread];
    NSLog(@&quot;当前线程是 = %@&quot;,thread.name);

}

- (void)updateUI:(NSNumber *)ktest{

        UIImageView *imageView = [self.view viewWithTag:100+[ktest integerValue]];

        imageView.image = image;

}

//点击屏幕将没有完成的线程设置为取消状态
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{

    for (int i=0; i&lt;6; i++) {
        NSThread *thread= threadArrays[i];
        //判断线程是否完成，如果没有完成则设置为取消状态
        //注意设置为取消状态仅仅是改变了线程状态而言，并不能终止线程
        if (!thread.isFinished) {
            [thread cancel];

            NSLog(@&quot;============&quot;);

        }
    }

}

@end
</code></pre><p>顺序启动的线程一般不会按照启动顺序执行，这是因为线程都创建好以后，CPU会根据实际情况（网速、启动时间、优先级等）来决定执行线程的先后顺序，<strong>在这里我采用线程sleep的方式实现了线程的顺序执行。</strong></p>
</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p> 为了简化多线程开发过程，苹果官方对NSObject进行分类扩展(本质还是创建NSThread)，对于简单的多线程操作可以直接使用这些扩展方法。</p>
<pre><code>//在后台执行一个操作，本质就是重新创建一个线程执行当前方法。
- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg：

//在指定的线程上执行一个方法，需要用户创建一个线程对象。
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait：

//在主线程上执行一个方法（前面已经使用过）。
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait：
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/01/多线程GCD/" itemprop="url">
                  多线程GCD
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-01T10:00:43+08:00" content="2016-09-01">
              2016-09-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/01/多线程GCD/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/01/多线程GCD/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 这篇文章主要讲GCD的使用，相关博客如下：</p>
<p> <a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/" target="_blank" rel="external">iOS开发之多线程理论部分</a></p>
<p> <a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSOperation/" target="_blank" rel="external">NSOperation</a></p>
<p><a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSThread/" target="_blank" rel="external">NSThread</a></p>
<h1 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h1><p>全称是Grand Central Dispath，纯C语言，提供非常多强大的函数，是目前苹果官网推荐的多线程开发方法，NSOperation便是基于GCD的封装。</p>
<h1 id="GCD的优势所在"><a href="#GCD的优势所在" class="headerlink" title="GCD的优势所在"></a>GCD的优势所在</h1><ol>
<li>为多核的并行运算提出了解决方案</li>
<li>GCD会自动利用更多的CPU内核，比如双核，四核。</li>
<li>GCD会自动管理线程的生命周期(创建线程、调度任务、销毁线程)</li>
<li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li>
</ol>
<h1 id="GCD中有2个核心概念"><a href="#GCD中有2个核心概念" class="headerlink" title="GCD中有2个核心概念"></a>GCD中有2个核心概念</h1><ul>
<li><strong>任务：</strong> 执行什么操作 </li>
<li><strong>队列：</strong> 用来存放任务</li>
</ul>
<h1 id="队列可以分为两大类型"><a href="#队列可以分为两大类型" class="headerlink" title="队列可以分为两大类型"></a>队列可以分为两大类型</h1><ul>
<li>串行队列(Serial Dispatch Queue)：只有一个线程，加入到队列中的操作按添加顺序依次执行，一个任务执行完毕后，才能再执行下一个任务。</li>
<li>并发队列(Concurrent Dispatch Queue)：有多个线程，操作进来以后他会将这些线程安排在可用的处理器上，同时保证先进来的任务优先处理。</li>
<li><strong>其实在GCD中还有一个特殊队列就是主队列，用来执行主线程上的操作任务</strong></li>
</ul>
<h1 id="GCD其实可以抽象为两步"><a href="#GCD其实可以抽象为两步" class="headerlink" title="GCD其实可以抽象为两步"></a>GCD其实可以抽象为两步</h1><h2 id="找到队列"><a href="#找到队列" class="headerlink" title="找到队列"></a>找到队列</h2><pre><code>//这是找到了更新UI的主线程所在的队列
dispatch_queue_t mainQueue= dispatch_get_main_queue(); 

/*
  *  创建一个队列
  *  第一个参数：队列名字
  *  第二个参数：队列类类型
         并行队列：DISPATCH_QUEUE_CONCURRENT
         串行队列：DISPATCH_QUEUE_SERIAL
  *
  */
dispatch_queue_t serialQueue = dispatch_queue_create(&quot;mySerialQueue&quot;, DISPATCH_QUEUE_SERIAL);

/* 
  * 系统内部给我们提供有一个现成的并发队列
  * 第一个参数：线程的优先级, DISPATCH_QUEUE_PRIORITY_BACKGROUND是最低的。
  * 第二个参数：系统保留的参数，永远传0
  */
 dispatch_queue_t queue = dispatch_get_global_queue(0 , 0);
</code></pre><h2 id="在队列中确定想做的事"><a href="#在队列中确定想做的事" class="headerlink" title="在队列中确定想做的事"></a>在队列中确定想做的事</h2><pre><code>//在找到的队列中确定想要做的事情，这里我采用的同步方式执行任务，asyn是异步。 
dispatch_sync(mainQueue, ^{  

});
</code></pre><h2 id="执行队列中任务的两种方式"><a href="#执行队列中任务的两种方式" class="headerlink" title="执行队列中任务的两种方式"></a>执行队列中任务的两种方式</h2><ol>
<li><p><strong>用同步的方式执行任务(同步：synchronization</strong>)，只能在当前线程中执行任务，不具备开启新线程的能力</p>
<pre><code>/*
 *  第一个参数：该任务所在的队列
 *  第二个参数：该任务要做的事情
 */
dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);

假如我指定的队列A是串行队列，则该队列中只能有一个线程，也就是说我放在队列A中的任务，所以必须得一个一个的执行。不仅如此，在上面我们还手动选择了在队列A中用同步的方式执行任务，这也限制了，队列中的任务只能一个一个执行。

假如我指定的队列A是并行队列，则该队列中可以开辟多个线程去执行任务，虽然如此，但由于我们在上面手动选择了在队列A中用同步的方式执行线程，所以队列A中的任务也只能一个一个去执行，**不能开辟多线程同时执行**。
</code></pre></li>
<li><p><strong>用异步的方式执行任务(异步：asynchronous</strong>)，可以在新的线程中执行任务，具备开启新线程的能力。</p>
<pre><code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);

假如此时我指定的队列B是并行队列，则表明该队列中可以存在多个线程，又因为我们采用的是异步的方式执行任务，所以在这个队列的任务可以实现同时运行。

假如此时我指定的队列B是串行队列，则表明该队列中，只能有一个线程，所以尽管我采用异步的方式执行任务，但该队列中的任务还是只能一个一个的运行。
</code></pre></li>
</ol>
<h1 id="GCD创建的线程任务有四种执行方式"><a href="#GCD创建的线程任务有四种执行方式" class="headerlink" title="GCD创建的线程任务有四种执行方式"></a>GCD创建的线程任务有四种执行方式</h1><h2 id="串行队列同步执行任务"><a href="#串行队列同步执行任务" class="headerlink" title="串行队列同步执行任务"></a>串行队列同步执行任务</h2><ul>
<li><p>同步不具有开辟新线程的能力，不会开辟新的线程去执行任务，会在当前程序的主线程中执行任务。</p>
</li>
<li><p>按照串行的方式去执行任务</p>
</li>
</ul>
<pre><code>#pragma mark ------------------串行队列同步执行任务--------------

dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serialQueue&quot;, DISPATCH_QUEUE_SERIAL);

dispatch_sync(serialQueue, ^{

     NSLog(@&quot;-%@&quot;,[NSThread currentThread]);

});

dispatch_sync(serialQueue, ^{

     NSLog(@&quot;1 - %@&quot;, [NSThread currentThread]);

 });

 dispatch_sync(serialQueue, ^{

     NSLog(@&quot;2 - %@&quot;, [NSThread currentThread]);

 });

 dispatch_sync(serialQueue, ^{

      NSLog(@&quot;3 - %@&quot;, [NSThread currentThread]);

 });
</code></pre><p><strong>打印结果</strong></p>
<blockquote>
<p><strong>2016-03-01 11:44:15.071 GCD[22196:2030750] 1 = <nsthread: 0x7fade3707d80="">{number = 1, name = main}</nsthread:></strong><br><br><strong>2016-03-01 11:44:15.071 GCD[22196:2030750] 2 = <nsthread: 0x7fade3707d80="">{number = 1, name = main}</nsthread:></strong><br><br><strong>2016-03-01 11:44:15.071 GCD[22196:2030750] 3 = <nsthread: 0x7fade3707d80="">{number = 1, name = main}</nsthread:></strong><br><br><strong>2016-03-01 11:44:15.071 GCD[22196:2030750] 4 = <nsthread: 0x7fade3707d80="">{number = 1, name = main}</nsthread:></strong></p>
</blockquote>
<pre><code>**由于是同步操作，不能开辟线程，所以都是在主线程并按照顺序执行**
</code></pre><h2 id="串行队列异步执行任务"><a href="#串行队列异步执行任务" class="headerlink" title="串行队列异步执行任务"></a>串行队列异步执行任务</h2><ul>
<li><p>异步具有创建新线程的能力，会开辟新的线程去执行任务</p>
</li>
<li><p>按照串行的方式去执行任务</p>
<pre><code>#pragma mark ------------------串行队列异步执行任务------------

dispatch_queue_t serialQueue1 = dispatch_queue_create(&quot;serialQueue1&quot;, DISPATCH_QUEUE_SERIAL);

dispatch_async(serialQueue1, ^{

    NSLog(@&quot;1 = %@&quot;,[NSThread currentThread]);

});

dispatch_async(serialQueue1, ^{

     NSLog(@&quot;2 = %@&quot;,[NSThread currentThread]);

});

dispatch_async(serialQueue1, ^{

     NSLog(@&quot;3 = %@&quot;,[NSThread currentThread]);

});
</code></pre><p>  <strong>打印结果</strong></p>
<blockquote>
<p><strong>2016-03-01 11:56:04.116 GCD[22310:2039747] 1 = <nsthread: 0x7f90ba60be60="">{number = 2, name = (null)}</nsthread:></strong><br><br><strong>2016-03-01 11:56:04.117 GCD[22310:2039747] 2 = <nsthread: 0x7f90ba60be60="">{number = 2, name = (null)}</nsthread:></strong><br><br><strong>2016-03-01 11:56:04.118 GCD[22310:2039747] 3 = <nsthread: 0x7f90ba60be60="">{number = 2, name = (null)}</nsthread:></strong></p>
</blockquote>
<p> <strong>因为是异步操作，所以有个编号为2的子线程被开辟，但有因为是串行队列，所以只开辟了一个线程。最终造就了三个线程顺序执行。</strong></p>
</li>
</ul>
<h2 id="并行队列同步执行任务"><a href="#并行队列同步执行任务" class="headerlink" title="并行队列同步执行任务"></a>并行队列同步执行任务</h2><ul>
<li><p>同步不具有创建新线程的能力，不会开辟新的线程去执行任务，会在当前程序的主线程去执行任务</p>
</li>
<li><p>按照同步的方式去执行任务</p>
<pre><code>dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);

dispatch_sync(concurrentQueue, ^{

     NSLog(@&quot;1 = %@&quot;,[NSThread currentThread]);

});

dispatch_sync(concurrentQueue, ^{

     NSLog(@&quot;2 = %@&quot;,[NSThread currentThread]);

});

dispatch_sync(concurrentQueue, ^{

     NSLog(@&quot;3 = %@&quot;,[NSThread currentThread]);

});
</code></pre><p>  <strong>虽然并行队列决定了该队列中可以有多个线程，但由于是同步操作，不能开辟线程，所以还都是在主线程中按顺序执行。</strong></p>
</li>
</ul>
<h2 id="并发队列异步执行任务-常用"><a href="#并发队列异步执行任务-常用" class="headerlink" title="并发队列异步执行任务(常用)"></a>并发队列异步执行任务(常用)</h2><ul>
<li><p>异步具有创建新线程的能力，会开辟新的线程去执行任务，不会在当前程序的主线程去执行任务</p>
</li>
<li><p>按照并发的方式去执行任务</p>
<pre><code>dispatch_queue_t concurrentQueue1 = dispatch_queue_create(&quot;concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);

dispatch_async(concurrentQueue1, ^{

     NSLog(@&quot;1 = %@&quot;,[NSThread currentThread]);

});

dispatch_async(concurrentQueue1, ^{

     NSLog(@&quot;2 = %@&quot;,[NSThread currentThread]);

});

dispatch_async(concurrentQueue1, ^{

     NSLog(@&quot;3 = %@&quot;,[NSThread currentThread]);

});
</code></pre><p> <strong>打印结果</strong></p>
<blockquote>
<p><strong>2016-03-01 14:32:35.880 GCD[22990:2122064] 2 = <nsthread: 0x7f997ae09f00="">{number = 3, name = (null)}</nsthread:></strong><br><br><strong>2016-03-01 14:32:35.880 GCD[22990:2122063] 1 = <nsthread: 0x7f997af25510="">{number = 2, name = (null)}</nsthread:></strong><br><br><strong>2016-03-01 14:32:35.880 GCD[22990:2122065] 3 = <nsthread: 0x7f997ac02a10="">{number = 4, name = (null)}</nsthread:></strong></p>
</blockquote>
<p> <strong>并行队列可以里可以有多个线程，同步执行的方式又可以开辟多个线程，所以这里实现了多个线程并行执行。</strong></p>
</li>
</ul>
<h1 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h1><p>   <strong>没线程锁的情况下：</strong>  我走进购票大厅，买票的人都没有排队，我好不容易挤到窗口前，正打算掏钱买票的时候，旁边有人已经把钱给了售票员。虽然你的线程已经开始执行买票的方法，但当你去拿票时，也就是将票数减一时，CPU将你的线程给中断，开始执行其他的线程，CPU返回继续执行你的线程的时候，票已经没了。</p>
<p>  <strong>有线程锁的情况下：*</strong> 我走进购票大厅，买票的人都在排队，当我到柜台能保证我买票的关键过程，也就是报站、掏钱、拿票过程不受干扰，我采用线程锁将这个关键过程给锁起来，以保证我能顺利的买到票。</p>
<pre><code>//
//  ViewController.m
//  GCD_ Train_Ticket 
//
//  Created by GG on 16/3/2.
//  Copyright © 2016年 GG. All rights reserved.
//

#import &quot;GCDLockViewController.h&quot;

@interface  GCDLockViewController()
{
   NSLock *lock;
}

@end

@implementation GCDLockViewController

- (void)viewDidLoad {

    [super viewDidLoad];

    self.view.backgroundColor = [UIColor whiteColor];
    self.title = @&quot;线程锁&quot;;
    self.edgesForExtendedLayout = UIRectEdgeNone;

    lock = [NSLock new];

    dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);
    __block int ticketNum = 10;

    for (int index = 0; index&lt;15; index++) {

          dispatch_async(concurrentQueue, ^{

              #pragma mark *****************不用线程锁，下面的购票的关键      过程就可能会被打断，无法确认剩余的票数***********************
              //            if (ticketNum&gt;0) {
              //
              //                ticketNum--;
              //
              //                NSLog(@&quot;还剩%d张票&quot;,ticketNum);
              //            }

             #pragma  mark *****************NSLock实现线程锁，能保证票数是按照预知的一张一张减少，对比不用线程所的输出可知*******************

             //            //上锁，lock是一个NSLock的对象
             //            [lock lock];
             //
             //            if (ticketNum&gt;0) {
             //
             //                ticketNum--;                   
             //
             //                NSLog(@&quot;还剩%d张票&quot;,ticketNum);
             //            }
             //            //解锁
             //            [lock unlock];

             #pragma mark *****************synchronized方式实现线程锁，能保证票数是按照预知的一张一张减少**********

             //保证此时没有其它线程对self里的对象进行修改
             @synchronized(self){

                if (ticketNum&gt;0) {

                  ticketNum--;

                  NSLog(@&quot;还剩%d张票&quot;,ticketNum);

                }

             }

         });


     }

 }

@end
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/01/多线程NSOperation/" itemprop="url">
                  多线程NSOperation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-01T09:10:35+08:00" content="2016-09-01">
              2016-09-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/01/多线程NSOperation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/01/多线程NSOperation/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章主要讲NSOperation的使用，相关博客如下：</p>
<p><a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/" target="_blank" rel="external">iOS开发之多线程理论部分</a></p>
<p><a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BGCD/" target="_blank" rel="external">GCD</a></p>
<p><a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSThread/" target="_blank" rel="external">NSThread</a></p>
<h1 id="什么是NSOperation"><a href="#什么是NSOperation" class="headerlink" title="什么是NSOperation"></a>什么是NSOperation</h1><p>使用NSOperation和NSOperationQueue进行多线程开发类似于线程池，只要将一个<strong>NSOperation(实际开发中需要使用其子类NSInvocationOperation、NSBlockOperation)放到NSOperationQueue这个队列中线程就会依次启动。</strong>NSOperationQueue负责管理、执行所有的NSOperation，在这个过程中<code>可以更加容易管理线程总数和控制线程之间的依赖关系。</code></p>
<p><strong>NSOperation</strong>  利用他来创建线程操作，线程操作只有放在线程队列中才会在子线程中执行。</p>
<p><strong>NSOperationQueue</strong>: 线程队列分两种类型。</p>
<ul>
<li><p>主队列</p>
<ul>
<li>[NSOperationQueue mainQueue]</li>
<li>凡是添加到主队列中的任务(NSOperation),都会放到主线程中执行。</li>
</ul>
</li>
<li><p>非主队列</p>
<ul>
<li>[[NSOperationQueue alloc]init]</li>
<li>添加到这种队列中的任务，都会放到子线程中执行。</li>
</ul>
</li>
</ul>
<p>NSOperation常用子类用于创建线程操作：NSInvocationOperation和NSBlockOperation，两种方式本质没有区别，但后者使用block形式进行代码组织，使用相对方便。也可以用自定义的继承于NSOperation的类来创建线程操作。</p>
<h1 id="NSOperation的三种用法"><a href="#NSOperation的三种用法" class="headerlink" title="NSOperation的三种用法"></a>NSOperation的三种用法</h1><p>配合使用NSOperation和NSOperationQueue实现多线程编程，一共有三种方式，但其实这三种方式都是采用NSOperation的子类与NSOperationQueue搭配实现多线程开发。这三个子类分别是NSInvocationOperation、NSBlockOperation和自定义继承于NSOperation的类，前两者是系统提供的子类。</p>
<h2 id="NSInvocationOperation与NSOperationQueue搭配"><a href="#NSInvocationOperation与NSOperationQueue搭配" class="headerlink" title="NSInvocationOperation与NSOperationQueue搭配"></a>NSInvocationOperation与NSOperationQueue搭配</h2><ol>
<li><p>创建一个线程操作，并实现方法选择器选择的方法</p>
<pre><code>//创建一个线程操作
NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(invocationOperation:) object:kurl];

//让线程操作开始执行。但是如果这样做的话这个操作将会在主线程中执行，只有将这个操作放进队列，才会开辟一个子线程让这个操作在子线程中执行。
//[invocationOperation start];
</code></pre></li>
<li><p>创建一个线程队列</p>
<pre><code>NSOperationQueue *operationQueue = [NSOperationQueue new];
</code></pre></li>
<li><p>将创建好的线程操作放在线程队列中</p>
<pre><code>//只有放在线程队列中的线程操作才会在子线程中执行。线程队列负责管理、执行所有的NSOperation
[operationQueue addOperation:invocationOperation];
</code></pre></li>
<li><p>在创建线程操作时选择的方法内更新UI</p>
<pre><code>- (void)invocationOperation:(NSString *)url{

      //虽然没有采用NSThread创建线程，但仍可以使用[NSThread currentThread]来获取当前的线程。
      NSLog(@&quot;invocationOperation方法所在的线程%@&quot;,[NSThread currentThread]);
      NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:kurl]];
      //在子线程中回到主线程更新UI
      [[NSOperationQueue mainQueue] addOperationWithBlock:^{

          imageView.image = [UIImage imageWithData:data];

     }];

}
</code></pre><p>   到目前为止是不是感觉跟NSThread挺相似的，接下来简单分析一下两者的区别。</p>
<pre><code> 1. NSThread需要启动，也就是说需要费心管理声明周期，而采用Operation只需将线程操作放到线程队列中即可，线程队列负责管理、执行所有的NSOperation。

 2. 管理线程的最大并发数，也就是同时执行的任务数。

      //默认是-1，不能设为0，如果设置为0就不执行任务。
      operationQueue.maxConcurrentOperationCount = 1;

 3. 控制线程之间的依赖关系，NSOperation之间可以设置依赖来保证执行顺序,比如一定要让操作1执行完后，才能执行操作2。线程之间不能相互依赖，不如A依赖于B，B有依赖于A。  

     //操作1依赖于操作2
     [invocationOperation1 addDependency:invocationOperation2];

 4. 队列的取消、暂停、恢复

      只要设置队列的suspended为YES, 那么就会暂停队列中其它任务的执行，也就是说不会再继续执行没有执行到得任务

      self.queue.suspended = YES;

      注意1: 设置为暂停之后, 不会立即暂停,会继续执行当前正在执行的任务, 直到当前任务执行完毕, 就不会执行下一个任务了,也就是说, 暂停其实是暂停下一个任务, 而不能暂停当前任务

      注意2: 暂停是可以恢复的,只要设置队列的suspended为NO, 那么就会恢复队列中其它任务的执行

5. 取消队列中所有的任务的执行

    [self.queue cancelAllOperations];

    取消和暂停一样, 是取消后面的任务, 不能取消当前正在执行的任务，取消是不可以恢复的
</code></pre></li>
</ol>
<h2 id="NSBlockOperation与NSOperationQueue搭配，"><a href="#NSBlockOperation与NSOperationQueue搭配，" class="headerlink" title="NSBlockOperation与NSOperationQueue搭配，"></a>NSBlockOperation与NSOperationQueue搭配，</h2><p>   其实方式一和方式二没有什么本质区别。主要是后者使用block形式进行代码组织，使用相对方便。</p>
<pre><code> - (void)viewDidLoad{

     [super viewDidLoad];

     imageView = [[UIImageView alloc]initWithFrame:CGRectMake(50, 50, 200, 200)];

     [self.view addSubview:imageView];

     //1. 创建线程操作
     NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{

        NSLog(@&quot;blockOperation线程操作所在的线程%@&quot;,[NSThread currentThread]);

        NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:kurl]];

        [[NSOperationQueue mainQueue] addOperationWithBlock:^{

              NSLog(@&quot;更新UI所在的线程%@&quot;,[NSThread currentThread]);

              imageView.image = [UIImage imageWithData:data];

         }];

     }];

     //2. 创建线程队列
     NSOperationQueue *operationQueue = [NSOperationQueue new];

     //3. 将线程操作放到线程队列中
     [operationQueue addOperation:blockOperation];

}
</code></pre><p>   简化以上操作</p>
<pre><code>//1. 创建一个线程队列
NSOperationQueue *operationQueue = [NSOperationQueue new];

//2. 直接利用线程队列的addOperationWithBlock添加线程操作。
[operationQueue addOperationWithBlock:^{

    NSLog(@&quot;更新UI所在的线程%@&quot;,[NSThread currentThread]);

}];
</code></pre><h2 id="继承于NSOperation的子类与NSOperationQueue的搭配"><a href="#继承于NSOperation的子类与NSOperationQueue的搭配" class="headerlink" title="继承于NSOperation的子类与NSOperationQueue的搭配"></a>继承于NSOperation的子类与NSOperationQueue的搭配</h2><ol>
<li><p>创建一个继承于NSOperation的类，并在.m文件中重写main方法，main方法便是该线程要执行的操作。<strong>注意，如果是同步操作，该方法能够自动访问到主线程的自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池，需要再main中再新建一个自动释放池，来帮助管理内存。</strong></p>
</li>
<li><p>创建线程队列，并把线程操作放在线程队列中。</p>
</li>
</ol>
<pre><code>  //
  //  CoustomOperation.h
  //  NSOperation
  //
  //  Created by GG on 16/2/26.
  //  Copyright © 2016年 GG. All rights reserved.
  //

  #import &lt;Foundation/Foundation.h&gt;
  #import &lt;UIKit/UIKit.h&gt;
  @interface CoustomOperation : NSOperation

  //接收传进来的图片对象
  @property (nonatomic,retain) UIImageView *imageView;

  //在该该类对象初始化时，将图片试图对象传到类中。
  - (instancetype)initWithImageView:(UIImageView *)imageView;

  @end


----

  //
  //  CoustomOperation.m
  //  NSOperation
  //
  //  Created by GG on 16/2/26.
  //  Copyright © 2016年 GG. All rights reserved.
  //

  #import &quot;CoustomOperation.h&quot;

  #define kurl @&quot;http://store.storeimages.cdn-apple.com/8748/as-images.apple.com/is/image/AppleInc/aos/published/images/s/38/s38ga/rdgd/s38ga-rdgd-sel-201601?wid=848&amp;hei=848&amp;fmt=jpeg&amp;qlt=80&amp;op_sharpen=0&amp;resMode=bicub&amp;op_usm=0.5,0.5,0,0&amp;iccEmbed=0&amp;layer=comp&amp;.v=1454777389943&quot;

  @implementation CoustomOperation

  - (instancetype)initWithImageView:(UIImageView *)imageView
  {
      self = [super init];
      if (self) {

         self.imageView = imageView;
      }
      return self;
  }

  - (void)main{

        //新建一个自动释放池，因为如果是同步操作，该方法能够自动访问到主线程的自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池。
        @autoreleasepool {

             NSLog(@&quot;获取图片所在的线程%@&quot;,[NSThread currentThread]);
             NSData *imageData = [NSData dataWithContentsOfURL:[NSURL URLWithString:kurl]];

             [[NSOperationQueue mainQueue] addOperationWithBlock:^{

                 NSLog(@&quot;更新UI所在的线程%@&quot;,[NSThread currentThread]);

                 self.imageView.image = [UIImage imageWithData:imageData];

             }];

        }            
   }

   @end  
</code></pre><hr>
<pre><code>ViewController.m
- (void)viewDidLoad{

    [super viewDidLoad];

    imageView = [[UIImageView alloc]initWithFrame:CGRectMake(50, 50, 200, 200)];

    [self.view addSubview:imageView];

    CoustomOperation *coustomOperation = [[CoustomOperation alloc] initWithImageView:(UIImageView *)imageView];

    NSOperationQueue *operationQueue = [NSOperationQueue new];

    [operationQueue addOperation:coustomOperation];

}
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  这三种方式中，感觉方式一是最麻烦的，方式二相对而已简洁不少，而方式三更适合于封装某一个线程操作。</p>
<ol>
<li>是用NSOperation加载一张图片</li>
<li>使用NSOperation加载多张图片，并能使线程暂停，恢复，终止,</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/31/定位-编码与反编码/" itemprop="url">
                  定位/编码与反编码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-31T08:28:39+08:00" content="2016-08-31">
              2016-08-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/31/定位-编码与反编码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/31/定位-编码与反编码/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  学习地图，我们必须要接触两个框架：</p>
<ol>
<li><p>Core Location，主要包含定位、地理编码、反编码功能</p>
</li>
<li><p>MapKit，利用他可以对地图进行精准的控制，如需了解请移步<a href="https://wangliguang.github.io/2016/08/30/iOS%E5%9C%B0%E5%9B%BE-%E5%9C%B0%E5%9B%BE%E6%98%BE%E7%A4%BA:%E5%A4%A7%E5%A4%B4%E9%92%88/" target="_blank" rel="external">iOS开发之地图-地图显示/大头针</a></p>
<p>本文我们主要介绍的是使用Core Location来实现定位、地理编码(包括反编码)功能。</p>
</li>
</ol>
<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p> 定位是一个很常用的功能，打开地图软件后如果用户允许软件定位的话，软件便会自动锁定到手机所在位置，并且地图上的位置会随着手机的移动而移动。定位使用到的类是Core Location框架中的CLLocationManager类。</p>
<h2 id="CLLocationManager中常用的方法"><a href="#CLLocationManager中常用的方法" class="headerlink" title="CLLocationManager中常用的方法"></a>CLLocationManager中常用的方法</h2><pre><code>  *******类方法**********
  //当前系统是否打开定位服务,在设置-&gt;隐私里控制。这是能够控制手机上所有App的定位授权     
  +(BOOL)locationServicesEnabled;

  /* 定位服务授权状态，返回枚举类型，下面是类型解释

   * kCLAuthorizationStatusNotDetermined： 用户尚未做出决定是否启用定位服务

   * kCLAuthorizationStatusRestricted： 没有获得用户授权使用定位服务,可能用户没有自己禁止访问授权

   * kCLAuthorizationStatusDenied ：用户已经明确禁止应用使用定位服务或者当前系统定位服务处于关闭状态

   * kCLAuthorizationStatusAuthorizedAlways： 应用获得授权可以一直使用定位服务，即使应用不在使用状态

   * kCLAuthorizationStatusAuthorizedWhenInUse： 使用此应用过程中允许访问定位服务

   */ 
   +(CLAuthorizationStatus)authorizationStatus;

---

   *******对象方法**********
   //开始定位追踪，开始定位后将按照用户设置的更新频率执行-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations;方法反馈定位信息
   startUpdatingLocation

   //停止定位追踪
   stopUpdatingLocation

   //请求获得应用使用时的定位服务授权，注意使用此方法前在要在info.plist中配置NSLocationWhenInUseUsageDescription
   requestWhenInUseAuthorization

   //请求获得应用一直使用定位服务授权，注意使用此方法前要在info.plist中配置NSLocationAlwaysUsageDescription
   requestAlwaysAuthorization

   //开始导航方向追踪
   startUpdatingHeading

   //停止导航方向追踪
   stopUpdatingHeading

   //开始对某个区域进行定位追踪，开始对某个区域进行定位后。如果用户进入或者走出某个区域会调用相应的代理方法反馈相关信息

   //停止对某区域追踪
   stopMonitoringForRegion:

 ---

   *******代理方法*******
   //位置发生改变后执行（第一次定位到某个位置之后也会执行）
   -(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations;

   //导航方向发生变化后执行
   - (void)locationManager:(CLLocationManager *)manager didUpdateHeading:(CLHeading *)newHeading;

   // 进入某个区域之后执行
   - (void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region;

    //走出某个区域之后执行
     - (void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region
</code></pre><h2 id="实现定位的步骤"><a href="#实现定位的步骤" class="headerlink" title="实现定位的步骤"></a>实现定位的步骤</h2><pre><code>1. 导入框架         
       #import &lt;CoreLocation/CoreLocation.h&gt;

2. **声明全局**的定位管理器，因为定位是持续性动作，如果声明为局部变量，还没有退出这个界面，定位管理器对象就会被释放，从而造成定位失败，而如果声明为全局变量，只有该界面对象被释放，这个定位管理器才会被释放。另外如果是该定位管理器是局部变量，第一次打开的授权提示框会出现闪退现象。
       CLLocationManager *_locationManager;

3. 实例化定位管理器
       _locationManager = [[CLLocationManager alloc]init];

4. 判断当前系统是否打开定位服务,在设置-&gt;隐私里。这是能够控制手机上所有App的定位授权
        if ([CLLocationManager locationServicesEnabled] == NO) {

              //判断是否可以打开设置界面
              if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]]) {

                    //跳转到设置页面
                    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];

              };

              return;
        }

5. **定位授权，如果不授权就无法定位**

       //使用中授权
       [_locationManager requestWhenInUseAuthorization]; 

       //永久授权，这种情况下，有时你应用没打开也会定位,如果苹果手机上有地图软件的话，你没有打开该软件，系统有时也会突然给你个提示框说某应用一直在使用定位功能，是否关闭。
       // [_locationManager requestAlwaysAuthorization];  
6. **在info.plist插入两个字段，不添加就无法定位**

       //都string类型，和第五步的两种授权，写入的内容会出现在定位授权提示框上
       NSLocationWhenInUseUsageDescription//使用中授权描述
       NSLocationAlwaysUsageDescription//永久授权描述

7.  挂上代理
        _locationManager.delegate = self;

8. 使用后台定位
        _locationManager.allowsBackgroundLocationUpdates = YES;

9. 设置定位信息

       //设置定位精度
       _locationManager.desiredAccuracy = 10;

       //设置定位频率定位频率和定位精度并不应当越精确越好，需要视实际情况而定，因为越精确越耗性能，也就越费电。
       CLLocationDistance distance=1.0;//1米定位一次
       _locationManager.distanceFilter = distance;

10. 开始追踪,**如果不需要定位了记得停止定位，要不然会有很大的耗电量**
        [_locationManager startUpdatingLocation];

11. 实现代理方法,**以后我们会常看到一个CLLocation类，它用于表示位置信息，包含地理坐标、海拔等信息，包含在CoreLoaction框架中。**
         #pragma  mark delegate 
        //定位成功，因为定位时刻都在进行，所以苹果将瞬时获得的多个位置信息放在一个数组中，我们只需获取到数组中的最后一个。
        - (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations{

        /*
         * 如果不需要定位了记得停止定位，要不然会有很大的耗电量
         */
        CLLocation *curLoc = locations.lastObject;

        /*
          * 当前位置的经纬度
          *
              typedef struct {
                 CLLocationDegrees latitude;
                 CLLocationDegrees longitude;
              } CLLocationCoordinate2D;
          *
          */
          CLLocationCoordinate2D coordinate = curLoc.coordinate;
          NSLog(@&quot;经度:%f 纬度:%f&quot;,coordinate.longitude,coordinate.latitude);

          //海拔高度
          NSLog(@&quot;海拔高度:%f&quot;,curLoc.altitude);

           //位置的精度，位置精度通过一个圆表示，实际位置可能位于这个圆内的任何地方。这个圆是由coordinate(坐标)和horizontalAccuracy(半径)共同决定的，horizontalAccuracy的值越大，那么定义的圆就越大，因此位置精度就越低。如果horizontalAccuracy的值为负，则表明coordinate的值无效。
          NSLog(@&quot;位置的精度:%f&quot;,curLoc.horizontalAccuracy);

          //海拔高度的精度。为正值表示海拔高度的误差为对应的米数；为负表示altitude(海拔高度)的值无效。
          NSLog(@&quot;海拔的精度:%f&quot;,curLoc.verticalAccuracy);

          //speed — 速度。该属性是通过比较当前位置和前一个位置，并比较它们之间的时间差异和距离计算得到的。鉴于Core Location更新的频率，speed属性的值不是非常精确，除非移动速度变化很小。
          NSLog(@&quot;行驶速度：%f&quot;,curLoc.speed);

          //当前定位的日期
          NSLog(@&quot;定位日期%@&quot;,curLoc.timestamp);

          //得到两个位置之间的距离，通过不断累加，来获取总距离
          //    [curLoc distanceFromLocation:nil];

          //得到两次更新的时间之间的间隔，通过累加来获取行驶总时间
          //    [curLoc.timestamp timeIntervalSinceDate:lastLoc.timestamp];

          //floor 楼层的高度 -&gt; level 几层
          NSLog(@&quot;当前楼层%ld层&quot;,curLoc.floor.level);

        } 

         //定位失败
        - (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error{

           NSLog(@&quot;定位失败%@&quot;,error);

        }
</code></pre><h2 id="总结：如果定位失败，首先检查一下几点："><a href="#总结：如果定位失败，首先检查一下几点：" class="headerlink" title="总结：如果定位失败，首先检查一下几点："></a>总结：如果定位失败，首先检查一下几点：</h2><ol>
<li><p>定位管理器是否为全局变量</p>
</li>
<li><p>info.plist中的字段是否配置</p>
</li>
<li><p>在代码中是否做授权处理</p>
</li>
<li><p><strong> 如果用模拟器的话，可能是因为没有给模拟器设置经纬度，点击模拟器模拟器 -&gt; 菜单栏Debug -&gt; Location -&gt; CustomLocation -&gt; 设置经纬度，如果想要让模拟器自动定位选择Location —&gt; Apple。</strong></p>
</li>
</ol>
<h1 id="编码反编码"><a href="#编码反编码" class="headerlink" title="编码反编码"></a>编码反编码</h1><p>   编码与反编码用到的类都是CLGeocoder</p>
<pre><code>1. 编码：将地址转化为经纬度
2. 反编码：将经纬度转化为地址
</code></pre><p>   <strong>之后我们会接触到一个CLPlacemark类，他是定位框架中地标类，封装了详细的地理信息</strong></p>
<pre><code>  //编码
  - (void)geocodeAddressString:(NSString *)addressString completionHandler:(CLGeocodeCompletionHandler)completionHandler;

//反编码
- (void)reverseGeocodeLocation:(CLLocation *)location completionHandler:(CLGeocodeCompletionHandler)completionHandler;
</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>//
//  CLGeocoderViewController.m
//  Location
//
//  Created by GG on 16/3/9.
//  Copyright © 2016年 GG. All rights reserved.
//

#import &quot;CLGeocoderViewController.h&quot;
#import &lt;CoreLocation/CoreLocation.h&gt;
@interface CLGeocoderViewController ()
{
    CLGeocoder *_geocoder;
}
@end

@implementation CLGeocoderViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    _geocoder=[[CLGeocoder alloc]init];
    [self getCoordinateByAddress:@&quot;北京&quot;];
    [self getAddressByLatitude:39.54 longitude:116.28];
}

#pragma mark 根据地名确定地理坐标
-(void)getCoordinateByAddress:(NSString *)address{
    //地理编码
    [_geocoder geocodeAddressString:address completionHandler:^(NSArray *placemarks, NSError *error) {
        //取得第一个地标，地标中存储了详细的地址信息，注意：一个地名可能搜索出多个地址
        CLPlacemark *placemark=[placemarks firstObject];

        CLLocation *location=placemark.location;//位置
        CLRegion *region=placemark.region;//区域
        NSDictionary *addressDic= placemark.addressDictionary;//详细地址信息字典,包含以下部分信息
        //        NSString *name=placemark.name;//地名
        //        NSString *thoroughfare=placemark.thoroughfare;//街道
        //        NSString *subThoroughfare=placemark.subThoroughfare; //街道相关信息，例如门牌等
        //        NSString *locality=placemark.locality; // 城市
        //        NSString *subLocality=placemark.subLocality; // 城市相关信息，例如标志性建筑
        //        NSString *administrativeArea=placemark.administrativeArea; // 州
        //        NSString *subAdministrativeArea=placemark.subAdministrativeArea; //其他行政区域信息
        //        NSString *postalCode=placemark.postalCode; //邮编
        //        NSString *ISOcountryCode=placemark.ISOcountryCode; //国家编码
        //        NSString *country=placemark.country; //国家
        //        NSString *inlandWater=placemark.inlandWater; //水源、湖泊
        //        NSString *ocean=placemark.ocean; // 海洋
        //        NSArray *areasOfInterest=placemark.areasOfInterest; //关联的或利益相关的地标
        NSLog(@&quot;位置:%@,区域:%@,详细信息:%@&quot;,location,region,addressDic);
    }];
}

#pragma mark 根据坐标取得地名
-(void)getAddressByLatitude:(CLLocationDegrees)latitude longitude:(CLLocationDegrees)longitude{
    //反地理编码
    CLLocation *location=[[CLLocation alloc]initWithLatitude:latitude longitude:longitude];
    [_geocoder reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) {
        CLPlacemark *placemark=[placemarks firstObject];
        NSLog(@&quot;详细信息:%@&quot;,placemark.addressDictionary);
    }];
}

@end
</code></pre><h2 id="总结我们目前在地图上接触到的几个类："><a href="#总结我们目前在地图上接触到的几个类：" class="headerlink" title="总结我们目前在地图上接触到的几个类："></a>总结我们目前在地图上接触到的几个类：</h2><pre><code>1.  CLLocationManager：定位管理器,用来设置管理定位，设置定位的精度、定位频率、后台运行等。

2. CLGeocoder：主要用来编码与反编码。

3. CLLocation：用于表示位置信息，包含地理坐标、海拔等信息，包含在CoreLoaction框架中。

4. CLPlacemark：定位框架中地标类，封装了详细的地理信息。

5. CLLocationCoordinate2D：他是一个结构体，用来表示经纬度。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/30/地图显示:大头针/" itemprop="url">
                  地图显示/大头针
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-30T22:27:07+08:00" content="2016-08-30">
              2016-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/30/地图显示:大头针/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/30/地图显示:大头针/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   学习地图，我们必须要接触两个框架：</p>
<ol>
<li><p>Core Location，主要包含定位、地理编码、反编码功能，如需了解请移步<a href="https://wangliguang.github.io/2016/08/31/iOS%E5%9C%B0%E5%9B%BE-%E5%AE%9A%E4%BD%8D-%E7%BC%96%E7%A0%81%E4%B8%8E%E5%8F%8D%E7%BC%96%E7%A0%81/" target="_blank" rel="external">iOS开发之地图-定位/编码与反编码</a></p>
</li>
<li><p>MapKit，利用他可以对地图进行精准的控制,比如，放置大头针、地图类型切换，导航等等。</p>
<p>本文我们主要介绍的是使用MapKit框架对地图试图进行精准的控制。</p>
</li>
</ol>
<h1 id="MKMapView"><a href="#MKMapView" class="headerlink" title="MKMapView"></a>MKMapView</h1><p>   <strong>MKMapView是地图展示控件。</strong></p>
<h2 id="MKMapView的常用属性"><a href="#MKMapView的常用属性" class="headerlink" title="MKMapView的常用属性"></a>MKMapView的常用属性</h2><pre><code>//跟踪类型，是一个枚举：MKUserTrackingModeNone :不进行用户位置跟踪；MKUserTrackingModeFollow :跟踪用户位置；MKUserTrackingModeFollowWithHeading :跟踪用户位置并且跟踪用户前进方向；
userTrackingMode    

//地图类型，是一个枚举：MKMapTypeStandard :标准地图，一般情况下使用此地图即可满足；MKMapTypeSatellite ：卫星地图；MKMapTypeHybrid ：混合地图，加载最慢比较消耗资源；
mapType

//用户位置，只读属性
userLocation

//当前地图中的所有大头针，只读属性
annotations

// 是否可以缩放 
zoomEnabled = NO; 

// 是否可以滚动 
scrollEnabled = NO; 

// 是否可以旋转  
rotateEnabled = NO; 

// 是否显示3D  
pitchEnabled = NO;

// 是否显示指南针
showsCompass = YES;

// 是否显示比例尺
showsScale = YES;

// 是否显示交通
showsTraffic = YES;

// 是否显示建筑物
showsBuildings = YES;
</code></pre><h2 id="MKMapView的常用方法"><a href="#MKMapView的常用方法" class="headerlink" title="MKMapView的常用方法"></a>MKMapView的常用方法</h2><pre><code>  ******对象方法*****
  //添加大头针，对应的有添加大头针数组
  - (void)addAnnotation:(id &lt;MKAnnotation&gt;)annotation;

  //删除大头针，对应的有删除大头针数组
  - (void)removeAnnotation:(id &lt;MKAnnotation&gt;)annotation;

  //设置地图显示区域，用于控制当前屏幕显示地图范围
  - (void)setRegion:(MKCoordinateRegion)region animated:(BOOL)animated;

  //设置地图中心点位置
  - (void)setCenterCoordinate:(CLLocationCoordinate2D)coordinate animated:(BOOL)animated;

  //将地理坐标（经纬度）转化为数学坐标（UIKit坐标）
  - (CGPoint)convertCoordinate:(CLLocationCoordinate2D)coordinate toPointToView:(UIView *)view;

  //将数学坐标转换为地理坐标
  - (CLLocationCoordinate2D)convertPoint:(CGPoint)point toCoordinateFromView:(UIView *)view;

  //从缓存池中取出大头针，类似于UITableView中取出UITableViewCell，为了进行性能优化而设计
  - (MKAnnotationView *)dequeueReusableAnnotationViewWithIdentifier:(NSString *)identifier;

  //选中指定的大头针
  - (void)selectAnnotation:(id &lt;MKAnnotation&gt;)annotation animated:(BOOL)animated;

  //取消选中指定的大头针
  - (void)deselectAnnotation:(id &lt;MKAnnotation&gt;)annotation animated:(BOOL)animated;

---

  ******代理方法*****

 //用户位置发生改变时触发（第一次定位到用户位置也会触发该方法）
 - (void)mapView:(MKMapView *)mapView didUpdateUserLocation:(MKUserLocation *)userLocation ;

 //显示区域发生改变后触发
 - (void)mapView:(MKMapView *)mapView didUpdateUserLocation:(MKUserLocation *)userLocation ;

 //地图加载完成后触发
 - (void)mapViewDidFinishLoadingMap:(MKMapView *)mapView;

 //显示大头针时触发，返回大头针视图，通常自定义大头针可以通过此方法进行
 - (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id &lt;MKAnnotation&gt;)annotation;

 //点击选中某个大头针时触发
 - (void)mapView:(MKMapView *)mapView didSelectAnnotationView:(MKAnnotationView *)view

 //取消选中大头针时触发
 - (void)mapView:(MKMapView *)mapView didDeselectAnnotationView:(MKAnnotationView *)view

 //渲染地图覆盖物时触发
 - (MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id &lt;MKOverlay&gt;)overlay
</code></pre><h2 id="MKMapView显示当前位置的步骤"><a href="#MKMapView显示当前位置的步骤" class="headerlink" title="MKMapView显示当前位置的步骤"></a>MKMapView显示当前位置的步骤</h2><pre><code>1. 导入MapKit框架

       #import &lt;MapKit/MapKit.h&gt;

2. 使用定位管理器CLLocationManager做定位授权
       _locationManager = [[CLLocationManager alloc]init];
       [_locationManager requestAlwaysAuthorization];//始终授权
       [_locationManager requestWhenInUseAuthorization];// 使用时授权
2. 创建MKMapView地图试图,并添加到他的父试图上面，我的_mapView已设为全局变量

       _mapView = [[MKMapView alloc]initWithFrame:self.view.frame];
       [self.view addSubview:_mapView];

3. 设置相应属性
       //跟踪类型，是一个枚举：MKUserTrackingModeNone :不进行用户位置跟踪；MKUserTrackingModeFollow :跟踪用户位置；MKUserTrackingModeFollowWithHeading :跟踪用户位置并且跟踪用户前进方向；userTrackingMode
       _mapView.userTrackingMode = MKUserTrackingModeFollowWithHeading;

       //地图类型，是一个枚举：MKMapTypeStandard :标准地图，一般情况下使用此地图即可满足；MKMapTypeSatellite ：卫星地图；MKMapTypeHybrid ：混合地图，加载最慢比较消耗资源；mapType
       _mapView.mapType = MKMapTypeStandard;

       // 显示标尺
       _mapView.showsScale = YES;

       // 显示交通状态
       _mapView.showsTraffic = YES;

       //    显示罗盘
       _mapView.showsCompass = YES;
5. 挂上代理

       _mapView.delegate = self;

6. 显示用户位置

       _mapView.showsUserLocation = YES;

7. 实现代理方法，不止有这些还有很多其他的代理方法。

       - (void)mapView:(MKMapView *)mapView didUpdateUserLocation:(MKUserLocation *)userLocation{
              //让用户定位到当前位置       
               _mapView.centerCoordinate = userLocation.coordinate;

                [_mapView setRegion:MKCoordinateRegionMake(userLocation.coordinate, MKCoordinateSpanMake(0.1, 0.1))];

             /*
               * 设置地图上所显示的区域

               *  CLLocationCoordinate2D 设置该区域的中心点

               * MKCoordinateSpan 设置该区域的经纬度跨度

               * 例如：中国经纬度

               经度范围：73.33E 至 135.05E
               纬度范围：2.51N  至 53.33N

               为了简便，我们去掉小数

               中国中心点的纬度是（3 + 53）/ 2 = 北纬28度

               中国中心点的经度是（73 + 135）/ 2 = 东经104度

               中国纬度跨度是53 - 3 = 50度

               中国经度跨度是135 - 73 = 62度

               */
              //    MKCoordinateSpan span = MKCoordinateSpanMake(50, 62);//跨度越大，地图所显示的区域越大
              //    CLLocationCoordinate2D coordinate = CLLocationCoordinate2DMake(28, 104);
              //    MKCoordinateRegion regoin = MKCoordinateRegionMake(coordinate, span);
              //    [_mapView setRegion:regoin animated:YES];

       }

       - (void)mapView:(MKMapView *)mapView didFailToLocateUserWithError:(NSError *)error{

           NSLog(@&quot;定位失败%@&quot;,error);
       }
</code></pre><p>  总结，如果无法显示自己的位置，检查以下几点：</p>
<pre><code>0. 是否将定位管理器设为全局变量

1. 是否在项目中进行定位授权，是否在Info.plist中配置

2. 是否将showsUserLocation设为YES。

3. 是否配置模拟器 点击模拟器 -&gt; 菜单栏Dubug -&gt; Location -&gt; Apple来使模拟器定位，然后使用Custom Location配置模拟器的经纬度。
</code></pre><p>   最终效果如下：</p>
<p>   <img src="http://upload-images.jianshu.io/upload_images/1338564-0a79924b88d1bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中间的原点就是用户所在的位置"></p>
<h1 id="自定义用户位置的大头针"><a href="#自定义用户位置的大头针" class="headerlink" title="自定义用户位置的大头针"></a>自定义用户位置的大头针</h1><pre><code>其实上图中间的那个点就是一个大头针。现在我们要做的就是自定义这个大头针的样式，写代码之前需先了解以下知识：

1.  **MKAnnotationView**：大头针试图，能够自定义，用户当前位置的大头针默认样式是一个原点，非用户当前位置的大头针，系统默认用一个类似图钉样式的试图显示。

2. **MKAnnotation**：大头针的数据模型，只要一个NSObject类实现MKAnnotation协议就可以作为一个大头针数据模型，通常会重写协议中coordinate（标记位置）、title（标题）、**subtitle**（子标题）三个属性来自定义大头针的数据模型。

3. **给地图试图添加大头针的原理如下**
   &gt; 0. 准备大头针数据模型
   &gt; 1. 使用地图试图调用addAnnotaion给地图试图添加大头针数据模型。

   &gt; 2. 然后MKMapView会将数据模型传给一个代理方法，该代理方法会将该大头针数据模型包装到一个大头针试图（在该代理方法内可以自定义大头针试图），然后返回该大头针试图，返回的带有数据模型的大头针试图便会显示在地图上，如果返回为nil,则系统会默认一个大头针试图显示在地图上面。

找到你上面所写的项目，我接着那个项目继续。

实现MKMapView的如下代理方法，当一个大头针将要显示是会调用这个代理方法，该方法会返回一个大头针，如果返回为nil,则系统采用默认的大头针。

       - (nullable MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation{

             //查看文档可以发现MKUserLocatio实现了协议MKAnnotation,所以MKUserLocation也是一个大头针数据模型，有名字可知，这个大头针数据模型是用户当前位置大头针上的数据模型，这里判断传进来的数据模型是不是当前位置的数据模型，如果是就将这个数据模型封装一个大头针试图中。
             if ([annotation isKindOfClass:[MKUserLocation class]]) {

                    MKAnnotationView *userAnnotationView = [[MKAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;userAnnotation&quot;];

                    userAnnotationView.image = [UIImage imageNamed:@&quot;person.png&quot;];

                    //自定义大头针后，大头针是不可交互的，需要将canShowCallout设为YES方可再继续交互。
                    userAnnotationView.canShowCallout = YES;

                     //仅仅实现了让用户大头针在地图试图上往右偏了100
                     //userAnnotationView.centerOffset = CGPointMake(100, 0);
                     //让大头针的详情试图在地图试图上偏移，默认是在用户大头针的顶部
                    //userAnnotationView.calloutOffset = CGPointMake(100, 0);

                     //是否可以拖到大头针
                    //userAnnotationView.draggable = YES;

                    //leftCalloutAccessoryView的试图只有高度能够设置
                    userAnnotationView.leftCalloutAccessoryView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;person.png&quot;]];
                    userAnnotationView.rightCalloutAccessoryView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;person.png&quot;]];

                    //会将detail给覆盖
                    //userAnnotationView.detailCalloutAccessoryView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;person.png&quot;]];;

                   return userAnnotationView;
          }

          return nil;

       }
</code></pre><h1 id="长按地图添加大头针"><a href="#长按地图添加大头针" class="headerlink" title="长按地图添加大头针"></a>长按地图添加大头针</h1><pre><code> 首先复习一些上面提到的放置大头针原理
 &gt; 0. 准备大头针数据模型
 &gt; 1. 使用地图试图调用addAnnotaion给地图试图添加大头针数据模型。

&gt; 2. 然后MKMapView会将数据模型传给一个代理方法，该代理方法会将该大头针数据模型包装到一个大头针试图（在该代理方法内可以自定义大头针试图），然后返回该大头针试图，返回的带有数据模型的大头针试图便会显示在地图上，如果返回为nil,则系统会默认一个大头针试图显示在地图上面。

废话不多说，直接上代码，这是所有的代码，建议你新建一个控制器或者项目直接将所有代码考入即可：

  //
  //  ViewController.m
  //  Map
  //
  //  Created by GG on 16/3/9.
  //  Copyright © 2016年 GG. All rights reserved.
  //

  #import &quot;AnnotationViewController.h&quot;
  #import &lt;MapKit/MapKit.h&gt;
  #import &quot;DetailViewController.h&quot;
  @interface AnnotationViewController ()&lt;MKMapViewDelegate,CLLocationManagerDelegate&gt;
  {

      MKMapView *_mapView;

  }

  @property (nonatomic,retain) CLGeocoder *geocoder;
  @property (nonatomic,retain) CLLocationManager *locationManager;
  @end

  @implementation AnnotationViewController

  - (void)viewDidLoad {
      [super viewDidLoad];

      self.title = @&quot;大头针&quot;;
      self.view.backgroundColor = [UIColor whiteColor];

      _locationManager = [[CLLocationManager alloc]init];
      [_locationManager requestAlwaysAuthorization];
      [_locationManager requestWhenInUseAuthorization];
      _mapView = [[MKMapView alloc]initWithFrame:self.view.frame];

      _mapView.delegate = self;

      _mapView.userTrackingMode = MKUserTrackingModeFollowWithHeading;

      _mapView.mapType = MKMapTypeStandard;

      //    显示标尺
      _mapView.showsScale = YES;
      //    显示交通状态
      _mapView.showsTraffic = YES;
      //    显示罗盘
      _mapView.showsCompass = YES;

      _mapView.delegate = self;

      _mapView.showsUserLocation = YES;

      [self.view addSubview:_mapView];

      UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(longPressClick:)];

      [_mapView addGestureRecognizer:longPressGesture];

  }

  - (void)longPressClick:(UIGestureRecognizer *)sender{
      //试试不加这个判断的效果
      if (sender.state != UIGestureRecognizerStateBegan) {

          return;

      }

      //根据在试图上点击的位置获取到所点的坐标位置
      CLLocationCoordinate2D coordinate = [_mapView convertPoint:[sender locationInView:self.view] toCoordinateFromView:sender.view];

      CLLocation *location = [[CLLocation alloc]initWithLatitude:coordinate.latitude longitude:coordinate.longitude];

      // 反编码
      [self.geocoder reverseGeocodeLocation:location completionHandler:^(NSArray&lt;CLPlacemark *&gt; * _Nullable placemarks, NSError * _Nullable error) {

          MKPointAnnotation *annotation = [[MKPointAnnotation alloc]init];

          annotation.coordinate = coordinate;

          annotation.title = placemarks.firstObject.name;

          [_mapView addAnnotation:annotation];
      }];

  }

  - (void)mapView:(MKMapView *)mapView didUpdateUserLocation:(MKUserLocation *)userLocation{

      MKCoordinateSpan span = MKCoordinateSpanMake(0.1, 0.1);//跨度越大，地图所显示的区域越大
      MKCoordinateRegion regoin = MKCoordinateRegionMake(userLocation.location.coordinate, span);
      [mapView setRegion:regoin animated:YES];

  }

  - (void)mapView:(MKMapView *)mapView didFailToLocateUserWithError:(NSError *)error {

      NSLog(@&quot;定位失败：%@&quot;,error);

  }

  - (void)mapView:(MKMapView *)mapView didSelectAnnotationView:(MKAnnotationView *)view{

      DetailViewController *detailVC = [DetailViewController new];

      detailVC.view.backgroundColor = [UIColor whiteColor];

      //获取到该大头针试图的数据模型
      MKPointAnnotation *annotation = view.annotation;

      detailVC.title = annotation.title;

      //判断当前点击的大头针是不是显示当前用户位置的大头针，如果是就让他变色
      /*
       * MKPinAnnotationView是MKAnnotationView的子类，相比MKAnnotationView而言，他能够设置大头针颜色和显示大头针时的动画

       */
      if (![view.annotation isKindOfClass:[MKUserLocation class]]) {

          MKPinAnnotationView *pinView = (MKPinAnnotationView *)view;

          pinView.pinTintColor = [UIColor yellowColor];
      }

      [self.navigationController pushViewController:detailVC animated:YES];

  }

  - (nullable MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation{

      //系统定义的大头针数据模型专门用来表示用户当前位置大头针上的数据模型，遵守了MKAnnotation协议
      if ([annotation isKindOfClass:[MKUserLocation class]]) {

          MKAnnotationView *userAnnotationView = [[MKAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;userAnnotation&quot;];

          userAnnotationView.image = [UIImage imageNamed:@&quot;person.png&quot;];

          //如果将大头针给自定义会变成不可交互，将canShowCallout设为YES便可恢复交互
          userAnnotationView.canShowCallout = YES;

          //仅仅实现了让用户大头针在地图试图上往右偏了100
          //userAnnotationView.centerOffset = CGPointMake(100, 0);

          //让大头针的详情试图在地图试图上偏移，默认是在用户大头针的顶部
          //userAnnotationView.calloutOffset = CGPointMake(100, 0);

          //是否可以移动大头针
          userAnnotationView.draggable = YES;

          //leftCalloutAccessoryView的试图只有高度能够设置
    userAnnotationView.leftCalloutAccessoryView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;person.png&quot;]];
          userAnnotationView.rightCalloutAccessoryView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;person.png&quot;]];

           return userAnnotationView;
      }

      return nil;

  }

  - (CLGeocoder *)geocoder{

      if (_geocoder == nil) {

          _geocoder = [[CLGeocoder alloc]init];

      }

      return _geocoder;
  }

  @end
</code></pre><h1 id="总结：本文地图学习过程中用到的类"><a href="#总结：本文地图学习过程中用到的类" class="headerlink" title="总结：本文地图学习过程中用到的类"></a>总结：本文地图学习过程中用到的类</h1><pre><code>1.  **大头针分有两种类**

  1. MKPinAnnotationView：他是系统自带的大头针，继承于MKAnnotationView，形状跟棒棒糖类似，可以设置糖的颜色，和显示的时候是否有动画效果

  2. MKAnnotationView：可以用指定的图片作为大头针的样式，但显示的时候没有动画效果，如果没有给图片的话会什么都不显示

2. **MKAnnotation**：大头针的数据模型，只要一个NSObject类实现MKAnnotation协议就可以作为一个大头针数据模型，通常会重写协议中coordinate（标记位置）、title（标题）、**subtitle**（子标题）三个属性来自定义大头针的数据模型。

3. **MKUserLocation**：系统定义的大头针数据模型专门用来表示用户当前位置大头针上的数据模型，遵守了MKAnnotation协议。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/30/添加多个自定义的大头针及自定义大头针动画/" itemprop="url">
                  添加多个自定义的大头针及自定义大头针动画
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-30T19:57:07+08:00" content="2016-08-30">
              2016-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/30/添加多个自定义的大头针及自定义大头针动画/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/30/添加多个自定义的大头针及自定义大头针动画/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   编程之前，需要了解以下知识：</p>
<p>   <a href="https://wangliguang.github.io/2016/08/30/iOS%E5%9C%B0%E5%9B%BE-%E5%9C%B0%E5%9B%BE%E6%98%BE%E7%A4%BA:%E5%A4%A7%E5%A4%B4%E9%92%88/" target="_blank" rel="external">iOS开发之地图-地图显示/大头针</a></p>
<p>   <a href="https://wangliguang.github.io/2016/08/31/iOS%E5%9C%B0%E5%9B%BE-%E5%AE%9A%E4%BD%8D-%E7%BC%96%E7%A0%81%E4%B8%8E%E5%8F%8D%E7%BC%96%E7%A0%81/" target="_blank" rel="external">iOS开发之地图-定位/编码与反编码</a></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>  下面直接将我建的MVC给大家，我已经尽可能的加上注释了，如有不清楚建议先看看上面推荐的两篇文章，如果还不清楚，请留言。</p>
<h2 id="ViewController-m（声明文件中我没有写代码）"><a href="#ViewController-m（声明文件中我没有写代码）" class="headerlink" title="ViewController.m（声明文件中我没有写代码）"></a>ViewController.m（声明文件中我没有写代码）</h2><pre><code>//
//  ViewController.m
//  AddManyCustomAnnotation
//
//  Created by GG on 16/3/10.
//  Copyright © 2016年 GG. All rights reserved.
//

#import &quot;ViewController.h&quot;
#import &lt;MapKit/MapKit.h&gt;
#import &quot;MyAnnotation.h&quot;
#import &lt;CoreLocation/CoreLocation.h&gt;
#import &quot;CustomAnnotationView.h&quot;
@interface ViewController ()&lt;MKMapViewDelegate&gt;
{
    CLLocationManager *_locationManager;

    MKMapView *_mapView;

}

@property (nonatomic,retain) NSMutableArray *locationArray;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    //定位授权
    _locationManager = [[CLLocationManager alloc]init];
    [_locationManager requestAlwaysAuthorization];

    //地图试图
    _mapView = [[MKMapView alloc]initWithFrame:self.view.frame];
    _mapView.showsUserLocation = YES;
    _mapView.delegate = self;
     [self.view addSubview:_mapView];

}

#pragma mark  private Method

//添加大头针
- (void)loadData{

    NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;PinData&quot; ofType:@&quot;plist&quot;];

    NSArray *tempArray = [NSArray arrayWithContentsOfFile:filePath];

    //将pist数据转换成大头针model
    for (NSDictionary *dict in tempArray) {

    MyAnnotation *myAnnotationModel = [[MyAnnotation alloc]initAnnotationModelWithDict:dict];

    [self.locationArray addObject:myAnnotationModel];

    }

    [_mapView addAnnotations:self.locationArray];

}

#pragma mark delegate

- (void)mapView:(MKMapView *)mapView didUpdateUserLocation:(MKUserLocation *)userLocation{

    userLocation.title = @&quot;1234&quot;;
    _mapView.centerCoordinate = userLocation.coordinate;

    [_mapView setRegion:MKCoordinateRegionMake(userLocation.coordinate, MKCoordinateSpanMake(0.3, 0.3)) animated:YES];

    //如果你是在ViewDidload方法中添加大头针，大头针显示时会没有掉落效果，定位结束以后添加大头针才会有掉落效果
    [self loadData];
}

- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id &lt;MKAnnotation&gt;)annotation{

    /*

     * 大头针分两种

     * 1. MKPinAnnotationView：他是系统自带的大头针，继承于MKAnnotationView，形状跟棒棒糖类似，可以设置糖的颜色，和显示的时候是否有动画效果

     * 2. MKAnnotationView：可以用指定的图片作为大头针的样式，但显示的时候没有动画效果，如果没有给图片的话会什么都不显示

     * 3. mapview有个代理方法，当大头针显示在试图上时会调用，可以实现这个方法来自定义大头针的动画效果，我下面写有可以参考一下

     * 4. 在这里我为了自定义大头针的样式，使用的是MKAnnotationView

     */
    if ([annotation isKindOfClass:[MKUserLocation class]]) {

        MKAnnotationView *annotationView = [[MKAnnotationView alloc]init];

        annotationView.image = [UIImage imageNamed:@&quot;user.png&quot;];

        annotationView.canShowCallout = YES;

       return annotationView;

    }

    CustomAnnotationView *annotationView = (CustomAnnotationView *)[mapView dequeueReusableAnnotationViewWithIdentifier:@&quot;otherAnnotationView&quot;];

    if (annotationView == nil) {

        annotationView = [[CustomAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;otherAnnotationView&quot;];

    }

    MyAnnotation *myAnnotation = annotation;

    switch ([myAnnotation.type intValue]) {

        case SUPER_MARKET:{

            annotationView.image = [UIImage imageNamed:@&quot;buy.png&quot;];
            annotationView.label.text = @&quot;超市&quot;;

        }break;

        case CREMATORY:{

            annotationView.image = [UIImage imageNamed:@&quot;fire.png&quot;];
            annotationView.label.text = @&quot;火葬场&quot;;

        }break;

        case INTEREST:{

            annotationView.image = [UIImage imageNamed:@&quot;cammer.png&quot;];
            annotationView.label.text = @&quot;景点&quot;;

        }break;

    }
    return annotationView;

}

//大头针显示在试图上时调用，我在这里给大头针设置显示动画
- (void) mapView:(MKMapView *)mapView didAddAnnotationViews:(NSArray *)views {

    //获取到mapview的frame
    CGRect visibleRect = [mapView annotationVisibleRect];

    for (MKAnnotationView *view in views) {

        CGRect endFrame = view.frame;
        CGRect startFrame = endFrame;
        startFrame.origin.y = visibleRect.origin.y - startFrame.size.height;
        view.frame = startFrame;
        [UIView beginAnimations:@&quot;drop&quot; context:NULL];
        [UIView setAnimationDuration:1];
        view.frame = endFrame;
        [UIView commitAnimations];
    }
}

#pragma mark lazy load

- (NSMutableArray *)locationArray{

    if (_locationArray == nil) {

        _locationArray = [NSMutableArray new];

    }
    return _locationArray;
}

@end
</code></pre><p>PS: 大头针的显示跟cell的显示机制一样，都是采用复用机制，可以对比着来理解。</p>
<h2 id="大头针数据模型-MyAnnotation-h"><a href="#大头针数据模型-MyAnnotation-h" class="headerlink" title="大头针数据模型   MyAnnotation.h"></a>大头针数据模型   MyAnnotation.h</h2><pre><code>//
//  MyAnnotation.h
//  AddManyCustomAnnotation
//
//  Created by GG on 16/3/13.
//  Copyright © 2016年 GG. All rights reserved.
//

#import &lt;Foundation/Foundation.h&gt;
#import &lt;MapKit/MapKit.h&gt;

typedef NS_ENUM(NSInteger, PinType) {
    /**
     *  超市
     */
    SUPER_MARKET = 0,
    /**
     *  火化场
     */
    CREMATORY,
    /**
     *  景点
     */
    INTEREST
};

//该模型是大头针模型，所以我必须实现MKAnnotation协议，而且必须实现CLLocationCoordinate2D coordinate属性
@interface MyAnnotation : NSObject &lt;MKAnnotation&gt;

@property (nonatomic, assign) CLLocationCoordinate2D coordinate;

@property (nonatomic, copy) NSString *name;

@property (nonatomic, copy) NSString *title;

@property (nonatomic, retain) NSNumber *type;

- (instancetype)initAnnotationModelWithDict:(NSDictionary *)dict;

@end
</code></pre><h2 id="大头针数据模型-MyAnnotation-m"><a href="#大头针数据模型-MyAnnotation-m" class="headerlink" title="大头针数据模型   MyAnnotation.m"></a>大头针数据模型   MyAnnotation.m</h2><pre><code>//
//  MyAnnotation.m
//  AddManyCustomAnnotation
//
//  Created by GG on 16/3/13.
//  Copyright © 2016年 GG. All rights reserved.
//

#import &quot;MyAnnotation.h&quot;

@implementation MyAnnotation

- (instancetype)initAnnotationModelWithDict:(NSDictionary *)dict{

    self = [super init];

    if (self) {

        self.coordinate = CLLocationCoordinate2DMake([dict[@&quot;coordinate&quot;][@&quot;latitude&quot;] doubleValue], [dict[@&quot;coordinate&quot;][@&quot;longitude&quot;] doubleValue]);

        self.title = dict[@&quot;detail&quot;];

        self.name = dict[@&quot;name&quot;];

        self.type = dict[@&quot;type&quot;];

    }

    return self;

}

@end
</code></pre><h2 id="大头针试图-CustomPinAnnotationView-h"><a href="#大头针试图-CustomPinAnnotationView-h" class="headerlink" title="大头针试图  CustomPinAnnotationView.h"></a>大头针试图  CustomPinAnnotationView.h</h2><pre><code>//
//  CustomPinAnnotationView.h
//  AddManyCustomAnnotation
//
//  Created by GG on 16/3/13.
//  Copyright © 2016年 GG. All rights reserved.
//

#import &lt;MapKit/MapKit.h&gt;
#import &quot;MyAnnotation.h&quot;
@interface CustomAnnotationView : MKAnnotationView

@property (nonatomic, retain)UILabel *label;

@end
</code></pre><h2 id="大头针试图-CustomPinAnnotationView-m"><a href="#大头针试图-CustomPinAnnotationView-m" class="headerlink" title="大头针试图  CustomPinAnnotationView.m"></a>大头针试图  CustomPinAnnotationView.m</h2><pre><code>//
//  CustomPinAnnotationView.m
//  AddManyCustomAnnotation
//
//  Created by GG on 16/3/13.
//  Copyright © 2016年 GG. All rights reserved.
//

#import &quot;CustomAnnotationView.h&quot;

@implementation CustomAnnotationView

- (instancetype)initWithAnnotation:(id&lt;MKAnnotation&gt;)annotation reuseIdentifier:(NSString *)reuseIdentifier{

    if ([super initWithAnnotation:annotation reuseIdentifier:reuseIdentifier]) {
        //在大头针旁边加一个label
        self.label = [[UILabel alloc] initWithFrame:CGRectMake(0, -15, 50, 20)];
        self.label.textColor = [UIColor grayColor];
        self.label.textAlignment = NSTextAlignmentCenter;
        self.label.font = [UIFont systemFontOfSize:10];
        [self addSubview:self.label];

    }

    return self;
}

@end
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/30/H5面试题集合/" itemprop="url">
                  H5面试题集合
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-30T15:59:34+08:00" content="2016-08-30">
              2016-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/H5面试题/" itemprop="url" rel="index">
                    <span itemprop="name">H5面试题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/30/H5面试题集合/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/30/H5面试题集合/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简述easeUI"><a href="#简述easeUI" class="headerlink" title="简述easeUI"></a>简述easeUI</h1><ul>
<li><p>什么是easyUI</p>
<p>  是一组基于jQuery的UI插件集合体，而jeaseyUI的目标是帮助web开发者更轻松的打造出功能丰富并且美观的UI界面。开发者不需要编写复杂的javascript,也不需要对css样式有深入的了解，开发者需要了解的只有一些简单的html标签。</p>
</li>
<li><p>特点</p>
<p>它提供了大多数UI控件的使用，如：accordion/combobox/menu/dialog/tabs/validatebox/datagrid/window/tree等等。</p>
</li>
</ul>
<h1 id="XMLHttpRequest对象的常用方法和属性"><a href="#XMLHttpRequest对象的常用方法和属性" class="headerlink" title="XMLHttpRequest对象的常用方法和属性"></a>XMLHttpRequest对象的常用方法和属性</h1><ul>
<li><p>方法</p>
<p>  open(“method”,”url”) 建立对服务器的调用:</p>
<p>   参数1：HTTP请求方式<br>   参数2：请求页面的URL</p>
<p>  send()  发送具体请求<br>  abort() 停止当前请求</p>
</li>
<li><p>属性</p>
<p>  readyState:请求的状态，有五个可取的值</p>
<pre><code>&gt;0 = 未初始化    
1 = 正在加载   
2 = 已加载     
4 = 交互中   
5 = 完成
</code></pre><p>  responseText: 服务器的响应，表示为一个字符串</p>
<p>  reponseXML： 服务器的响应，表示为XML</p>
<p>  status: 服务器的HTTP状态码</p>
</li>
</ul>
<h1 id="AJAX应用和传统Web应用有什么不同"><a href="#AJAX应用和传统Web应用有什么不同" class="headerlink" title="AJAX应用和传统Web应用有什么不同"></a>AJAX应用和传统Web应用有什么不同</h1><ul>
<li><p>在传统的JS编程中，如果想得到服务器端数据库或文件上的信息，或者发送客户端信息到服务器，需要建立一个HTML form然后GET或者POST数据到服务器端。用户需要点击summit按钮来发送或者接受数据信息，然后等待服务器响应请求，<strong>页面重新加载。因为服务器每次都会返回一个新的页面，所以传统的web引用有可能很慢而且用户交互较差。</strong></p>
</li>
<li><p>使用AJAX技术，就可以使JavaScript通过XMLHttpRequest对象直接与服务器进行交互，通过HTTP Request，一个web页面可以发送一个请求到web服务器并且接受web服务器返回的信息（不用重新加载界面），<strong>展示给用户的还是同一页面，但是只实现页面的局部刷新，从而提高体验度。</strong></p>
</li>
</ul>
<h1 id="介绍一下XMLHttprequest对象"><a href="#介绍一下XMLHttprequest对象" class="headerlink" title="介绍一下XMLHttprequest对象"></a>介绍一下XMLHttprequest对象</h1><ul>
<li>AJAX的核心是JavaScript对象<strong>XMLHttpRequest</strong>。该对象在Internet Explorer 5中首次，他是一种支持异步请求的技术。</li>
</ul>
<ul>
<li>XmlHttpRequest可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部刷新。</li>
</ul>
<h1 id="至少写出5种常见的http状态码以及代表的意义"><a href="#至少写出5种常见的http状态码以及代表的意义" class="headerlink" title="至少写出5种常见的http状态码以及代表的意义"></a>至少写出5种常见的http状态码以及代表的意义</h1><ul>
<li><p><strong>200(OK)</strong><br>请求已成功，请求所希望的响应头或数据体将随此响应返回。</p>
</li>
<li><p><strong>303(See Other)</strong><br>告知客户端使用另一个URL来获取资源</p>
</li>
<li><p><strong>400(Bad Request)</strong><br> 请求格式错误</p>
<ol>
<li>语义有误，当前请求无法被服务器理解。</li>
<li>请求参数有误。</li>
</ol>
</li>
<li><p><strong>404(Not Found)</strong></p>
<p> 请求失败，请求所希望得到的资源未在服务器上发现</p>
</li>
<li><p><strong>500(Internal Srver Error)</strong></p>
<p>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理</p>
</li>
</ul>
<h1 id="jQuery中的Delegate-函数有什么用？"><a href="#jQuery中的Delegate-函数有什么用？" class="headerlink" title="jQuery中的Delegate()函数有什么用？"></a>jQuery中的Delegate()函数有什么用？</h1><ul>
<li><p>给父元素其下的子元素添加事件，代码如下：</p>
<pre><code>$(&quot;ul&quot;).delegate(&quot;li&quot;,&quot;click&quot;,function(){
  $(this).hide();
});
</code></pre></li>
<li><p>当元素在当前页面中不可用时，可以使用delegate()</p>
</li>
</ul>
<h1 id="jQuery中有哪几种类型的选择器"><a href="#jQuery中有哪几种类型的选择器" class="headerlink" title="jQuery中有哪几种类型的选择器"></a>jQuery中有哪几种类型的选择器</h1><ul>
<li><p><strong>基本选择器：</strong> 直接根据id/css类名/元素名返回dom元素</p>
</li>
<li><p><strong>层次选择器：</strong>也叫作路径选择器，可以根据路径层次来选择相应的dom元素</p>
</li>
<li><p><strong>过滤选择器：</strong>在前面的基础上过滤相关条件，得到匹配的dom元素</p>
</li>
</ul>
<h1 id="body中的onload-和jQuery中的-document-ready-有什么区别"><a href="#body中的onload-和jQuery中的-document-ready-有什么区别" class="headerlink" title="body中的onload()和jQuery中的$(document).ready()有什么区别"></a>body中的onload()和jQuery中的$(document).ready()有什么区别</h1><ul>
<li><p>可以在页面中使用多个document.ready(),但只能使用一次onload()</p>
</li>
<li><p>document.ready()函数在页面DOM元素加载完成以后就会被调用，而onload函数则要在所有的关联资源(包括图像、音频)加载完毕才会调用。</p>
</li>
</ul>
<h1 id="HTML5中新增的表单元素有哪些"><a href="#HTML5中新增的表单元素有哪些" class="headerlink" title="HTML5中新增的表单元素有哪些"></a>HTML5中新增的表单元素有哪些</h1><ul>
<li>datalist</li>
<li>datatime</li>
<li>output</li>
<li>date</li>
<li>month</li>
<li>week</li>
<li>time</li>
<li>color</li>
<li>number</li>
<li>range</li>
<li>email</li>
<li>url</li>
<li>search</li>
</ul>
<h1 id="HTML5应用程序缓存和浏览器缓存有什么区别"><a href="#HTML5应用程序缓存和浏览器缓存有什么区别" class="headerlink" title="HTML5应用程序缓存和浏览器缓存有什么区别"></a>HTML5应用程序缓存和浏览器缓存有什么区别</h1><p>应用程序缓存是HTML5的重要特性之一，提供了离线使用功能，让应用程序可以获取本地的网站内容，例如：HTML/CSS/图片以及JavScript。这个特性可以提高网站性能，他的实现借助于manifest文件，代码如下：</p>
<pre><code>&lt;!doctype html&gt;
    &lt;html manifest = &quot;example.appcache&quot;&gt;
    ....
 &lt;/html&gt;
</code></pre><p>与传统浏览器相比，它不强制用户访问的网站内容被缓存。</p>
<h1 id="什么是Web-Worker？为什么需要他们？"><a href="#什么是Web-Worker？为什么需要他们？" class="headerlink" title="什么是Web Worker？为什么需要他们？"></a>什么是Web Worker？为什么需要他们？</h1><p>查看如下代码(模拟会执行上百万此的繁重代码)：</p>
<pre><code>function test(){
   for(i = 0; i&lt; 10000000; i++){
      x = x + i;
   }
}
</code></pre><p>如果上诉代码在HTML按钮点击以后执行，这种执行是同步的，即浏览器必须等到此执行完毕之后才能进行其他操作。因为此操作耗时较长，那么这个操作会导致浏览器冻结并且没有响应，而且屏幕还会出现异常信息。</p>
<p>如果可以将这些繁重的代码移动到JS文件中，并采用异步的方式运行，就可以解决这个问题。这就是web worker的作用。web worker用于异步执行javaScript文件，提高浏览器的敏捷度。</p>
<h1 id="除了音频视频，HTML5还支持什么其他新的媒体元素"><a href="#除了音频视频，HTML5还支持什么其他新的媒体元素" class="headerlink" title="除了音频视频，HTML5还支持什么其他新的媒体元素"></a>除了音频视频，HTML5还支持什么其他新的媒体元素</h1><p>HTML5对媒体支持很强，除了audio和video外，还提供：</p>
<ul>
<li><strong>embed</strong>作为外部应用的容器</li>
<li><strong>track</strong>定义媒体的文本跟踪</li>
<li><strong>source</strong>多种媒体源的支持</li>
</ul>
<h1 id="HTML5有哪些不同类型的存储"><a href="#HTML5有哪些不同类型的存储" class="headerlink" title="HTML5有哪些不同类型的存储"></a>HTML5有哪些不同类型的存储</h1><ul>
<li><p>HTM5支持本地存储，在之前的版本中是通过Cookie实现的。HTML5本地存储速度快而安全。</p>
</li>
<li><p>有两种不同的对象可用于存储数据。</p>
<ol>
<li><p>localStorage：适用于长期存储数据，浏览器关闭后数据不丢失。</p>
</li>
<li><p>sessionStorage: 存储的数据在浏览器关闭后自动删除。</p>
</li>
</ol>
</li>
</ul>
<h1 id="简要描述HTML5中Canvas的作用"><a href="#简要描述HTML5中Canvas的作用" class="headerlink" title="简要描述HTML5中Canvas的作用"></a>简要描述HTML5中Canvas的作用</h1><ul>
<li><p>Canva是HTML5的出现的标签，拥有自己的属性、方法、事件，其中就有绘图的方法，JS能够调用它在网页上完成绘图</p>
</li>
<li><p>Canvas也是HTML5中最强大的特性之一，允许开发者使用动态和交互式可视化方法在Web上实现桌面应用程序的功能。</p>
</li>
</ul>
<h1 id="简要描述HTML5中的本地存储"><a href="#简要描述HTML5中的本地存储" class="headerlink" title="简要描述HTML5中的本地存储"></a>简要描述HTML5中的本地存储</h1><ul>
<li><p>很多时候我们会存储用户本地信息到电脑上，例如：用户有一个填充了一半的长表格，然后突然网络断开了，这样用户希望你能存储这些信息到本地，当网络恢复的时候，他想获取这些信息然后发送到服务器进行存储。</p>
</li>
<li><p>现代浏览器拥有的存储被叫做“Local Storage”,用于存储这些信息。</p>
</li>
</ul>
<h1 id="描述Call和apply的区别"><a href="#描述Call和apply的区别" class="headerlink" title="描述Call和apply的区别"></a>描述Call和apply的区别</h1><ul>
<li><p>Call()和apply()都用于间接调用函数</p>
</li>
<li><p>call方法用于调用一个对象的一个方法，并以另一个对象替换当前的对象。即，任何函数可以作为任何对象的方法来调用，哪怕这个函数并非那个那个对象的方法，语法如下：</p>
<pre><code>call(thisObj[,arg1[,arg2[,.....[, .argN]]]]);
</code></pre><p>   其中第一个参数thisObj要调用函数的上下文，即将被用作当前对象的对象。其他参数为可选参数，表示将被传递方法参数序列。</p>
</li>
<li><p>apply()和call()在作用上是相同的，但两者在参数上有区别，他两的第一个参数相同，不同的是第二个参数。对于apply()，第二个参数是一个参数数组，也就是将多个参数合成为一个数组传入。如:</p>
<pre><code>func.call(func1,var1,var2,var3);
func.apply(func1,[var1,var2,var3]);
</code></pre></li>
</ul>
<h1 id="描述JS中的继承"><a href="#描述JS中的继承" class="headerlink" title="描述JS中的继承"></a>描述JS中的继承</h1><p>在JS中，继承都是源于原型，有多种实现方式。</p>
<ol>
<li><p>修改构造函数的原型，为该构造函数创建的对象指定统一的父级对象，代码如下：</p>
<pre><code>B.prototype = new A();
</code></pre></li>
</ol>
<ol>
<li><p>只继承于原型（尽可能地将可重用的属性和方法添加到原型中），代码如下：</p>
<pre><code>B.prototype = A.prototype;
</code></pre></li>
<li><p>单独修改一个对象的原型，而不影响其他对象的原型，代码如下：</p>
<pre><code>var b1 = new B();
Object.setPrototypeOf(b1,new A());
</code></pre></li>
<li><p>修改构造函数，这将影响使用该构造函数创建的所有对象，代码如下：</p>
<pre><code>function B(){
  Object.setPrototypeOf(this,new A());
} 
</code></pre></li>
</ol>
<h1 id="描述对原型链的理解"><a href="#描述对原型链的理解" class="headerlink" title="描述对原型链的理解"></a>描述对原型链的理解</h1><ul>
<li><p>每个函数中都有prototype属性，该函数被new操作符用于创建对象。将一个函数的prototype属性指向某个对象，由此形成了一条链，称之为原型链。</p>
</li>
<li><p>可以使用isPrototypeOf()方法判定一个prototype对象是否存在于另一个对象的原型链中。如果是返回true,否则返回false。</p>
</li>
</ul>
<h1 id="简述JS中的自有属性和原型属性"><a href="#简述JS中的自有属性和原型属性" class="headerlink" title="简述JS中的自有属性和原型属性"></a>简述JS中的自有属性和原型属性</h1><ul>
<li><p>自有属性</p>
<p>指通过对象的引用添加的属性，此时，其他对象可能无此属性。对于自有属性，是各个对象所持有的、彼此独立的属性。</p>
<pre><code>emp1.job = &quot;Coder&quot;;
</code></pre></li>
<li><p>原型属性</p>
<p> 指从原型对象中继承来的属性，一旦原型对象中的属性值改变，所有继承自该原型的对象属性均改变。</p>
<pre><code>emp.prototype.dept  = &quot;研发部&quot;;
</code></pre></li>
</ul>
<ul>
<li><p>检测对象的属性</p>
<ol>
<li><p>当需要检测对象的自有属性时，可以使用hasOwnProperty()方法，另，还可以使用in操作检测对象及其原型链中是否具备指定属性。</p>
</li>
<li><p>在检测对象属性时，先检测自有属性，再检测原型属性。</p>
</li>
</ol>
</li>
</ul>
<h1 id="简述对JS中原型的理解"><a href="#简述对JS中原型的理解" class="headerlink" title="简述对JS中原型的理解"></a>简述对JS中原型的理解</h1><ul>
<li><p>在JS中，函数本身就是一个包含了方法和属性的对象。每个函数中都有一个prototype属性，该属性所存储的就是原型对象。</p>
</li>
<li><p>原型对象用来保存共享属性和方法，可以通过原型来实现为对象扩展属性，实现继承。</p>
</li>
</ul>
<h1 id="this关键字的作用是什么？"><a href="#this关键字的作用是什么？" class="headerlink" title="this关键字的作用是什么？"></a>this关键字的作用是什么？</h1><ul>
<li><p>笼统的说，关键字this指向当前对象。比如：顶级代码中的this指向全局对象；在指定元素事件的时候，this指定当前发生事件的元素对象。</p>
</li>
<li><p>对于嵌套函数，如果嵌套函数作为方法被调用，其this指向调用它的对象；如果作为函数调用，this是全局对象或者为undefined（严格模式下）。</p>
</li>
</ul>
<h1 id="JS中创建自定义对象的方式"><a href="#JS中创建自定义对象的方式" class="headerlink" title="JS中创建自定义对象的方式"></a>JS中创建自定义对象的方式</h1><p>自定义对象指由用户创建的对象，兼容性问题需要由编写者注意。创建自定义对象的方式有：</p>
<ol>
<li><p>对象直接量</p>
</li>
<li><p>new objec()</p>
</li>
<li><p>function 对象模板</p>
</li>
<li><p>Object.create()</p>
</li>
</ol>
<h1 id="简要描述对闭包的理解"><a href="#简要描述对闭包的理解" class="headerlink" title="简要描述对闭包的理解"></a>简要描述对闭包的理解</h1><ul>
<li><p>闭包的理解</p>
<p>函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为闭包，这意味着函数变量可以隐藏于作用域链之内，看起来好像是函数将变量包裹了起来。这种方式常用于共享函数内的私有变量。</p>
</li>
</ul>
<ul>
<li><p>闭包的应用特征</p>
<ol>
<li><p><strong>局部变量：</strong>在函数中定义有共享意义(如：缓存、计数器等)的局部变量(注：定义成全局变量会对外造成污染);</p>
</li>
<li><p><strong>内嵌函数：</strong>在函数内声明有内嵌函数，内嵌函数对函数中的局部变量进行访问</p>
</li>
<li><p><strong>外部使用：</strong>函数向外返回此内嵌函数，外部可以通过此内嵌函数持有并访问声明在函数中的局部变量，而此变量在外部是通过其他途径无法访问的。</p>
</li>
</ol>
</li>
</ul>
<h1 id="简要描述JS中的作用域链-任何一段JS代码中都对应一个作用域链，作用域链中存放一系列对象，代码中声明的变量讲作为对象的属性存放。"><a href="#简要描述JS中的作用域链-任何一段JS代码中都对应一个作用域链，作用域链中存放一系列对象，代码中声明的变量讲作为对象的属性存放。" class="headerlink" title="简要描述JS中的作用域链- 任何一段JS代码中都对应一个作用域链，作用域链中存放一系列对象，代码中声明的变量讲作为对象的属性存放。"></a>简要描述JS中的作用域链- 任何一段JS代码中都对应一个作用域链，作用域链中存放一系列对象，代码中声明的变量讲作为对象的属性存放。</h1><ul>
<li><p>在JS的顶层代码中，作用域链由一个全局对象组成；当定义一个函数时，他保存一个作用域链，作用域链上有两个对象，一个是函数对象，一个是全局对象。</p>
</li>
<li><p>每当一个函数被调用，会创建一个活动对象(也叫上下文对象)，函数中的局部变量将作为该对象的属性存放。</p>
</li>
<li><p>当需要使用一个变量时，将从作用域链中逐个查找对象的属性。<strong>比如：要使用变量a</strong></p>
<ol>
<li><p>将先查找作用域中的第一个对象是否有属性a,如果有就使用；</p>
</li>
<li><p>如果没有就查找作用域链中的下一个对象的属性，以此类推。</p>
</li>
<li><p>如果作用域链上没有任何一个对象函数属性a，则认为这段代码的作用域链上不存在a，将抛出引用错误异常。</p>
</li>
</ol>
</li>
</ul>
<ol>
<li>当函数调用完成后，如果没有其他引用指向为此次调用所创建的上下文对象，该对象将被回收。</li>
</ol>
<h1 id="简要描述JS中的匿名函数"><a href="#简要描述JS中的匿名函数" class="headerlink" title="简要描述JS中的匿名函数"></a>简要描述JS中的匿名函数</h1><ul>
<li><p>匿名函数是指在定义时<strong>没有指定名字的函数</strong>，且定义后往往直接调用，如：</p>
<pre><code>function(num1,num2){
  console.log(num1+num2)；
}
</code></pre><p>这种方式所定义的匿名函数，往往需要直接调用，如：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    
    (function(num1,num2){
        console.log(num1+num2);
    })(10,20);
&lt;/script&gt;
</code></pre><p> 其他任何代码都没写的情况下， 控制台输出：</p>
<pre><code>30
</code></pre></li>
<li><p>匿名函数常用于定义不需要重复使用的函数，用完即释放。另外，对于直接调用的匿名函数而言，可以看成是一个临时的命名空间，其区域内定义的所有变量，不会污染到全局命名空间。</p>
</li>
</ul>
<h1 id="什么是正则表达式，在JS中如何应用？"><a href="#什么是正则表达式，在JS中如何应用？" class="headerlink" title="什么是正则表达式，在JS中如何应用？"></a>什么是正则表达式，在JS中如何应用？</h1><ul>
<li><p>什么是正则表达式</p>
<ol>
<li><p>正则表达式本身就一个字符串，由一些普通字符和特殊字符组成，用以秒速一种特定的字符规则的表达式。</p>
</li>
<li><p>正则表达式常用于在一段文本中搜索、匹配或替换特定形式的文本。如词语出现频率统计、验证字符串是否符合邮箱格式、屏蔽一篇帖子总的限制性词语等。许多程序设计语言都支持利用正则表达式进行字符串操作。</p>
</li>
</ol>
</li>
<li><p>在JS中，正则表达式的应用分为两种</p>
<ol>
<li><p>结合String对象的replace/search/match方法，实现对字符串的替换、查找和匹配。</p>
</li>
<li><p>定义正则表达式对象，实现对字符串的复杂匹配操作。</p>
</li>
</ol>
</li>
</ul>
<h1 id="什么是栈，在JS中，如何模拟栈操作"><a href="#什么是栈，在JS中，如何模拟栈操作" class="headerlink" title="什么是栈，在JS中，如何模拟栈操作"></a>什么是栈，在JS中，如何模拟栈操作</h1><ul>
<li><p>栈(stack)是一种运算受限的线性表，其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对的把另一端称为栈底。</p>
</li>
<li><p>向一个栈插入新元素又称作进栈、入栈或压栈，他是把新元素放到栈顶元素的上面，使之称为新的栈顶元素；</p>
</li>
<li><p>从一个栈删除元素又称作出栈或退栈，他是把栈顶元素给删掉，使其相邻的元素成为新的栈顶元素</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-c076fec4a5af7f89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>在JS中，可以使用数组及其相关操作来模拟栈操作。</p>
<ol>
<li><p>首先使用数组存储一列元素，</p>
</li>
<li><p>然后使用数组的push()方法在数组的尾部添加指定的元素，类似于在栈顶添加元素，即顶部入；</p>
</li>
<li><p>然后使用数组的pop()删除并返回数组尾部的元素，类似于顶部出栈，即后入的元素先出。</p>
</li>
</ol>
</li>
</ul>
<h1 id="使用JS编写冒泡排序"><a href="#使用JS编写冒泡排序" class="headerlink" title="使用JS编写冒泡排序"></a>使用JS编写冒泡排序</h1><pre><code>var array = [5, 4, 3, 2, 1];
var temp = 0;

for (var i = 0; i &lt; array.length; i++)
{
   for (var j = 0; j &lt; array.length - i; j++)
   {
      if (array[j] &gt; array[j + 1])
      {
         temp = array[j + 1];
         array[j + 1] = array[j];
         array[j] = temp;
       }
   }
}
console.log(array);
</code></pre><h1 id="列举几个JavaScript中常用的全局函数，并描述其作用"><a href="#列举几个JavaScript中常用的全局函数，并描述其作用" class="headerlink" title="列举几个JavaScript中常用的全局函数，并描述其作用"></a>列举几个JavaScript中常用的全局函数，并描述其作用</h1><ol>
<li><p><strong>parseInt：</strong>解析一个字符串并返回一个整数</p>
</li>
<li><p><strong>parseFloat：</strong> 解析一个字符串并返回一个整数</p>
</li>
<li><p><strong>isNaN：</strong> 检查某个值是否是数字，返回true或者false</p>
</li>
<li><p><strong>encodeURI：</strong> 把字符串作为URI进行编码</p>
</li>
<li><p><strong>decodeURI：</strong> 对encodeURI() 函数编码过的URI进行解码</p>
</li>
<li><p><strong>eval：</strong> 计算某个字符串，以得到结果，或者用于执行其中的JavaScript代码。</p>
</li>
</ol>
<h1 id="简述arguments对象的作用"><a href="#简述arguments对象的作用" class="headerlink" title="简述arguments对象的作用"></a>简述arguments对象的作用</h1><ul>
<li><p>在函数代码中，使用特殊对象arguments可以访问函数的参数。即，开发者在定义函数时，无需明确的为方法声明参数，可以在方法体重使用argument来访问参数，这是因为，argument是一种特殊对象，在函数代码中，表示函数的参数数组。</p>
</li>
<li><p>正因为arguments表示参数组成的数组，因此，首先可以使用arguments.length检测函数的参数个数，其次，可以通过下标(arguments[index])来访问某个参数。这样可以用arguments对象判断传递给函数的参数个数并获取参数，适用于函数参数无法确定个数的情况下。</p>
</li>
</ul>
<h1 id="什么是逻辑短路"><a href="#什么是逻辑短路" class="headerlink" title="什么是逻辑短路"></a>什么是逻辑短路</h1><ul>
<li><p>逻辑短路时对于逻辑运算而言的。指仅计算逻辑表达式中的一部分便能确定结果，而不对整个表达式进行计算的现象</p>
</li>
<li><p>对于&amp;&amp;运算符，当第一个操作数为false时，将不会判断第二个操作数，因为此时无论第二个操作数为何，最后的运算结果一定是false</p>
</li>
<li><p>对于||运算符，当第一个操作数为true时，将不会判断第二个操作数，因为此时无论第二个操作数为何，最后的运算结果一定是true</p>
</li>
</ul>
<h1 id="简要描述null和undefined的区别"><a href="#简要描述null和undefined的区别" class="headerlink" title="简要描述null和undefined的区别"></a>简要描述null和undefined的区别</h1><ul>
<li><p><strong>null</strong><br>是JavaScript的关键字，用于描述”空值”，对其执行typeof操作，返回”Object”，即为一个特殊的对象值，可以表示数字、字符串和对象是”无值”的。</p>
</li>
<li><p><strong>undefined</strong><br>是预定义的全局变量，其值为”未定义”，他是变量的一种取值，表示变量没有初始化。当查询对象属性、数组元素的值时，如果返回undefined则表示属性或者元素不存在；如果函数没有任何返回值，也返回undefined。</p>
</li>
<li><p><strong>注意</strong></p>
<p>虽然null和undefined是不同的，但是因为都表示『值的空缺』，两者可以互换，因此，使用”==”认为两者是相等的，需要使用”===”来区分它们。</p>
</li>
</ul>
<h1 id="H5为什么这么火？H5是哪一年产生的？H5会火多久？"><a href="#H5为什么这么火？H5是哪一年产生的？H5会火多久？" class="headerlink" title="H5为什么这么火？H5是哪一年产生的？H5会火多久？"></a>H5为什么这么火？H5是哪一年产生的？H5会火多久？</h1><ul>
<li><p>因为H5的后台很硬，是谷歌（google）和苹果（Apple）两大巨头公司，谷歌和苹果大力倡导H5的发展，也是H5的忠实的支持者和实践者（IOS+Android系统占据手机市场92.36%），H5的产生主要目的也是干掉flash，因为flash是adobe公司的，adobe不是W3C组织的成员之一，苹果和谷歌等万维网联盟也不希望在自己的产品中使用加载量过大的flash。</p>
</li>
<li><p>H5是2014年9月份W3C（万维网联盟，主要有苹果和谷歌公司）组织发布的。</p>
</li>
<li><p>刷脸时代（这里专指网站用户体验更加美观的时代）+移动端时代（手机+平板），会促使H5会在未来的有更加美好的发展前景，只要有网站，H5就会很火，UI也就很火，H5的发展会让UI更加提高用户的满意度，H5的火爆时代，会促进UI更好发展。  </p>
</li>
<li><p>微信的发展，O2O的促使H5更火。</p>
<p>在这里不得不谈微信，如果没有微信，或许今天我们不会这样来讨论H5，微信无意中养成了用户扫码的习惯，并通过公众号的内容生产及分发，以及微信本身已有的庞大的用户群体及社交属性，使基于网页的内容可以快速传播，真正带来了APP即浏览器的时代，取消了输入内容网址的麻烦。以微信为代表的超级社交APP，解决了网页内容浏览及分发的通路。H5或许会没落，但会迎来H6、H7…，只会变得越来越好，所以没必要担心H5会不会死，当下重在实践与积累，至少现在，Html5的影响力，会超出你我的想象，也就意味着H5的好闺蜜UI会一直火下去。</p>
</li>
</ul>
<h1 id="原生App与H5的区别"><a href="#原生App与H5的区别" class="headerlink" title="原生App与H5的区别"></a>原生App与H5的区别</h1><ol>
<li><p>如果APP中出现大段文字（如新闻、攻略等），且格式比较丰富（如加粗，字体多样），那么用H5会比较方便。原因是原生开发解析json对字符串格式处理不算很好。</p>
</li>
<li><p>如果讲究APP反应速度（含页面切换流畅性），则选用原生开发，因为H5其本质是网页，换页时，基本要加载整个页面，就像是浏览器打开一个新页面一样，显得较慢，而原生系统则只加载变化部分。</p>
</li>
<li><p>如果APP对有无网络、网络优劣敏感（譬如有离线操作，在线操作），那么，基本选用原生开发，虽然H5可以做到，但是很复杂。</p>
</li>
<li><p>如果APP需要频繁调用硬件（摄像头、麦克风、未来的湿度检测仪等等）那么，基本选用原生开发，这样支持硬件更多，更容易扩展，且调用速度更快，H5就望尘莫及了。</p>
</li>
<li><p>如果APP用户常见页面频换，如（淘宝首页各种不同活动），那么用H5，维护起来更容易。</p>
</li>
<li><p>如果预算有限（H5开发一套可跨平台覆盖安卓、ios，黑莓、塞班），不是很讲究用户体验，不在乎加载速度，那非H5不可。</p>
</li>
</ol>
<p>列举那么多，实际上有个采阴补阳的方法是H5+原生混合开发，对于固定格式、页面速度要求高，的模块（如PDB的即时通讯、宝典、我的项目）采用原生开发，对于新闻、大段文字、资讯类的（如信息广场、发表、问吧等）用H5页面来加载，将其嵌入到原生框架中那么，可以达到比较良好的体验。</p>
<h1 id="前端工程师，平常访问的IT网站都有哪些？"><a href="#前端工程师，平常访问的IT网站都有哪些？" class="headerlink" title="前端工程师，平常访问的IT网站都有哪些？"></a>前端工程师，平常访问的IT网站都有哪些？</h1><ul>
<li>W3C shool </li>
<li>segmentFault</li>
<li>csdn</li>
<li>知乎论坛 </li>
<li>博客园</li>
</ul>
<h1 id="如何居中div，如何居中一个浮动元素"><a href="#如何居中div，如何居中一个浮动元素" class="headerlink" title="如何居中div，如何居中一个浮动元素?"></a>如何居中div，如何居中一个浮动元素?</h1><p>确定容器的宽高 宽500 高 300 的层。  设置层的外边距    </p>
<pre><code>.div {       
  Width:500px ; 
  height:300px;//高度可以不设     
  Margin: -150px 0 0 -250px;      
  position:relative;相对定位     
  background-color:pink;//方便看效果   
  left:50%;    
  top:50%;    
 } 
</code></pre><h1 id="CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？"><a href="#CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？" class="headerlink" title="CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？"></a>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？</h1><ul>
<li><p>选择符</p>
<ol>
<li>id选择器（ # myid）       </li>
<li>类选择器（.myclassname）        </li>
<li>标签选择器（div, h1, p） </li>
<li>相邻选择器（h1 + p）        </li>
<li>子选择器（ul &lt; li）       </li>
<li>后代选择器（li a）        </li>
<li>通配符选择器（ * ）        </li>
<li>属性选择器（a[rel = “external”]）        </li>
<li>伪类选择器（a: hover, li: nth - child）    </li>
</ol>
</li>
<li><p>继承问题</p>
<ul>
<li>可继承： font-size font-family color, ul li  dl  dd  dt;    </li>
<li>不可继承：border padding margin width height ;    </li>
</ul>
</li>
<li><p>优先级</p>
<ul>
<li><p>就近原则：样式定义最近者为准;    </p>
</li>
<li><p>载入样式：以最后载入的定位为准;</p>
</li>
<li><p>id/class/tag优先级为: </p>
<blockquote>
<p>  !important &gt;  id &gt; class &gt; tag         important 比 内联优先级高</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="做一个网站的团队都需要哪些人？"><a href="#做一个网站的团队都需要哪些人？" class="headerlink" title="做一个网站的团队都需要哪些人？"></a>做一个网站的团队都需要哪些人？</h1><ul>
<li><p><strong>产品经理：</strong>设计这个产品，通常就是了解用户的网站需求，画原型图。   </p>
</li>
<li><p><strong>项目经理：</strong>通常是对整个产品有一个整理管理和负责，通常是会代码技术的人来构建整个网站的代码框架，以后网站实现的全面管理。  </p>
</li>
<li><p><strong>UI设计师：</strong>通过原型图画psd设计图的。   </p>
</li>
<li><p><strong>前端工程师：</strong>根据设计图来做静态网页，可能是原生app的IOS和安卓工程师，或者web端的web前端工程师。   </p>
</li>
<li><p><strong>后端工程师：</strong>通常就是做java、asp.net、php的工程师来写后端逻辑的工程师。</p>
</li>
</ul>
<h1 id="html是什么？css是什么？js是什么？"><a href="#html是什么？css是什么？js是什么？" class="headerlink" title="html是什么？css是什么？js是什么？"></a>html是什么？css是什么？js是什么？</h1><ul>
<li><p>html是超文本标记语言，他是做网站时候用的一些文本标记标签，比如div、span等。</p>
</li>
<li><p>css是层叠样式表，是做网站的时候给标签来美化网站的样式，比如说background（背景）、color（字体颜色）、height（高度）、width（宽度）等。</p>
</li>
<li><p>js=javascript是网站中写前后台交互效果、网页动画效果的一种开发语言，比如鼠标点击事件（click）、前后台数据请求（ajax）等。</p>
</li>
</ul>
<h1 id="AJAX技术体系的组成部分有哪些"><a href="#AJAX技术体系的组成部分有哪些" class="headerlink" title="AJAX技术体系的组成部分有哪些"></a>AJAX技术体系的组成部分有哪些</h1><p>HTML、CSS、DOM、XML、xmlHttpRequest、JavaScript</p>
<h1 id="什么是AJAX，为什么要使用AJAX"><a href="#什么是AJAX，为什么要使用AJAX" class="headerlink" title="什么是AJAX，为什么要使用AJAX?"></a>什么是AJAX，为什么要使用AJAX?</h1><ul>
<li><p>什么是AJAX</p>
<p> AJAX是『Asynchronoous JavaScript and XML』的缩写，他是指一种创建交互式网页应用的网页开发结束。AJAX包含下列技术：</p>
<ul>
<li>基于Web标准XHTML+CSS的表示</li>
<li>使用DOM进行动态显示以及交互</li>
<li>使用XML和XSLT进行数据交互及相关操作</li>
<li>使用XMLHttpRequest进行异步数据查询、检索</li>
<li>使用JavaScript将所有的东西绑定在一起</li>
</ul>
</li>
<li><p>AJAX的优势</p>
<ul>
<li><p>通过异步模式，提升了用户体验</p>
</li>
<li><p>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了宽带占用</p>
</li>
<li><p>AJAX引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载</p>
</li>
</ul>
</li>
</ul>
<h1 id="dom里添加、删除、移动、复制、创建节点的方法"><a href="#dom里添加、删除、移动、复制、创建节点的方法" class="headerlink" title="dom里添加、删除、移动、复制、创建节点的方法;"></a>dom里添加、删除、移动、复制、创建节点的方法;</h1><ul>
<li><p>创建新节点</p>
<pre><code>1.创建一个DOM片段
createDocumentFragment()  
2.创建一个具体的元素
createElement_x()    
3.创建一个文本节点createTextNode()                 
</code></pre></li>
<li><p>添加、移除、替换、插入</p>
<pre><code>1.添加
appendChild() 

2.移除
removeChild()

3.替换
replaceChild()

4.插入
insertBefore() 
</code></pre></li>
<li><p>查找</p>
<pre><code>1.通过标签名称
getElementsByTagName_r() 

2.通过元素的Name属性的值
getElementsByName() 

3.通过元素Id，唯一性
getElementById()
</code></pre></li>
</ul>
<h1 id="你对前端界面工程师这个职位是怎么样理解的-它的前景会怎么样"><a href="#你对前端界面工程师这个职位是怎么样理解的-它的前景会怎么样" class="headerlink" title="你对前端界面工程师这个职位是怎么样理解的?它的前景会怎么样?"></a>你对前端界面工程师这个职位是怎么样理解的?它的前景会怎么样?</h1><ul>
<li><p>前端界面工程师理解</p>
<ol>
<li>与交互设计师、视觉设计师协作，根据设计图完成页面制作。</li>
<li>维护及优化网站前端性能。</li>
</ol>
</li>
<li><p>前景</p>
<p>长期以来，国内前端开发在整个软件开发行业内占得比重较小，发展较晚。网站也多倾向于赢利最大化而轻视用户体验。前后端比例悬殊大。近几年来，随着 以用户为中心 的思想普及发展。前端开发呈现出强劲的发展态势，前端开发人员在项目中的重要性日益突出。前端开发人员呈现出严重的人员短缺现象。</p>
</li>
</ul>
<h1 id="js是什么，js和html-的开发如何结合"><a href="#js是什么，js和html-的开发如何结合" class="headerlink" title="js是什么，js和html 的开发如何结合?"></a>js是什么，js和html 的开发如何结合?</h1><p>js是一种基于对象和事件驱动，并具有安全性的脚本语言。可以html的三个地方编写js脚本语言</p>
<ul>
<li>一是在网页文件的标签对中直接编写脚本程序代码；</li>
<li>二是将脚本程序代码放置在一个单独的文件中，在网页文件中引用这个脚本程序语言；</li>
<li>三是将脚本程序代码作为某个元素的事件属性值或超链接的href属性值。</li>
</ul>
<h1 id="如果让你来制作一个访问量很大的大型网站，如何管理所有的css-js-图片文件"><a href="#如果让你来制作一个访问量很大的大型网站，如何管理所有的css-js-图片文件" class="headerlink" title="如果让你来制作一个访问量很大的大型网站，如何管理所有的css/js/图片文件"></a>如果让你来制作一个访问量很大的大型网站，如何管理所有的css/js/图片文件</h1><ul>
<li>把所有的CSS文件都放入一个样式表中,通过把所有的脚本放到一个文件中来减少HTTP请求的方法。js文件也采用同样的方法。</li>
</ul>
<ul>
<li>把所有的背景图像都放到一个图片文件中，然后通过CSS的background-image和background-position属性来显示图片的不同部分。</li>
</ul>
<h1 id="浏览器的内核分别是什么？经常遇到的浏览器兼容性问题有哪些，解决方法是什么？"><a href="#浏览器的内核分别是什么？经常遇到的浏览器兼容性问题有哪些，解决方法是什么？" class="headerlink" title="浏览器的内核分别是什么？经常遇到的浏览器兼容性问题有哪些，解决方法是什么？"></a>浏览器的内核分别是什么？经常遇到的浏览器兼容性问题有哪些，解决方法是什么？</h1><h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p><strong>IE内核:</strong> 360/遨游/搜狗/世界之窗/腾讯TT</p>
<p><strong>非IE内核:</strong> firefox/opera/safari/chrome</p>
<h2 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h2><ol>
<li><p>ie6双倍边距问题</p>
<blockquote>
<p>在使用了float的情况下，不管是向左还是向右都会出现双倍，</p>
</blockquote>
<p>最简单的解决方法就是用display:inline加到css里面去。</p>
</li>
<li><p>文字本身不兼容</p>
<blockquote>
<p>同样是font-size:14px的宋体文字，在不同浏览器下占的空间是不一样的，ie下实际占高16px，下留白3px。ff下实际占高17px，上留白1px,下留白3px。opera下就更不一样了。</p>
</blockquote>
<p>解决方法，给文字设定line-height。确保所有文字都有默认的line-height值，这点很重要，在高度上我们不能容忍1px的差异。</p>
</li>
<li><p>ff下容器高度限定，即容器定义了height之后，容器边框的外形就确定了，不会被内容撑大，而ie下是会被内容撑大，高度限定失效。所以不要轻易给容器定义height。</p>
</li>
<li><p>还讨论内容撑破容器问题，横向上的。</p>
<blockquote>
<p>如果float容器未定义宽度，ff下内容会尽可能撑开容器宽度，ie下则会优先考虑内容折行。</p>
</blockquote>
<p>内容可能撑破的浮动容器需要定义width</p>
</li>
<li><p>浮动的清除，ff下不清除浮动是不行的。</p>
</li>
<li><p>mirrormargin bug。</p>
<blockquote>
<p>当外层元素内有float元素时，外层元素如定义margin-top:14px，将自动生成margin-bootom:14px。padding也会出现类似问题，都是ie6下的特产，该类bug出现的情况较为复杂，远不只这一种出现条件，还没系统整理。</p>
</blockquote>
<p> 外层元素设定border或设定float</p>
</li>
<li><p>吞吃现象，限于篇幅，我就不展开了。</p>
<blockquote>
<p>还是ie6,上下两个div，上面的div设置背景，却发现下面没有设置背景的div也有了背景，这就是吞吃现象。对应上面的背景吞吃线程，还有滚动下边框缺失的线程，</p>
</blockquote>
<p> 解决方案：使用zoom:1,这个zoom好像是专门为解决ie6 bug而生的。</p>
</li>
<li><p>img下的留白</p>
<p>  给imge设置display:block</p>
</li>
<li><p>失去line-height</p>
<pre><code>&lt;div style = &quot;line-height:20px&quot;&gt;&lt;img/&gt; 文字&lt;/div&gt;
</code></pre><blockquote>
<p>很遗憾，在ie6下单行文字line-height效果消失了，原因是<img>这个inline-block元素和inline元素写在一起了</p>
</blockquote>
<p>解决方案： 让img和文字都float起来</p>
</li>
<li><p>链接的hover状态。</p>
<p>   a:hover img{width:300px} 我们让鼠标hover时，链接里包含的图片宽度变化，可以在ie6下无效，ie7和ff下有效。</p>
</li>
<li><p>非链接的hover状态。div：hover{} 这样的样式ie6是不认的，在ie7/ff下才有效果</p>
</li>
<li><p>ie下的overflow:hidden对其下的绝对层postiton:absolute或者相对层positon:absolute，另外ie6支持overfolow-x或者overflow-y的特性，ie7/ff不支持</p>
</li>
<li><p>ff的缺点</p>
<p>   width:100%这个东西在ie里面用很方便，会向上逐层搜索width值，忽视浮动层的影响，ff下搜索至浮动层结束，如此，只能给中间的所有浮动层加width100%才行，累啊，opera这点倒学乖了跟了ie。</p>
</li>
</ol>
<h1 id="css的基本语句构成是什么"><a href="#css的基本语句构成是什么" class="headerlink" title="css的基本语句构成是什么"></a>css的基本语句构成是什么</h1><pre><code>选择器{属性1：值1；属性2：值2；....}
</code></pre><h1 id="前端页面由哪三层构成，分别是什么，作用是什么"><a href="#前端页面由哪三层构成，分别是什么，作用是什么" class="headerlink" title="前端页面由哪三层构成，分别是什么，作用是什么"></a>前端页面由哪三层构成，分别是什么，作用是什么</h1><ul>
<li><p>网页分成三个层次</p>
<p>  结构层、表示层、行为层。</p>
</li>
</ul>
<ul>
<li><p>结构层</p>
<p>   由HTML或XHTML之类的标记语言负责创建。标签，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P标签表达了这样的一种语义，”这是一个文本段”.</p>
</li>
<li><p>表示层</p>
<p>  由css负责创建，css对”如何显示有关内容”的问题作出了回答。</p>
</li>
<li><p>行为层</p>
<p>   负责回答”内容应该如何对事件作出反应”这一问题，这是JavaScript语言和DOM主宰的领域。</p>
</li>
</ul>
<h1 id="Doctype-严格模式与混杂模式，如何触发这两种模式，区分它们有何意义"><a href="#Doctype-严格模式与混杂模式，如何触发这两种模式，区分它们有何意义" class="headerlink" title="Doctype? 严格模式与混杂模式，如何触发这两种模式，区分它们有何意义"></a>Doctype? 严格模式与混杂模式，如何触发这两种模式，区分它们有何意义</h1><ul>
<li><p>Doctype声明位于文档中的最前面的位置，处于标签之前。</p>
<ul>
<li>此标签可告知浏览器文档使用哪种HTML或XHTML规范，</li>
<li>该标签可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的HTML文档。</li>
</ul>
</li>
<li><p>当浏览器厂商开始创建于标准兼容的浏览器时，他们希望确保向后兼容性，为了实现这一点，他们创建了两种呈现模式：<strong>标准模式</strong>和<strong>混杂模式</strong>。</p>
<ul>
<li><p>在标准模式中，浏览器根据规范呈现页面；</p>
</li>
<li><p>在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。混杂模式通常模拟老式浏览器的行为以防止老站点无法工作。</p>
</li>
</ul>
</li>
<li><p>浏览器根据DOCTYPE是否存在以及使用哪种DTD来选择要使用的呈现方法，如果XHTML文档包含形式完整的DOCTYPE，那么它一般以标准模式呈现。</p>
</li>
<li><p>对于HTML4.01文档，包含严格DTD的DOCTYPE常常导致页面以标准模式呈现。<br>包含过渡DTD和URL的DOCTYPE也导致页面以标准模式呈现，但是有过渡DTD而没有URL会导致页面以混杂模式呈现。</p>
</li>
<li><p>DOCTYPE不存在或形式不正确会导致HTML和XHTML文档以混杂模式呈现。</p>
</li>
</ul>
<h1 id="行内、块级元素以及CSS的盒模型有哪些？"><a href="#行内、块级元素以及CSS的盒模型有哪些？" class="headerlink" title="行内、块级元素以及CSS的盒模型有哪些？"></a>行内、块级元素以及CSS的盒模型有哪些？</h1><ul>
<li><p>行内元素：</p>
<blockquote>
<p>a b span I bem img input select strong</p>
</blockquote>
</li>
<li><p>块级元素有</p>
<blockquote>
<p>div ul ol lidl dt dd h1 h2 h3 h4…p</p>
</blockquote>
</li>
<li><p>css盒模型</p>
<blockquote>
<p>margin border padding width</p>
</blockquote>
</li>
</ul>
<h1 id="CSS引入的方式有哪些-link和-import的区别是"><a href="#CSS引入的方式有哪些-link和-import的区别是" class="headerlink" title="CSS引入的方式有哪些? link和@import的区别是?"></a>CSS引入的方式有哪些? link和@import的区别是?</h1><h2 id="css引入的方式"><a href="#css引入的方式" class="headerlink" title="css引入的方式"></a>css引入的方式</h2><ol>
<li><p>使用LINK标签</p>
<p>将样式规则写在css的样式文件中，再以<link>标签引入。</p>
<pre><code>&lt;link rel=stylesheet type= &quot;text/css&quot; href = &quot;example.css&quot;&gt;
</code></pre></li>
<li><p>使用@import引入</p>
<p> 跟link方法很像，但必须放在<style>…</style>中</p>
<pre><code>&lt;STYLE TYPE = &quot;text/css&quot;&gt;
 &lt;!-- 
    @import url(css/example.css);
 --&gt;
&lt;/STYLE&gt;
</code></pre></li>
<li><p>使用STYLE标签</p>
<p>  将样式写在<style>…</style>标签之中。</p>
<pre><code>&lt;STYLE TYPE = &quot;text/css&quot;&gt;
&lt;!-- 
   boby {color:#666;background:#f0f0f0;font-size:12px}
--&gt;
&lt;/STYLE&gt;
</code></pre></li>
<li><p>使用STYLE属性</p>
<p>   将STYLE属性直接加载在个别的元件标签里， </p>
<pre><code>&lt;元件(标签)STYLE=&quot;性质(属性)1&quot;：设定值1;...&gt;
</code></pre></li>
<li><p>使用<span></span>标记引入样式</p>
<pre><code>&lt;span style = &quot;font:12px/20px #000000;&quot;&gt;cnwebshow.com&lt;/span&gt;
</code></pre></li>
</ol>
<h2 id="link和-import区别"><a href="#link和-import区别" class="headerlink" title="link和@import区别"></a>link和@import区别</h2><ol>
<li><p>加载顺序的区别，当一个页面被加载的时候，link引用css会同时被加载，而@import引用的css会等到页面全部被下载完再被加载。</p>
</li>
<li><p>@import可以在css中再次引入其他样式表，比如可以创建一个主样式表，在主样式表中再引入其他的样式表。<strong>这样做有一个缺点，会对网络服务器产生过多的HTTP请求，以前是一个文件，而现在却是两个或更多文件了，服务器的压力增大，服务器的压力增大，浏览量大的网站还是谨慎使用</strong>。</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/30/搭建个人博客/" itemprop="url">
                  搭建个人博客
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-30T09:03:33+08:00" content="2016-08-30">
              2016-08-30
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/30/搭建个人博客/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/30/搭建个人博客/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  之前共用过两个博客平台，一个是做开发时使用的<a href="http://www.cnblogs.com/g-ios/" target="_blank" rel="external">博客园</a>，另一个是做教育工作时用得<a href="www.baidu.com">简书</a>，其中我更喜欢简书。因为最近感觉有必要对自己的博客进行一个大整理，所以就自己搭建了一个个人博客平台，现在我就把搭建这个平台的流程(流程参考的是<a href="http://baixin.io/2015/08/HEXO搭建个人博客/" target="_blank" rel="external">潘柏信大牛的博客</a>)</p>
<h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><ul>
<li><h2 id="安装Node-必须"><a href="#安装Node-必须" class="headerlink" title="安装Node(必须)"></a>安装Node(必须)</h2><p>作用：用来生成静态页面。 到Node.js<a href="https://nodejs.org/en/" target="_blank" rel="external">官网</a>下载相应平台的最新版本，一路安装即可。</p>
</li>
<li><h2 id="安装Git-必须"><a href="#安装Git-必须" class="headerlink" title="安装Git(必须)"></a>安装Git(必须)</h2><p> 作用：把本地的hexo内容提交到gitHub上，安装Xcode就自带有git,我就不多说了。</p>
</li>
<li><h2 id="申请GitHub-必须"><a href="#申请GitHub-必须" class="headerlink" title="申请GitHub(必须)"></a>申请GitHub(必须)</h2><p> 作用：是用来做博客的远程仓库、域名、服务器之类的，github的申请可以在网上搜教程，按教程一步一步配置即可。<strong>怎么与本地hexo建立连接等下讲</strong></p>
</li>
</ul>
<h1 id="安装Hexo环境"><a href="#安装Hexo环境" class="headerlink" title="安装Hexo环境"></a>安装Hexo环境</h1><p>   Node和Git都安装好后，可执行如下命令安装hexo</p>
<pre><code>sudo npm install -g hexo
</code></pre><h1 id="Hexo的基础配置"><a href="#Hexo的基础配置" class="headerlink" title="Hexo的基础配置"></a>Hexo的基础配置</h1><ol>
<li><h2 id="Hexo初始化"><a href="#Hexo初始化" class="headerlink" title="Hexo初始化"></a>Hexo初始化</h2><p>执行init命令初始化hexo到你终端此时所在的目录。</p>
<pre><code>hexo init //结束以后hexo会有如下一堆文件
</code></pre><p>效果图</p>
<p><img src="http://i4.buimg.com/567571/b019939baf9d73ec.png" alt="">   </p>
</li>
<li><h2 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h2><p>cd到你的init目录，执行如下命令，生成静态页面至public\目录</p>
<pre><code>hexo generate (hexo g 也可以)
</code></pre></li>
<li><h2 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h2><pre><code>hexo server (hexo s 也可以)
</code></pre><p> 浏览器输入<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> ,便能看到初始化界面了。</p>
</li>
<li><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>至此，我们搭建出来一个最为基本的一个hexo环境，但现在我们只能本地访问,而且还不知道怎么写博客，部署博客。下面我们讲这部分内容。</p>
</li>
<li><p>另外在做基本配置的时候，碰到的一些问题，在文章的最后面会做整理。</p>
</li>
<li><p><strong>使用hexo命令时，一定要保证终端的路径处于hexo初始化时的路径下</strong></p>
</li>
</ol>
</li>
</ol>
<h1 id="配置GitHub"><a href="#配置GitHub" class="headerlink" title="配置GitHub"></a>配置GitHub</h1><h2 id="建立与你用户名对应的仓库，"><a href="#建立与你用户名对应的仓库，" class="headerlink" title="建立与你用户名对应的仓库，"></a>建立与你用户名对应的仓库，</h2><p>   在自己的Github账号上创建一个仓库，仓库名必须为<strong>【your_user_name.github.io】</strong>，固定写法 </p>
<h2 id="建立关联，"><a href="#建立关联，" class="headerlink" title="建立关联，"></a>建立关联，</h2><p>   我的blog在本地/Users/GG/hexo，有以下文件</p>
<pre><code>_config.yml  node_modules  public  source　
 　　　
db.json  package.json  scaffolds  themes　　      
</code></pre><p>   现在我们需要_config.yml文件，来建立关联,打开_config.yml文件，翻到最下面，改成我这样子的，<strong>注意： : 后面要有空格</strong>，改完后保存</p>
<pre><code>deploy:
type: git
repository: https://github.com/wangliguang/wangliguang.github.io.git
branch: master
</code></pre><h2 id="执行如下命令才能使用git部署"><a href="#执行如下命令才能使用git部署" class="headerlink" title="执行如下命令才能使用git部署"></a>执行如下命令才能使用git部署</h2><pre><code>npm install hexo-deployer-git --save
</code></pre><h2 id="最后执行如下命令部署一下"><a href="#最后执行如下命令部署一下" class="headerlink" title="最后执行如下命令部署一下"></a>最后执行如下命令部署一下</h2><pre><code>hexo deploy (hexo d也可以)
</code></pre><p>   现在在浏览器中输入 <a href="http://wangliguang.github.io/" target="_blank" rel="external">http://wangliguang.github.io/</a> 就行了，我的github的账户叫wangliguang,把这个改成你github的账户名就行了</p>
<h1 id="hexo的写作配置"><a href="#hexo的写作配置" class="headerlink" title="hexo的写作配置"></a>hexo的写作配置</h1><ol>
<li><p>上面我们做的基础配置，只需要做一次就行，但每次我们写作完成以后，需要把我们的文章部署到github服务器上，需要做一下三步。</p>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre></li>
<li><p>hexo一些常用的命令</p>
<pre><code>hexo new &quot;postName&quot; #新建文章
 hexo new page &quot;pageName&quot; #新建页面
 hexo generate #生成静态页面至public目录
 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
 hexo deploy #将.deploy目录部署到GitHub
 hexo help  # 查看帮助
 hexo version  #查看Hexo的版本
</code></pre></li>
<li><p>总结</p>
<ol>
<li><p>至于写作的详情自己按按上面的操作来就型。</p>
</li>
<li><p><strong>使用hexo命令时，一定要保证终端的路径处于hexo初始化时的路径下</strong></p>
</li>
</ol>
</li>
</ol>
<h1 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h1><ol>
<li><p>如果不想用hexo默认的主题，可以在<a href="https://hexo.io/themes/" target="_blank" rel="external">hexo主题</a>进行更换，上面的流程人家说的也比较详细。</p>
</li>
<li><p>主题配置过后，可以先使用hexo s命令在本地查看一下，再通过命令行部署到服务器上</p>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre></li>
<li><p>目前做的比较好的主题是next,<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">官网</a>里面有超级超级详细的说明，强烈推荐。</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://i1.buimg.com/8311/e0cc1a1fed3a4bda.jpg"
               alt="涅槃广广" />
          <p class="site-author-name" itemprop="name">涅槃广广</p>
          <p class="site-description motion-element" itemprop="description">说不定世界上根本就没有偶然，就如一切都是必然那样</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">30</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wangliguang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5987686599/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">涅槃广广</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"gg-ios"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
