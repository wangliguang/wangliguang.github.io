<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Robot Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="说不定世界上根本就没有偶然，就如一切都是必然那样">
<meta property="og:type" content="website">
<meta property="og:title" content="广广的技术博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="广广的技术博客">
<meta property="og:description" content="说不定世界上根本就没有偶然，就如一切都是必然那样">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="广广的技术博客">
<meta name="twitter:description" content="说不定世界上根本就没有偶然，就如一切都是必然那样">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/2/"/>

  <title> 广广的技术博客 - 说不定世界上根本就没有偶然，就如一切都是必然那样 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">广广的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">说不定世界上根本就没有偶然，就如一切都是必然那样</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/响应式编程RAC/" itemprop="url">
                  响应式编程RAC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T15:48:52+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/响应式编程RAC/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/响应式编程RAC/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ReactiveCocoa是什么"><a href="#ReactiveCocoa是什么" class="headerlink" title="ReactiveCocoa是什么"></a>ReactiveCocoa是什么</h1><ul>
<li><p>ReactiveCocoa（简称为<code>RAC</code>）,响应式框架,是由Github开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。</p>
</li>
<li><p>在我们iOS开发过程中，经常会响应某些事件来处理某些业务逻辑，例如按钮的点击，上下拉刷新，网络请求，属性的变化（通过KVO）或者用户位置的变化（通过CoreLocation）。但是这些事件都用不同的方式来处理，比如action、delegate、KVO、callback(回调)等。  </p>
</li>
<li><p>其实这些事件，都可以通过RAC处理，ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中<code>高聚合，低耦合</code>的思想。</p>
</li>
</ul>
<h1 id="这个框架能为我们带来什么样的便利"><a href="#这个框架能为我们带来什么样的便利" class="headerlink" title="这个框架能为我们带来什么样的便利"></a>这个框架能为我们带来什么样的便利</h1><ul>
<li>能使业务逻辑变得更加清晰</li>
<li>大量减少开发代码量</li>
<li>大量使用block块</li>
</ul>
<h1 id="什么时候能用到这个RAC呢"><a href="#什么时候能用到这个RAC呢" class="headerlink" title="什么时候能用到这个RAC呢"></a>什么时候能用到这个RAC呢</h1><ol>
<li><p>当你需要用到代理的时候开始使用它。例如用RAC检测textfiled的实时输入，不需要繁琐的遵守协议、挂代理、实现方法</p>
</li>
<li><p>涉及到点击事件的时候可以用，不需要再addtarget及实现方法。</p>
</li>
<li>还有通知、KVO、回调等。</li>
</ol>
<h1 id="具体怎么使用"><a href="#具体怎么使用" class="headerlink" title="具体怎么使用"></a>具体怎么使用</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><p>创建一个新项目，使用<a href="http://www.jianshu.com/p/24e0a451bca1" target="_blank" rel="external">Cocoapods</a>在项目中导入该框架。将下面的代码复制到Podfile文件然后更新。</p>
<pre><code>use_frameworks!
pod &apos;ReactiveCocoa&apos;, &apos;~&gt; 4.0.4-alpha-4&apos;
</code></pre><p>PS：因为这个框架是采用Swift和OC混编的，所以在Podfile文件的最上面要写上use_frameworks</p>
</li>
<li><p>建pch文件，在pch文件中导入该框架。</p>
<pre><code>#import &quot;ReactiveCocoa.h&quot;
</code></pre></li>
<li><p>利用这个框架实现下面需求，来具体说明他该如何使用。</p>
<ul>
<li>两个输入框内都有内容时，下面的按钮是红色。</li>
<li>两个输入框内都没内容时，下面的按钮是灰色。</li>
</ul>
</li>
<li><p>将下面代码粘贴到项目中的ViewController.m中。</p>
<pre><code>#import &quot;ViewController.h&quot;

#define kMargin 100
#define kScreenWidth [UIScreen mainScreen].bounds.size.width
#define kScreenheight [UIScreen mainScreen].bounds.size.height

@interface ViewController ()

@property (nonatomic,strong) UITextField *passwordTextFiled;

@property (nonatomic,strong) UITextField *accountTextFiled;

@property (nonatomic,strong) UIButton *OKBtn;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    //账号输入框
    self.accountTextFiled = [[UITextField alloc]initWithFrame:CGRectMake(kMargin, kMargin, kScreenWidth-kMargin*2, 50)];
    self.accountTextFiled.placeholder = @&quot;账号&quot;;
    self.accountTextFiled.layer.masksToBounds = YES;
    self.accountTextFiled.layer.cornerRadius = 5;
    self.accountTextFiled.textAlignment = NSTextAlignmentCenter;
    self.accountTextFiled.backgroundColor = [UIColor grayColor];
    [self.view addSubview:self.accountTextFiled];

    //密码输入框
    self.passwordTextFiled = [[UITextField alloc]initWithFrame:CGRectMake(kMargin, kMargin*2, kScreenWidth-kMargin*2, 50)];
    self.passwordTextFiled.backgroundColor = [UIColor grayColor];
    self.passwordTextFiled.placeholder = @&quot;密码&quot;;
    self.passwordTextFiled.textAlignment = NSTextAlignmentCenter;
    self.passwordTextFiled.layer.masksToBounds = YES;
    self.passwordTextFiled.layer.cornerRadius = 5;

    [self.view addSubview:self.passwordTextFiled];

    //确定按钮
    self.OKBtn = [UIButton buttonWithType:UIButtonTypeCustom];
    self.OKBtn.frame = CGRectMake((kScreenWidth-150)/2, kMargin*3, 150, 50);
    self.OKBtn.backgroundColor = [UIColor grayColor];
    [self.view addSubview:self.OKBtn];
    self.OKBtn.layer.masksToBounds = YES;
    self.OKBtn.layer.cornerRadius = 5;
    [self.OKBtn setTitle:@&quot;登录&quot; forState:UIControlStateNormal];

}

@end
</code></pre></li>
</ol>
<p>运行显示如下图：<br> <img src="http://upload-images.jianshu.io/upload_images/1338564-1e6e2436dce366cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p>
<h2 id="不适用RAC来实现上面的需求-不写具体代码了，只写一些过程"><a href="#不适用RAC来实现上面的需求-不写具体代码了，只写一些过程" class="headerlink" title="不适用RAC来实现上面的需求(不写具体代码了，只写一些过程)"></a>不适用RAC来实现上面的需求(不写具体代码了，只写一些过程)</h2><p>1、遵守协议<br>2、挂代理<br>3、实现相应的代理方法<br>4、在方法内写业务逻辑</p>
<h2 id="使用RAC来实现该业务逻辑"><a href="#使用RAC来实现该业务逻辑" class="headerlink" title="使用RAC来实现该业务逻辑"></a>使用RAC来实现该业务逻辑</h2><p><img src="http://upload-images.jianshu.io/upload_images/1338564-1984290c516ae19a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ol>
<li>将上面方法写入ViewController.m中。上面的RAC()其实就是一个宏定义</li>
<li>之前咱们说过RAC能帮助我们大量的减少代码而且逻辑更加清晰，在这里我们不需要在.m中找遵守协议的地方，不需要找控件挂代理，不需要去实现方法。</li>
</ol>
<h2 id="RAC的深入学习"><a href="#RAC的深入学习" class="headerlink" title="RAC的深入学习"></a>RAC的深入学习</h2><p>1、 使用RAC给按钮添加事件</p>
<pre><code>//老办法，还要实现clickBtn方法
[self.OKBtn addTarget:self action:@selector(clickBtn) forControlEvents:UIControlEventTouchUpInside];

//rac方法
[[self.OKBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {

NSLog(@&quot;OK按钮被点击&quot;);

}];
</code></pre><ul>
<li>通过rac_signalForControlEvents给按钮创建一个信号流，然后给这个信号指定一个subscribeNext(订阅者)。如果这个信号流的状态发生改变，订阅者便会受到他的改变。不仅仅button可以，segmentcontrol也同样可以。这样操作。</li>
<li>订阅者受到信息以后的操作都在block中操作。block返回来的参数(id x)其实就是用户所点击的按钮。程序员可以直接将（id x）改为（UIButton *sender）。</li>
<li><p>在找subcribeNext时，会看到这么一个方法</p>
<pre><code>subscribeNext:nil error:nil completed:nil];
</code></pre><p>第一个参数咱已经说过了，另外事件处理有问题会回调这个error这个block块，点击事件执行完毕以后会调用completed这个block块。</p>
</li>
</ul>
<p>2、使用RAC监听TextFiled的输入变化</p>
<pre><code>[self.accountTextFiled.rac_textSignal subscribeNext:^(id x) {

 NSLog(@&quot;%@&quot;,x);

}];
</code></pre><ul>
<li>self.accountTextFiled.rac_textSignal获得到textfiled的信号流。然后给这个信号指定一个（subscribeNext）订阅者。</li>
<li>subscribeNext:^(id x)如果输入框发生变化，订阅者会收到信息，subscribeNext后的参数，便是输入框的内容。</li>
</ul>
<p>3、RAC的过滤效果</p>
<pre><code>[[self.passwordTextfiled.rac_textSignal filter:^BOOL(id value) {

    NSString *text = value;

    BOOL k = [text isEqualToString:@&quot;123&quot;];

    return k;

}] subscribeNext:^(id x) {

    NSLog(@&quot;======&quot;);
}];
</code></pre><ul>
<li>这段代码最终实现的效果是，只有密码输入框输入的值是123的时候，subscribe中的代码才能执行。    </li>
<li>之前我们已经接触过.rac_textSignal(信号流)和subscirbeNext(订阅者)。上面他们之间的filter的block块便是一个过滤器。在subscriber(订阅者)接受到文本信号变化之前，filter(过滤器)会首先拦截到这个信号。在这个filter进行一个判断，如果filter内返回一个yes，subscribe才会收到文本变化的信号流，返回NO，订阅者就不会收到信息。就好比一个母亲在给自己待嫁的女儿找婆家，只有这名母亲相中了，她才会让女儿去相亲。</li>
</ul>
<p>4、改变订阅者收到的信息。</p>
<pre><code>[[self.passwordTextFiled.rac_textSignal map:^id(NSString  *str) {

    return[str boolValue] ? [UIColor clearColor]:[UIColor yellowColor];


}] subscribeNext:^(UIColor *x) {

    self.view.backgroundColor = x;
}];
</code></pre><ul>
<li>实现的功能：输入框有变化时改变self.view的背景颜色</li>
<li>之前我们subscribe收到的都是输入框的文本内容，现在我们要做的就是改变订阅者收到的信息。</li>
<li>在3中我们提到一个filter(过滤器),在这里我们要用一个map(映射)来改变订阅者收到的信息。之前咱们说filter的时候，在订阅者收到信息之前filter会进行一个拦截。map(映射)其实也拦截一下，拦截的时候同样会收到文本框的变化。他两唯一的不同是在map(映射)中返回的是订阅者收到的东西。上面的母亲给女儿找到了一个对象，已经结婚了。老公的第一个月工资发了，老婆（map）拿着。她那里给老公（subscribe）给你买什么东西，老公用什么东西。</li>
</ul>
<p>5、对4优化</p>
<pre><code>//对上面的优化
RAC(self.view, backgroundColor) = [self.passwordTextFiled.rac_textSignal map:^id(NSString *passwordValid){


    return[passwordValid boolValue] ? [UIColor clearColor]:[UIColor yellowColor];

}];
</code></pre><ul>
<li>刚开始咱们使用RAC实现咱们刚开始说的需求时，大家已经见到了RAC()。现在我们做的就是讲map(映射)中返回的颜色。赋值给RAC()中对象控件的对应属性。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>起初咱们说到RAC框架有以下几个特点：<br>1、能够使业务逻辑更清晰<br>2、减少代码量<br>3、大量使用block</p>
<p>最后必须要记住的一点是它能做到这一步最为重要的一个原因是</p>
<blockquote>
<p>将代理、KVO、通知、callBack等一系列事件，做了一个统一管理。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/通知中心、KVC、KVO/" itemprop="url">
                  通知中心、KVC、KVO
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T15:30:05+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/通知中心、KVC、KVO/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/通知中心、KVC、KVO/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   本文的内容可能跟之前相比会比较长，主要因为讲了通知、KVO、KVC三个知识点，但我自认为条理还算清晰。建议学完一个敲一下，再进行下一个知识点的学习。</p>
<h1 id="通知中心"><a href="#通知中心" class="headerlink" title="通知中心"></a>通知中心</h1><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>  是一种一对多的信息广播机制,一个应用程序同时只能有一个NSNotificationCenter(通知中心)对象，因为如果有多个通知，发送通知的时候就不知道是该给谁发送了。</p>
<h2 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h2><p>  delegate和block也属于一种信息传递机制，但这两种都是一对一的，每次执行的方法都不一样，而通知是一对多，只要有地方触发通知，执行的是同一个方法。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><ol>
<li><p>添加一个通知</p>
<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(paySalary) name:@&quot;发工资啦&quot; object:nil];
</code></pre></li>
<li><p>实现添加通知时方法选择器选择的方法</p>
</li>
<li><p>在需要发送通知的类中采用下面方法发送通知，发送成功便会执行步骤二实现的方法</p>
<pre><code>[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;发工资啦&quot; object:nil];
</code></pre></li>
<li><p>移除通知，个人习惯在delloc中释放</p>
<pre><code>[[NSNotificationCenter defaultCenter] postNotificationName:nil object:nil userInfo:nil]; 
</code></pre></li>
</ol>
<p>##代码示例</p>
<ol>
<li><p>在viewController.m的viewDidLoad方法中注册一个通知 </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-368c9b1fa38a70e6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注册通知"></p>
</li>
<li><p>在viewController.m实现在注册通知时方法选择器选择的方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-3bfcde362f56fce7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>在NSNotificationViewController.m中的按钮点击事件方法中发送通知</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-75fe25ec0e2a2160.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送通知"></p>
</li>
<li>在viewController.m中重写delloc方法，在方法移除通知。</li>
</ol>
<p>   <img src="http://upload-images.jianshu.io/upload_images/1338564-f212cb4b2c467146.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移除通知"></p>
<h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><h2 id="What-1"><a href="#What-1" class="headerlink" title="What"></a>What</h2><p>  全称，key valued coding(键值编码)</p>
<h2 id="Where-1"><a href="#Where-1" class="headerlink" title="Where"></a>Where</h2><p>  最常用的是将字典数据转model</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>  特殊情况下，更加简便，下文会进行分析。</p>
<h2 id="How-1"><a href="#How-1" class="headerlink" title="How"></a>How</h2><p>  见代码</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>   <strong>该类中用到的Parent和Children类里面只有.h里面有东西，.m文件内什么都没。详情看最后附录。</strong></p>
<pre><code>//
//  KVCViewController.m
//  NSNotification、KVC、KVO
//
//  Created by GG on 16/1/20.
//  Copyright © 2016年 王立广. All rights reserved.
//

#import &quot;KVCViewController.h&quot;
#import &quot;Parent.h&quot;
@implementation KVCViewController

/*

- (void)viewDidLoad{

    [super viewDidLoad];

    self.title = @&quot;KVC&quot;;

    /*

     * 将字典@{@&quot;name&quot;:@&quot;红红&quot;,@&quot;children&quot;:@{@&quot;name&quot;:@&quot;小红&quot;}}采用多种方式转化为model.

     */

     NSDictionary *dict = @{@&quot;name&quot;:@&quot;红   红&quot;,@&quot;children&quot;:@{@&quot;name&quot;:@&quot;小红&quot;}};

     #pragma mark -------------------老方式-------------------

     //该类中用到的Parent和Children类里面只有.h里面有东西，.m文件内什么都没。详情看最后附录。

     Parent *oldWayparent = [Parent new];

     //给parent起名字
     oldWayparent.name = dict[@&quot;name&quot;];

     Children *children1 = [Children new];

     children1.name = dict[@&quot;children&quot;][@&quot;name&quot;];

     //给parent的孩子起名字
     oldWayparent.children = children1;

     NSLog(@&quot;oldWay ======= %@的孩子叫做%@&quot;,oldWayparent.name,oldWayparent.children.name);

     #pragma mark -------------------KVC 方式-------------------

     /*

      * 采用kvc将字典转化为model的三种方式

      * 方式一 : 存值：[id setValue:&lt;#value#&gt; forKey:&lt;#key#&gt;];

                取值：[id valueForKey:&lt;#key#&gt;];

                给id对象的key属性赋值value。此处key的值一定必须要和在id对象key属性一模一样。

      * 方式二 : 存值：[id setValue:&lt;#value#&gt; forKeyPath:&lt;#key.key#&gt;];

                取值：[id valueForKeyPath:&lt;#key#&gt;];

                同样是给id对象的相应属性赋值，但此时后面将不再直接给出键，而是按照键值路径来查找出相应的键，系统会按『.』,自动进入对象内部，查找对象属性。坑①。

      * 方式三 : [id setValuesForKeysWithDictionary:&lt;#NSDictionary#&gt;];

      上面的两种方式都需要取出来字典中的值，赋值给对象的相应属性。如果该对象要是有八九十来个属性，就要写八九十来行代码。这样太麻烦。碰到这样情况直接采用方式三便可。直接将整个字典作为参数传进来，便可将字典转化为model对象。

      * 温馨提示 ： 这三种方式并不是完全独立，不是不可混合使用的，要根据字典内容做决定，接下来我用上面的那个字典做一下简单分析。

      */

      Parent *kvcWayParent = [Parent new];  

      //采用方式一给属性赋值，如果属性是用@property声明的可以直接用self.name = dict[@&quot;name&quot;]，如果没有用@property，而是在大括号内声明的属性要用这种方式。

     [kvcWayParent setValue:dict[@&quot;name&quot;] forKey:@&quot;name&quot;];

     Children *children2 = [Children new];

     [kvcWayParent setValue:children2 forKey:@&quot;children&quot;];

     /*
      * 采用方式二给属性赋值。此时要注意以下两点：
      *
      * 1、是forKeyPath，不是forkey
        2、forkeyPath后childeren一定必须要和kvcWayParent里面的children属性名字一样，它后面的name必须一定要和children里面的name属性名一样。

      */

      [kvcWayParent setValue:dict[@&quot;children&quot;][@&quot;name&quot;] forKeyPath:@&quot;children.name&quot;];

      NSLog(@&quot;kvcWay ======= %@的孩子叫做%@&quot;,kvcWayParent.name,kvcWayParent.children.name);

      Parent *newKvcWayParent = [Parent new];

      /* 
       * 采用第三种方式将字典转化为model,此时我们要注意以下几点：
       * 1、字典里面有什么东西，挑出我们需要用的（一般都需要）在model类中给声明出来。例如字典里有name,我就要在model类中声明该属性。
       * 2、声明属性的时候要注意匹配数据类型。如果是数字，建议声明成NSNumber,因为在进行编码的时候，kvc会自动将字典中的数字转化为NSNumber类型。

       */
       [newKvcWayParent setValuesForKeysWithDictionary:dict];

       //坑②
       NSLog(@&quot;newsKvcWay ======= %@你太伟大了%@&quot;,newKvcWayParent.name,newKvcWayParent.children);    

 }

 @end
</code></pre><p>   坑①： 如果model类中还有其他自定义对象，在赋值之前一定要先给该自定义对象赋值，在给其属性赋值。如果直接按下面的方式赋值，是错误的。</p>
<pre><code>Parent *testParent = [Parent new];
//给children.name赋值之前没有给children赋值
[testParent setValue:dict[@&quot;children&quot;][@&quot;name&quot;] forKeyPath:@&quot;children.name&quot;];
</code></pre><p>   坑②：最后一句输出如下：</p>
<pre><code>&gt; newsKvcWay =======   红红你太伟大了  {

    name = &quot;\U5c0f\U7ea2&quot;;
  }
</code></pre><p>   出现这种情况的原因是我用一个Children的对象来接受字典里面的字典了。</p>
<h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><h2 id="What-2"><a href="#What-2" class="headerlink" title="What"></a>What</h2><p>Key-Value Observing（键值观察），它提供一种机制，当指定的对象的属性被修改后（<strong>指的是属性的内存地址被修改</strong>），则对象就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。</p>
<h2 id="Where-2"><a href="#Where-2" class="headerlink" title="Where"></a>Where</h2><p>需要监听某对象某一属性的变化时</p>
<h2 id="Why-1"><a href="#Why-1" class="headerlink" title="Why"></a>Why</h2><p> 能够实时监听对象属性的变化</p>
<h2 id="How-2"><a href="#How-2" class="headerlink" title="How"></a>How</h2><ol>
<li><p>采用下面这个方法给属性添加观察者,各参数详情见下文</p>
<pre><code>- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;
</code></pre></li>
<li><p>观察者实现下面方法，如果监听的属性发生变化，便会调用该方法。</p>
<pre><code>- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSString*, id&gt; *)change context:(nullable void *)context;
</code></pre></li>
<li><p>适时调用下面方法移除观察者,个人习惯在delloc中释放。</p>
<pre><code>- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context;
</code></pre></li>
</ol>
<h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><pre><code>//
//  KVOViewController.m
//  NSNotification、KVC、KVO
//
//  Created by GG on 16/2/12.
//  Copyright © 2016年 王立广. All rights reserved.
//

#import &quot;KVOViewController.h&quot;
#import &quot;Parent.h&quot;
@interface KVOViewController ()
{
    Parent *parent;

    UILabel *label;
}
@end

@implementation KVOViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.title = @&quot;KVO&quot;;

    parent = [Parent new];

    Children *children = [Children new];

    parent.children = children;

    //给parent的起名字，给parent的children起名字
    parent.children.name = @&quot;闪闪&quot;;
    parent.name = @&quot;小闪&quot;;

    /*
     * 监听parent的children的名字

     * observer: 设置观察者

     * forkeyPath: 设置对象的属性，要注意这里传入的是字符串。在这里我传入的是&quot;children.name&quot;。也就是说我要监听的是parent对象的children属性的name属性。所以说KVO是在KVC的基础上实现的。

     * options: 
         NSKeyValueObservingOptionNew：当options中包括了这个参数的时候，观察者收到的change参数中就会包含NSKeyValueChangeNewKey和它对应的值，也就是说，观察者可以得知这个property在被改变之后的新值。

         NSKeyValueObservingOptionOld：和NSKeyValueObservingOptionNew的意思类似，当包含了这个参数的时候，观察者收到的change参数中就会包含NSKeyValueChangeOldKey和它对应的值。

         NSKeyValueObservingOptionInitial：当包含这个参数的时候，在addObserver的这个过程中，就会有一个notification被发送到观察者那里，反之则没有。

         NSKeyValueObservingOptionPrior：当包含这个参数的时候，在被观察的property的值改变前和改变后，系统各会给观察者发送一个change notification；在property的值改变之前发送的change notification中，change参数会包含NSKeyValueChangeNotificationIsPriorKey并且值为@YES，但不会包含NSKeyValueChangeNewKey和它对应的值。

         可以指定多个NSKeyValueObservingOptions，将他们用“或”连接后，作为options参数。常用的就前三种，第四种知道便可。目前我们只需知道前三种便可。

      * content: 可以将任意对象作为参数在这里传递。

     */
    [parent addObserver:self forKeyPath:@&quot;children.name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld | NSKeyValueObservingOptionInitial context:nil];

    label = [[UILabel alloc]initWithFrame:CGRectMake(100, 200, kScreenWidth-200, 40)];
    label.text = [NSString stringWithFormat:@&quot;%@的孩子名字叫做%@&quot;,parent.name,parent.children.name];
    [self.view addSubview:label];

    UITextField *textfiled = [[UITextField alloc]initWithFrame:CGRectMake(100, 300, kScreenWidth-200, 40)];
    textfiled.placeholder = @&quot;重新输入孩子的名字&quot;;
    [textfiled addTarget:self action:@selector(textfiledChanged:) forControlEvents:UIControlEventEditingChanged];
    [self.view addSubview:textfiled];

}

- (void)textfiledChanged:(UITextField *)textfiled{

    parent.children.name = textfiled.text;
}

/*
 * 如果监听的属性发生了变化，调用该方法。

 * keyPath: 传进来发生变化的属性。

 * object: 所监听的对象

 * change：是一个字典，包含了与property的值变化相关的信息。其中可能会有这样几个键值对，

    NSKeyValueChangeKindKey：这是change中永远会包含的键值对，它的值时一个NSNumber对象，具体的数值有NSKeyValueChangeSetting(对属性进行赋值操作)、NSKeyValueChangeInsertion(对属性进行插入操作)、NSKeyValueChangeRemoval(对属性进行移除操作)、NSKeyValueChangeReplacement(对属性进行替换操作)这几个，其中后三个是针对于一对多关系的。

    NSKeyValueChangeNewKey：只有当addObserver的时候在optional参数中加入NSKeyValueObservingOptionNew，这个键值对才会被change参数包含；它表示这个property改变后的新值。

    NSKeyValueChangeNewOld：只有当addObserver的时候在optional参数中加入NSKeyValueObservingOptionOld，这个键值对才会被change参数包含；它表示这个property改变前的值。

    NSKeyValueChangeIndexesKey：当被观察的property是一个ordered to-many relationship时，这个键值对才会被change参数包含；它的值是一个NSIndexSet对象。

    NSKeyValueChangeNotificationIsPriorKey：只有当addObserver的时候在optional参数中加入NSKeyValueObservingOptionPrior，这个键值对才会被change参数包含；它的值是@YES。

    用[change objectForKey:@&quot;old&quot;]获取变化前的值
    用[change objectForKey:@&quot;new&quot;]获取变化后的值

 *
 */
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context{

    label.text = [NSString stringWithFormat:@&quot;%@的孩子叫做%@&quot;,parent.name, [change objectForKey:@&quot;new&quot;]];

    NSLog(@&quot;上次的名字是%@&quot;,[change objectForKey:@&quot;old&quot;]);

}

- (void)dealloc{

    [parent removeObserver:self forKeyPath:@&quot;children.name&quot;];

}

@end
</code></pre><p>1、 添加观察者时的options参数，目前我们最为常用的就是前三种，其他两种可不做深究。<br>2、属性发生变化，调用相应的方法，change字典参数最常用的两个键是『new』和『old』,其他暂不考虑。</p>
<h1 id="附录-Parent-h和Children-h"><a href="#附录-Parent-h和Children-h" class="headerlink" title="附录 Parent.h和Children.h"></a>附录 Parent.h和Children.h</h1><h2 id="Parent-h，-m里什么都没有"><a href="#Parent-h，-m里什么都没有" class="headerlink" title="Parent.h，.m里什么都没有"></a>Parent.h，.m里什么都没有</h2><pre><code>#import &lt;Foundation/Foundation.h&gt;
#import &quot;Children.h&quot;

@interface Parent : NSObject

@property (nonatomic,copy) NSString *name;

@property (nonatomic,retain) Children *children;

@end
</code></pre><h2 id="Children-h-m里什么都没有"><a href="#Children-h-m里什么都没有" class="headerlink" title="Children.h .m里什么都没有"></a>Children.h .m里什么都没有</h2><pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface Children : NSObject

@property (nonatomic,copy) NSString *name;

@end
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/网络协议TCP-IP、HTTP/" itemprop="url">
                  网络协议TCP/IP、HTTP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T15:22:01+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/14/网络协议TCP-IP、HTTP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/14/网络协议TCP-IP、HTTP/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><p>两台计算机要实现通讯必须遵守同一个规则，这就好比两个人交流，只会英文和只会中文的因为没有共同的语言(规则)根本就无法沟通，要使两台计算机能够正常通讯，两者必须遵守同样的规则，而这个规则就是就是网络协议。</p>
<p> 那么这个规则，也就是计算机通信的网络协议是谁规定的呢，国际上有这么一个组织<strong>ISO(国际标准化组织)，他定义了网络协议基本框架，叫做OSI模型</strong>。两台电脑在进行通讯时，要考虑很多很多的问题，例如A电脑如何找到B电脑，A电脑给B电脑什么类型的数据，A电脑怎么能收到B电脑的反馈等等，这些问题都需要一个标准，为了能够给以上问题分类设置标准，OSI模型进行了层次划分，每一层都有相应的协议去解决相应的问题。七层标准模型，如下：</p>
<ul>
<li>应用层 </li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层 </li>
<li>数据链路层</li>
<li>物理层。</li>
</ul>
<h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><h2 id="什么是TCP-IP协议"><a href="#什么是TCP-IP协议" class="headerlink" title="什么是TCP/IP协议"></a>什么是TCP/IP协议</h2><ul>
<li><p><strong>OSI网络通讯协议模型，是一个参考模型，参考于他的TCP/IP协议才是目前网络上通用的网络通讯协议，</strong>接下来先了解一下TCP/IP协议。</p>
</li>
<li><p>通常所说的TCP/IP协议，其实是一个协议集合，这个集合里面包含了网络通讯所需的所有协议，里面不仅有TCP(传输控制协议)、IP(网际协议)，还有UDP、ICMP、RIP、TELNET、FTP、SMTP、ARP、TFTP等许多协议，但因为TCP协议和IP协议是保证数据完整传输的两个基本的重要协议，所以该协议集合就被命名为TCP/IP协议了。</p>
</li>
<li><p>TCP/IP协议的制定是参考于OSI模型的，但并没有严格按照OSI规定的七层去划分，而是划分了四层，</p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1338564-a0a2a7fb67f60f59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OSI和TCP/IP对比图"></p>
</li>
<li><p>目前我们已经知道TCP/IP协议分为四个层次，我举个例子简单说明一下各个层的作用，拿寄送邮件举例，A寄邮件给B，A关心的是用什么格式写什么内容给B(应用层内容)，是寄挂号信(信件丢失会赔偿)还是寄平信(信件丢失不赔偿)(应用层内容)，A是不会关注邮件传送过程中采用了哪条路线，邮递员是如何把信地道B手里的(网络层，网络接口层)。接下来再详细讲一下应用层和传输层。</p>
<ol>
<li><p><strong>传输层</strong> 传输层有多个协议，但最主要的是<code>TCP和UDP协议。两者的区别在与TCP协议需要接收方反馈，传输更可靠，而UDP协议虽然不需要反馈，但传输的速率比较高。</code>，至于具体采用哪种方式，需要具体问题具体分析，在不可靠的网络传送过程中一般选择TCP传送方式，在讲求效率或者不在乎传输失误的情况下可以选择UDP方式来提高传输速率。</p>
</li>
<li><p><strong>应用层</strong> 应用层协议有很多，每一个协议代表一种类型的服务。<br><code>HTTP协议，万维网服务</code><br><code>FTP协议，文件传送服务</code><br><code>POP3协议，邮件服务</code></p>
</li>
</ol>
</li>
</ul>
<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="HTTP介绍"><a href="#HTTP介绍" class="headerlink" title="HTTP介绍"></a>HTTP介绍</h2><p>   HTTP协议，属于应用层，是一种超文本传输协议。</p>
<h2 id="HTTP协议的作用"><a href="#HTTP协议的作用" class="headerlink" title="HTTP协议的作用"></a>HTTP协议的作用</h2><ol>
<li><p>规定客户端和服务器之间的数据传输格式</p>
</li>
<li><p>让客户端和服务器能有效地进行数据沟通</p>
</li>
</ol>
<h2 id="为什么要选择使用HTTP协议"><a href="#为什么要选择使用HTTP协议" class="headerlink" title="为什么要选择使用HTTP协议"></a>为什么要选择使用HTTP协议</h2><ol>
<li><p>支持客户/服务器模式。</p>
</li>
<li><p>简单快速。客户向服务器请求服务时，只需传送请求方法和路径，客户端与服务器之间的请求方法常用的有GET、HEAD、POST。另外，由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快因为HTTP协议简单，所以HTTP服务器的程序规模小，因而通信速度很快。</p>
</li>
<li><p>灵活。HTTP允许传输任意类型的数据，正在传输的类型由Content-Type加以标记。</p>
</li>
<li><p>无连接。限制每次链接只处理一个请求，服务器对客户端的请求做出响应后，马上断开链接，这种方式可以节省传输时间。</p>
</li>
<li><p>无状态。HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
</li>
</ol>
<h2 id="采用HTTP向服务器请求数据常用方式"><a href="#采用HTTP向服务器请求数据常用方式" class="headerlink" title="采用HTTP向服务器请求数据常用方式"></a>采用HTTP向服务器请求数据常用方式</h2><ol>
<li><p>GET请求。get是获取数据的意思，数据以明文在URL中传递，受限于URL长度，所以传输数据量比较小。比如我在百度上搜索FMDB，那么他相应的url便是<a href="https://www.baidu.com/s?ie=UTF-8&amp;wd=FMDB" target="_blank" rel="external">https://www.baidu.com/s?ie=UTF-8&amp;wd=FMDB</a>，我要搜索的内容在url是可见的，如果我要搜索的内容过长，便会产生异常，不信的话，你可以将FMDB换成一个比较长的字符看下效果。</p>
</li>
<li><p>POST请求。post是向服务器提交数据的意思，提交的数据以实际内容形式存放到消息头中进行传递，无法在浏览器url中查看到，大小没有限制。在请求URL后面以?的形式跟上发给服务器的参数，多个参数之间用&amp;隔开，比如<a href="http://ww.test.com/login?username=123&amp;pwd=234&amp;type=JSON" target="_blank" rel="external">http://ww.test.com/login?username=123&amp;pwd=234&amp;type=JSON</a></p>
</li>
<li><p>HEAD请求：请求头信息，并不返回请求数据体，而只返回请求头信息，常用用于在文件下载中取得文件大小、类型等信息。</p>
</li>
<li><p>GET和POST的选择</p>
<ul>
<li>如果要传递大量数据，比如文件上传，只能用POST请求</li>
<li>GET的安全性比POST要差些，如果包含机密\敏感信息，建议用POST</li>
<li>如果仅仅是索取数据（数据查询），建议使用GET</li>
<li>如果是增加、修改、删除数据，建议使用POST   </li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/JSON和XML/" itemprop="url">
                  JSON和XML
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-13T17:48:30+08:00" content="2016-09-13">
              2016-09-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/13/JSON和XML/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/13/JSON和XML/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h2><ol>
<li><p>XML是一种使信息具有结构性的标记语言，很类似HTML，XML文档是一种树结构，它从”根部”开始，然后扩展到”枝叶”。</p>
</li>
<li><p>XML被设计为具有自我描述性，例如：</p>
<pre><code>&lt;note&gt;
&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre><p>上面的这条便签就具有自我描述性,它拥有标题以及留言，同时包含了发送者和接受者的信息。阅读上面代码可知，这是John发送给George，主题为Reminder,内容为Dont’t forget the metting!的一条便签。</p>
</li>
<li><p>XML标签没有被预定义，需要自行定义标签。上例中的标签其实没有在任何XML标准中定义过，比如<to>和<from>,这些标签是由文档的创作者发明的。</from></to></p>
</li>
<li><p>XML的设计宗旨是传输数据，而非显示数据。XML自身是无作为的，也就是说XML文档不会做任何事情，他仅仅是包装在XML标签中纯粹的信息。我们需要编写软件或者程序，才能传送、接受和显示这个文档。</p>
</li>
</ol>
<h2 id="与HTML的主要差异"><a href="#与HTML的主要差异" class="headerlink" title="与HTML的主要差异"></a>与HTML的主要差异</h2><ol>
<li><p>XML不是HTML的替代</p>
</li>
<li><p>XML被设计为传输和存储数据，其焦点是数据的内容</p>
</li>
<li><p>HTML被设计用来显示数据，其焦点是数据的外观</p>
</li>
<li><p>HTML旨在显示信息，而XML旨在传输信息</p>
</li>
<li><p>在HTML中使用的标签是预定义的，HTML文档只能使用HTML标准中定义过的标签，XML允许创作者定义自己的标签。</p>
</li>
</ol>
<h2 id="XML的用途"><a href="#XML的用途" class="headerlink" title="XML的用途"></a>XML的用途</h2><ol>
<li><p>XML把数据从HTML分离。如果你需要在HTML文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑HTML，而通过XML，数据能够存储在独立的XML文件中。这样就可以专注于使用HTML进行布局和显示，并确保修改底层数据不再需要对HTML进行任何的改变。</p>
</li>
<li><p>简化数据的共享、传输、变更。因为XML数据以纯文本格式进行存储，是一种独立于软件和硬件的数据存储方法，这给不同应用程序数据的共享、不同系统之间数据的传输、平台的变更时数据的转移带来了极大的便利。</p>
</li>
</ol>
<h2 id="XML的写法"><a href="#XML的写法" class="headerlink" title="XML的写法"></a>XML的写法</h2><p>其实大家之前都写过XML。为什么这么说呢，因为之前咱们写的<code>plis</code>文件的底层便是是XML写的。</p>
<p>在Xcode中新建一个plist文件，并右键plist文件open as -&gt; source code，然后将下面内复制粘贴到该文件的<code>plist</code>标签中，</p>
<pre><code>&lt;dict&gt;
&lt;key&gt;Books&lt;/key&gt;
&lt;array&gt;
&lt;dict&gt;
&lt;key&gt;name&lt;/key&gt;
&lt;string&gt;与时间做朋友&lt;/string&gt;
&lt;key&gt;price&lt;/key&gt;
&lt;integer&gt;56&lt;/integer&gt;
&lt;/dict&gt;
&lt;dict&gt;
&lt;key&gt;name&lt;/key&gt;
&lt;string&gt;我想和这个世界谈谈&lt;/string&gt;
&lt;key&gt;price&lt;/key&gt;
&lt;integer&gt;40&lt;/integer&gt;
&lt;/dict&gt;
&lt;dict&gt;
&lt;key&gt;name&lt;/key&gt;
&lt;string&gt;互联网+&lt;/string&gt;
&lt;key&gt;price&lt;/key&gt;
&lt;integer&gt;50&lt;/integer&gt;
&lt;/dict&gt;
&lt;/array&gt;
&lt;/dict&gt;
</code></pre><p>然后在右键plist文件open as -&gt; source code,效果如下</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/1338564-a4d5d451aae221a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ol>
<li>咱们已经了解XML的标签是能够自定义的，在上面的那些代码中，dict、array、key、string、integer等标签都是Xcode自定义的，比如xcode规定dict代表字典，array代表数组，既然人家规定的，我们必须按照他们的规定来，要不然在Xcode中不能读取该文件。</li>
<li><p>如果脱离Xcode软件，那么这些标签可以按照自己的喜好随意取，只要自己能分辨出来即可。</p>
</li>
<li><p><a href="http://www.w3school.com.cn/xml/xml_syntax.asp" target="_blank" rel="external">点击详细写法</a></p>
</li>
</ol>
<h1 id="JSON（JavaScript-Object-Notation）"><a href="#JSON（JavaScript-Object-Notation）" class="headerlink" title="JSON（JavaScript Object Notation）"></a>JSON（JavaScript Object Notation）</h1><h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><ol>
<li><p>JSON是轻量级的文本数据交换格式</p>
</li>
<li><p>JSON具有自我描述性，易理解</p>
</li>
<li><p>JSON采用完全独立于语言的文本格式</p>
</li>
<li><p>JSON成为理想的数据交换语言</p>
</li>
</ol>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><pre><code>{
&quot;programmers&quot;: [{
&quot;firstName&quot;: &quot;Brett&quot;,
&quot;lastName&quot;: &quot;McLaughlin&quot;,
&quot;email&quot;: &quot;aaaa&quot;
}, {
&quot;firstName&quot;: &quot;Jason&quot;,
&quot;lastName&quot;: &quot;Hunter&quot;,
&quot;email&quot;: &quot;bbbb&quot;
}, {
&quot;firstName&quot;: &quot;Elliotte&quot;,
&quot;lastName&quot;: &quot;Harold&quot;,
&quot;email&quot;: &quot;cccc&quot;
}],

&quot;authors&quot;: [{
&quot;firstName&quot;: &quot;Isaac&quot;,
&quot;lastName&quot;: &quot;Asimov&quot;,
&quot;genre&quot;: &quot;sciencefiction&quot;
}, {
&quot;firstName&quot;: &quot;Tad&quot;,
&quot;lastName&quot;: &quot;Williams&quot;,
&quot;genre&quot;: &quot;fantasy&quot;
}, {
&quot;firstName&quot;: &quot;Frank&quot;,
&quot;lastName&quot;: &quot;Peretti&quot;,
&quot;genre&quot;: &quot;christianfiction&quot;
}],
</code></pre><ol>
<li>数据一般在键值对中</li>
<li>数据由逗号分割</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
<li><a href="http://www.w3school.com.cn/json/json_syntax.asp" target="_blank" rel="external">点击详细写法</a></li>
</ol>
<h2 id="在JSON中数据类型"><a href="#在JSON中数据类型" class="headerlink" title="在JSON中数据类型"></a>在JSON中数据类型</h2><pre><code>&quot;&quot; : 用字符串接收  
12 : 用NSNumber接受 
</code></pre><h2 id="与XML的比较"><a href="#与XML的比较" class="headerlink" title="与XML的比较"></a>与XML的比较</h2><ol>
<li><p>在可读性方面，JSON和XML的数据可读性基本相同。JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，很难分出胜负。</p>
</li>
<li><p>在可扩展性方面，XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。</p>
</li>
<li><p>在编码难度方面，XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有json.org提供的工具，但是JSON的编码明显比XML容易许多，即使不借助工具也能写出JSON的代码，可是要写好XML就不太容易了。</p>
</li>
<li><p>在解码难度方面，XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。这一点XML输的真是没话说。</p>
</li>
<li><p>在流行度方面，XML已经被业界广泛的使用，而JSON才刚刚开始。</p>
</li>
<li><p>JSON和XML同样拥有丰富的解析手段。</p>
</li>
<li><p>JSON相对于XML来讲，数据的体积小。</p>
</li>
<li><p>JSON与JavaScript的交互更加方便。</p>
</li>
<li><p>JSON对数据的描述性比XML较差。</p>
</li>
<li><p>JSON的速度要远远快于XML</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/H5杂项面试题/" itemprop="url">
                  H5杂项面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T14:39:59+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/H5面试题/" itemprop="url" rel="index">
                    <span itemprop="name">H5面试题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/H5杂项面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/H5杂项面试题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="你能描述一下渐进增强和优雅降级之间的不同吗"><a href="#你能描述一下渐进增强和优雅降级之间的不同吗" class="headerlink" title="你能描述一下渐进增强和优雅降级之间的不同吗?"></a>你能描述一下渐进增强和优雅降级之间的不同吗?</h1><ul>
<li><p><strong>优雅降级</strong></p>
<p>  Web站点在所有新式浏览器中都能正常工作，如果用户使用的 是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功 能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</p>
</li>
<li><p><strong>渐进增强</strong></p>
<p>  从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p>
</li>
</ul>
<h1 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h1><ul>
<li><p>一个程序至少有一个进程，一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
</li>
<li><p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
</li>
<li><p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
</li>
<li><p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
</li>
</ul>
<h1 id="说说你对语义化的理解？"><a href="#说说你对语义化的理解？" class="headerlink" title="说说你对语义化的理解？"></a>说说你对语义化的理解？</h1><ul>
<li><p>去掉或样式丢失的时候能让页面呈现清晰的结构：html本身是没有表现的，我们看到例如h1是粗体，字体大小2em，加 粗；strong是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面 呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和 语义化的HTML结构是不可分割的。</p>
</li>
<li><p>屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页。</p>
</li>
<li><p>PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）。</p>
</li>
<li><p>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。</p>
</li>
<li><p>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p>
</li>
</ul>
<h1 id="你如何对网站的文件和资源进行优化？"><a href="#你如何对网站的文件和资源进行优化？" class="headerlink" title="你如何对网站的文件和资源进行优化？"></a>你如何对网站的文件和资源进行优化？</h1><p>   期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。</p>
<h1 id="为什么利用多个域名来提供网站资源会更有效？"><a href="#为什么利用多个域名来提供网站资源会更有效？" class="headerlink" title="为什么利用多个域名来提供网站资源会更有效？"></a>为什么利用多个域名来提供网站资源会更有效？</h1><ol>
<li><p>CDN缓存更方便</p>
</li>
<li><p>突破浏览器并发限制（一般每个域名建立的链接不超过6个）</p>
</li>
<li><p>Cookieless，节省带宽，尤其是上行带宽一般比下行要慢</p>
</li>
<li><p>对于UGC的内容和主站隔离，防止不必要的安全问题(上传js窃取主站cookie之类的)。正是这个原因要求用户内容的域名必须不是自己主站的子域名，而是一个完全独立的第三方域名。</p>
</li>
<li><p>数据做了划分，甚至切到了不同的物理集群，通过子域名来分流比较省事。这个可能被用的不多。</p>
<p>PS: 关于Cookie的问题，带宽是次要的，安全隔离才是主要的。关于多域名，也不是越多越好，虽然服务器端可以做泛解释，浏览器做dns解释也是耗时间的，而且太多域名，如果要走https的话，还有要多买证书和部署的问题。</p>
</li>
</ol>
<h1 id="请说出三种减少页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）"><a href="#请说出三种减少页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）" class="headerlink" title="请说出三种减少页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）"></a>请说出三种减少页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）</h1><ol>
<li>优化图片</li>
<li>图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）</li>
<li>优化CSS（压缩合并css，如margin-top,margin-left…)</li>
<li>网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）</li>
<li>标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速 度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏 览体验也更好了。）</li>
<li>减少http请求（合并文件，合并图片）。</li>
</ol>
<h1 id="如果你参与到一个项目中，发现他们使用Tab来缩进代码，但是你喜欢空格，你会怎么做？"><a href="#如果你参与到一个项目中，发现他们使用Tab来缩进代码，但是你喜欢空格，你会怎么做？" class="headerlink" title="如果你参与到一个项目中，发现他们使用Tab来缩进代码，但是你喜欢空格，你会怎么做？"></a>如果你参与到一个项目中，发现他们使用Tab来缩进代码，但是你喜欢空格，你会怎么做？</h1><ol>
<li>建议这个项目使用像<a href="http://editorconfig.org/" target="_blank" rel="external">EditorConfig</a> 之类的规范</li>
<li>为了保持一致性，接受项目原有的风格</li>
<li>直接使用VIM的retab命令</li>
</ol>
<h1 id="请写一个简单的幻灯效果页面"><a href="#请写一个简单的幻灯效果页面" class="headerlink" title="请写一个简单的幻灯效果页面"></a>请写一个简单的幻灯效果页面</h1><p>如果不使用JS来完成，可以加分。（如：纯CSS实现的幻灯片效果）</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;style&gt;
    img {
      display: none;
      width: 100px;
      height: 100px;
    }

    input:checked + img {
      display: block;
    }

    input {
      position: absolute;
      left: -9999px;
    }

    label {
      cursor: pointer;
    }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;cont&quot;&gt;
      &lt;input id=&quot;img1&quot; name=&quot;img&quot; type=&quot;radio&quot; checked=&quot;checked&quot;&gt;
      &lt;img src=&quot;a.png&quot;&gt;
      &lt;input id=&quot;img2&quot; name=&quot;img&quot; type=&quot;radio&quot;&gt;
      &lt;img src=&quot;b.png&quot;&gt;
    &lt;/div&gt;
    &lt;div id=&quot;nav&quot;&gt;
      &lt;label for=&quot;img1&quot;&gt;第一张&lt;/label&gt;
      &lt;label for=&quot;img2&quot;&gt;第二张&lt;/label&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h1 id="你都使用哪些工具来测试代码的性能？"><a href="#你都使用哪些工具来测试代码的性能？" class="headerlink" title="你都使用哪些工具来测试代码的性能？"></a>你都使用哪些工具来测试代码的性能？</h1><p>Profiler,<a href="http://jsperf.com/nexttick-vs-setzerotimeout-vs-settimeout" target="_blank" rel="external">JSPerf</a>,Dromaeo。</p>
<h1 id="如果今年你打算熟练掌握一项新技术，那会是什么？"><a href="#如果今年你打算熟练掌握一项新技术，那会是什么？" class="headerlink" title="如果今年你打算熟练掌握一项新技术，那会是什么？"></a>如果今年你打算熟练掌握一项新技术，那会是什么？</h1><p>nodejs，html5，css3，less等。</p>
<h1 id="请谈一下你对网页标准和标准制定机构重要性的理解。"><a href="#请谈一下你对网页标准和标准制定机构重要性的理解。" class="headerlink" title="请谈一下你对网页标准和标准制定机构重要性的理解。"></a>请谈一下你对网页标准和标准制定机构重要性的理解。</h1><p>w3c存在的意义就是让浏览器兼容性问题尽量小，首先是他们对浏览器开发者的约束，然后是对开发者的约束。</p>
<h1 id="什么是FOUC（无样式内容闪烁）？你如何来避免FOUC？"><a href="#什么是FOUC（无样式内容闪烁）？你如何来避免FOUC？" class="headerlink" title="什么是FOUC（无样式内容闪烁）？你如何来避免FOUC？"></a>什么是FOUC（无样式内容闪烁）？你如何来避免FOUC？</h1><blockquote>
<p>FOUC(Flash Of Unstyled Content)–文档样式闪烁<br>style type=”text/css”media=”all”&gt;@import”../fouc.css”;&lt; /style&gt;而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文 件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。解决方法简单的出奇，只要在<head>之间加入一个link或者script元素就可以了。</head></p>
</blockquote>
<h1 id="如果网页内容需要支持多语言，你会怎么做？"><a href="#如果网页内容需要支持多语言，你会怎么做？" class="headerlink" title="如果网页内容需要支持多语言，你会怎么做？"></a>如果网页内容需要支持多语言，你会怎么做？</h1><p>下面这些问题需要考虑</p>
<ul>
<li>应用字符集的选择，选择UTF-8编码</li>
<li>语言书写习惯&amp;导航结构</li>
<li>数据库驱动型网站</li>
</ul>
<h1 id="data-属性的作用是什么？"><a href="#data-属性的作用是什么？" class="headerlink" title="data-属性的作用是什么？"></a>data-属性的作用是什么？</h1><ul>
<li><p>data-<em> 属性用于存储页面或应用程序的私有自定义数据。data-</em> 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。存储的（自定义）数据能够被页面的 JavaScript 中利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。</p>
</li>
<li><p>data-* 属性包括两部分：</p>
<ul>
<li>属性名不应该包含任何大写字母，并且在前缀 “data-“ 之后必须有至少一个字符</li>
<li>属性值可以是任意字符串 </li>
</ul>
</li>
</ul>
<h1 id="请描述一下cookies，sessionStorage和localStorage的区别？"><a href="#请描述一下cookies，sessionStorage和localStorage的区别？" class="headerlink" title="请描述一下cookies，sessionStorage和localStorage的区别？"></a>请描述一下cookies，sessionStorage和localStorage的区别？</h1><p>sessionStorage和localStorage是HTML5 Web Storage API提供的，可以方便的在web请求之间保存数 据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。sessionStorage、localStorage、cookie都是在浏 览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念。sessionStorage是在同源的同窗口（或 tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口 后，sessionStorage即被销毁。同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的cookies会 发送到服务器端。其余两个不会。Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每 个域名50个cookie。</p>
<ul>
<li>Firefox每个域名cookie限制为50个。</li>
<li>Opera每个域名cookie限制为30个。</li>
<li>Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。</li>
<li>Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。</li>
<li>InternetExplorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。</li>
</ul>
<h1 id="你最喜欢的图片替换方法是什么，你如何选择使用。"><a href="#你最喜欢的图片替换方法是什么，你如何选择使用。" class="headerlink" title="你最喜欢的图片替换方法是什么，你如何选择使用。"></a>你最喜欢的图片替换方法是什么，你如何选择使用。</h1><pre><code>&lt;h2&gt;&lt;span图片丢这里&gt;&lt;/span&gt;Hello World&lt;/h2&gt;
</code></pre><p>   把span背景设成文字内容，这样又可以保证seo，也有图片的效果在上面。一般都是：alt，title，onerror。</p>
<h1 id="如何视觉隐藏网页内容，只让它们在屏幕阅读器中可用？"><a href="#如何视觉隐藏网页内容，只让它们在屏幕阅读器中可用？" class="headerlink" title="如何视觉隐藏网页内容，只让它们在屏幕阅读器中可用？"></a>如何视觉隐藏网页内容，只让它们在屏幕阅读器中可用？</h1><ul>
<li><p>display:none;的缺陷搜索引擎可能认为被隐藏的文字属于垃圾信息而被忽略屏幕阅读器（是为视觉上有障碍的人设计的读取屏幕内容的程序）会忽略被隐藏的文字。</p>
</li>
<li><p>visibility:hidden;的缺陷这个大家应该比较熟悉就是隐藏的内容会占据他所应该占据物理空间 </p>
</li>
<li><p>overflow:hidden;一个比较合理的方法.texthidden{display:block;/<em>统一转化为块级元素</em> /overflow:hidden;width:0;height:0;}就像上面的一段CSS所展示的方法，将宽度和高度设定为0，然后超过部分隐藏， 就会弥补上述一、二方法中的缺陷，也达到了隐藏内容的目的。</p>
</li>
</ul>
<h1 id="你用过栅格系统吗？如果使用过，你最喜欢哪种？"><a href="#你用过栅格系统吗？如果使用过，你最喜欢哪种？" class="headerlink" title="你用过栅格系统吗？如果使用过，你最喜欢哪种？"></a>你用过栅格系统吗？如果使用过，你最喜欢哪种？</h1><p>比如：Bootstrap，流式栅格系统，<a href="http://960.gs/，栅格系统延续美学。" target="_blank" rel="external">http://960.gs/，栅格系统延续美学。</a></p>
<h1 id="你用过媒体查询，或针对移动端的布局-CSS吗？"><a href="#你用过媒体查询，或针对移动端的布局-CSS吗？" class="headerlink" title="你用过媒体查询，或针对移动端的布局/CSS吗？"></a>你用过媒体查询，或针对移动端的布局/CSS吗？</h1><ul>
<li><p>媒体查询，就是响应式布局。通过不同的媒介类型和条件定义样式表规则。媒介查询让CSS可以更精确作用于不同的媒介类型和同一媒介的不同条件。</p>
</li>
<li><p>语法结构及用法：@media 设备名 only （选取条件） not （选取条件） and（设备选取条件），设备二{sRules}。</p>
</li>
<li><p>示例</p>
</li>
</ul>
<pre><code>/* 当浏览器的可视区域小于980px */
@media screen and （max-width： 980px） {
#wrap {width： 90%; margin:0 auto;}
#content {width： 60%;padding： 5%;}
#sidebar {width： 30%;}
#footer {padding： 8% 5%;margin-bottom： 10px;}
}
/* 当浏览器的可视区域小于650px */
@media screen and （max-width： 650px） {
#header {height： auto;}
#searchform {position： absolute;top： 5px;right： 0;}
#content {width： auto; float： none; margin： 20px 0;}
#sidebar {width： 100%; float： none; margin： 0;}
}
</code></pre><h1 id="你熟悉SVG样式的书写吗？"><a href="#你熟悉SVG样式的书写吗？" class="headerlink" title="你熟悉SVG样式的书写吗？"></a>你熟悉SVG样式的书写吗？</h1><ol>
<li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li>
<li>SVG 用来定义用于网络的基于矢量的图形</li>
<li>SVG 使用 XML 格式定义图形</li>
<li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</li>
<li>SVG 是万维网联盟的标准</li>
<li><p>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;
      &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;
      &lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
          &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot;/&gt;
      &lt;/svg&gt;
</code></pre></li>
</ol>
<h1 id="如何优化网页的打印样式？"><a href="#如何优化网页的打印样式？" class="headerlink" title="如何优化网页的打印样式？"></a>如何优化网页的打印样式？</h1><pre><code>&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; media = &quot;screen&quot; href = &quot;xxx.css&quot;/&gt;
</code></pre><p>   其中media指定的属性就是设备，显示器上就是screen，打印机则是print，电视是tv，投影仪是projection。打印样式示例如下：</p>
<pre><code>&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; media = &quot;print&quot; href = &quot;yyy.css&quot;/&gt;
</code></pre><p>   但打印样式表也应注意以下事项：</p>
<ol>
<li>打印样式表中最好不要用背景图片，因为打印机不能打印CSS中的背景。如要显示图片，请使用html插入到页面中。</li>
<li>最好不要使用像素作为单位，因为打印样式表要打印出来的会是实物，所以建议使用pt和cm。</li>
<li>隐藏掉不必要的内容。（@print div{display:none;}）</li>
<li>打印样式表中最好少用浮动属性，因为它们会消失。如果想要知道打印样式表的效果如何，直接在浏览器上选择打印预览就可以了。</li>
</ol>
<h1 id="如果设计中使用了非标准的字体，你该如何去实现？"><a href="#如果设计中使用了非标准的字体，你该如何去实现？" class="headerlink" title="如果设计中使用了非标准的字体，你该如何去实现？"></a>如果设计中使用了非标准的字体，你该如何去实现？</h1><p>所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。</p>
<p>方法：</p>
<ul>
<li>用图片代替</li>
<li><p>web fonts在线字库，如Google Webfonts，Typekit等等；http://- www.chinaz.com/free/2012/0815/269267.shtml</p>
</li>
<li><p>@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)</p>
</li>
</ul>
<h1 id="解释下浏览器是如何判断元素是否匹配某个CSS选择器？"><a href="#解释下浏览器是如何判断元素是否匹配某个CSS选择器？" class="headerlink" title="解释下浏览器是如何判断元素是否匹配某个CSS选择器？"></a>解释下浏览器是如何判断元素是否匹配某个CSS选择器？</h1><p>从后往前判断。浏览器先产生一个元素集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，如果不符合上一个部分，就把元素从集合中删除，直到真个选择器都匹配完，还在集合中的元素就匹配这个选择器了。举个例子，有选择器：</p>
<pre><code>body.ready#wrapper&gt;.lol233
</code></pre><p>先把所有class中有lol233的元素拿出来组成一个集合，然后上一层，对每一个集合中的元素，如果元素的parent id不 为#wrapper则把元素从集合中删去。再向上，从这个元素的父元素开始向上找，没有找到一个tagName为body且class中有ready的元 素，就把原来的元素从集合中删去。至此这个选择器匹配结束，所有还在集合中的元素满足。大体就是这样，不过浏览器还会有一些奇怪的优化。为什么从后往前匹 配因为效率和文档流的解析方向。效率不必说，找元素的父亲和之前的兄弟比遍历所哟儿子快而且方便。关于文档流的解析方向，是因为现在的CSS，一个元素只 要确定了这个元素在文档流之前出现过的所有元素，就能确定他的匹配情况。应用在即使html没有载入完成，浏览器也能根据已经载入的这一部分信息完全确定 出现过的元素的属性。为什么是用集合主要也还是效率。基于CSS Rule数量远远小于元素数量的假设和索引的运用，遍历每一条CSS Rule通过集合 筛选，比遍历每一个元素再遍历每一条Rule匹配要快得多。</p>
<h1 id="解释一下你对盒模型的理解，以及如何在CSS中告诉浏览器使用不同的盒模型来渲染你的布局。"><a href="#解释一下你对盒模型的理解，以及如何在CSS中告诉浏览器使用不同的盒模型来渲染你的布局。" class="headerlink" title="解释一下你对盒模型的理解，以及如何在CSS中告诉浏览器使用不同的盒模型来渲染你的布局。"></a>解释一下你对盒模型的理解，以及如何在CSS中告诉浏览器使用不同的盒模型来渲染你的布局。</h1><p><a href="http://www.cnblogs.com/syfwhu/p/4319236.html" target="_blank" rel="external">关于盒模型请看文章CSS之布局与定位</a></p>
<h1 id="请解释一下relative、fixed、absolute和static元素的区别？请解释一下inline和inline-block的区别？"><a href="#请解释一下relative、fixed、absolute和static元素的区别？请解释一下inline和inline-block的区别？" class="headerlink" title="请解释一下relative、fixed、absolute和static元素的区别？请解释一下inline和inline-block的区别？"></a>请解释一下relative、fixed、absolute和static元素的区别？请解释一下inline和inline-block的区别？</h1><p><a href="http://www.cnblogs.com/syfwhu/p/4319236.html" target="_blank" rel="external">关于第一个问题请看文章CSS之布局与定位</a></p>
<p><strong>inline:</strong>此元素会被显示为内联元素，元素前后没有换行符。</p>
<p><strong>inline-block:</strong>行内块元素。</p>
<h1 id="解释下事件代理。"><a href="#解释下事件代理。" class="headerlink" title="解释下事件代理。"></a>解释下事件代理。</h1><p>JavaScript事件代理则是一种简单的技巧，通过它你可以把事件处理器添加到一个父级元素上，这样就避免了把事件处理器添加到多个子级元素 上。当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制。事 件代理用到了两个在JavaSciprt事件中常被忽略的特性：事件冒泡以及目标元素。</p>
<pre><code>function getEventTarget(e) {
  e=e||window.event;
  return e.target||e.srcElement;
}
</code></pre><h1 id="AMD-vs-CommonJS？"><a href="#AMD-vs-CommonJS？" class="headerlink" title="AMD vs.CommonJS？"></a>AMD vs.CommonJS？</h1><p><a href="http://www.cnblogs.com/syfwhu/p/4883532.html" target="_blank" rel="external">请看文章JavaScript之模块化编程</a></p>
<h1 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h1><p>散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<h1 id="描述以下变量的区别：null，undefined或undeclared？"><a href="#描述以下变量的区别：null，undefined或undeclared？" class="headerlink" title="描述以下变量的区别：null，undefined或undeclared？"></a>描述以下变量的区别：null，undefined或undeclared？</h1><p>JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</p>
<p>但是，上面这样的区分，在实践中很快就被证明不可行。目前，null和undefined基本是同义的，只有一些细微的差别。</p>
<p>null表示”没有对象”，即该处不应该有值。典型用法是：</p>
<ul>
<li>用来初始化一个变量，这个变量可能被赋值为一个对象。</li>
<li>用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。</li>
<li>当函数的参数期望是对象时，被用作参数传入。</li>
<li>当函数的返回值期望是对象时，被用作返回值传出。</li>
<li>作为对象原型链的终点。</li>
</ul>
<p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<ul>
<li>变量被声明了，但没有赋值时，就等于undefined。</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>
<li>对象没有赋值的属性，该属性的值为undefined。</li>
<li>函数没有返回值时，默认返回undefined。</li>
</ul>
<p>该如何检测它们？</p>
<p>null：表示无值；undefined：表示一个未声明的变量，或已声明但没有赋值的变量，或一个并不存在的对象属性。</p>
<p>==运算符将两者看作相等。如果要区分两者，要使用===或typeof运算符。</p>
<p>以下是不正确的用法：</p>
<pre><code>var exp = undefined;

if (exp == undefined) {
    alert(&quot;undefined&quot;);
}
</code></pre><p>exp为null时，也会得到与undefined相同的结果，虽然null和undefined不一样。注意：要同时判断undefined和null时可使用本法。</p>
<p>typeof返回的是字符串，有六种可能：”number”、”string”、”boolean”、”object”、”function”、”undefined”。</p>
<p>以下是正确的用法：</p>
<pre><code>var exp = undefined;

if(typeof(exp) == undefined) {
    alert(&quot;undefined&quot;);
}
</code></pre><p>JS中如何判断null？</p>
<p>以下是不正确的用法：</p>
<pre><code>var exp = null;

if(exp == null) {
    alert(&quot;is null&quot;);
}
</code></pre><p>exp为undefined时，也会得到与null相同的结果，虽然null和undefined不一样。注意：要同时判断null和undefined时可使用本法。</p>
<pre><code>var exp=null;

if(!exp) {
    alert(&quot;is null&quot;);
}
</code></pre><p>如果exp为undefined或者数字零，也会得到与null相同的结果，虽然null和二者不一样。注意：要同时判断null、undefined和数字零时可使用本法。</p>
<pre><code>var exp = null;

if(typeof(exp) == &quot;null&quot;) {
    alert(&quot;is null&quot;);
}
</code></pre><p>为了向下兼容，exp为null时，typeof总返回object。这种方式也不太好。</p>
<p>以下是正确的用法：</p>
<pre><code>var exp = null;

if(!exp&amp;&amp;typeof(exp) != &quot;undefined&quot; &amp;&amp; exp != 0) {
    alert(&quot;is null&quot;);
}
</code></pre><h1 id="请指出浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别？"><a href="#请指出浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别？" class="headerlink" title="请指出浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别？"></a>请指出浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别？</h1><p><strong>特性检测：</strong>为特定浏览器的特性进行测试，并仅当特性存在时即可应用特性。</p>
<p><strong>User-Agent检测：</strong>最早的浏览器嗅探即用户代理检测，服务端（以及后来的客户端）根据UA字符串屏蔽某些特定的浏览器查看网站内容。</p>
<p><strong>特性推断：</strong>尝试使用多个特性但仅验证了其中之一。根据一个特性的存在推断另一个特性是否存在。问题是，推断是假设并非事实，而且可能导致可维护性的问题。</p>
<h1 id="请尽可能详尽的解释AJAX的工作原理。"><a href="#请尽可能详尽的解释AJAX的工作原理。" class="headerlink" title="请尽可能详尽的解释AJAX的工作原理。"></a>请尽可能详尽的解释AJAX的工作原理。</h1><p><a href="http://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html" target="_blank" rel="external">请参考文章AJAX工作原理</a></p>
<h1 id="请解释JSONP的工作原理，以及它为什么不是真正的AJAX。"><a href="#请解释JSONP的工作原理，以及它为什么不是真正的AJAX。" class="headerlink" title="请解释JSONP的工作原理，以及它为什么不是真正的AJAX。"></a>请解释JSONP的工作原理，以及它为什么不是真正的AJAX。</h1><p>JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的javascript，于是我们可以通过script标 记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA 需要的数据，然后在 pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后 会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行， 那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。</p>
<p>AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！</p>
<h1 id="请描述下事件冒泡机制。"><a href="#请描述下事件冒泡机制。" class="headerlink" title="请描述下事件冒泡机制。"></a>请描述下事件冒泡机制。</h1><p>冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。</p>
<p>捕获型事件：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。</p>
<p>支持W3C标准的浏览器在添加事件时用addEventListener(event,fn,useCapture)方法，基中第3个参数 useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行。而不兼容W3C的浏览器(IE)用 attachEvent()方法，此方法没有相关设置，不过IE的事件模型默认是在事件冒泡时执行的，也就是在useCapture等于false的时候 执行，所以把在处理事件时把useCapture设置为false是比较安全，也实现兼容浏览器的效果。</p>
<p><img src="http://images2015.cnblogs.com/blog/716683/201510/716683-20151013185212819-847014694.jpg" alt=""></p>
<h1 id="请解释-end-的用途。"><a href="#请解释-end-的用途。" class="headerlink" title="请解释.end()的用途。"></a>请解释.end()的用途。</h1><p>在官方的API上是这样描述end()方法的：“回到最近的一个”破坏性”操作之前。即，将匹配的元素列表变为前一次的状态。”；看样子好像是找到最后一次操作的元素的上一元素，在如下的例子中：html代码：</p>
<p>复制代码代码如下:</p>
<pre><code>&lt;div&gt;测试内容1&lt;/div&gt;&lt;div&gt;测试内容2&lt;/div&gt;
</code></pre><p>jQuery代码：</p>
<pre><code>$(&apos;&lt;p&gt;新增内容&lt;/p&gt;&apos;).appendTo(&apos;div&apos;).addClass(&apos;c1&apos;).end().addClass(&apos;c2&apos;);
</code></pre><p>复制代码代码如下:</p>
<pre><code>&lt;div&gt;测试内容1
    &lt;p class=&quot;c1 c2&quot;&gt;新增内容&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;测试内容2
    &lt;p class=&quot;c1&quot;&gt;新增内容&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>这里我就有一点不太明白了，怎么只有第一个</p><p>标签有两个样式，end()方法后返回的是什么,在火狐里添加了监控，得到如下结 果：1.$(‘</p><p>新增内容</p>‘).appendTo(‘div’)返回的是：[p,p]对象数组，即新增后的两个p标 签；2.$(‘<p>新增内容</p>‘).appendTo(‘div’).addClass(‘c1’)返回的是： [p.c1,p.c1]对象数组，即添加了c1类样式后的p对象数组；3.$(‘<p>新增内 容</p>‘).appendTo(‘div’).addClass(‘c1’).end()返回的是[p.c1],是第1 个<div>中的<p>,在2操作中，最后“破坏”的是第2个<div>中的<p>,所以他的前一次操 作的对象是第1个<div>中的<p>,返回的就是它;4.$(‘</p><p>新增内 容</p>‘).appendTo(‘div’).addClass(‘c1’).end().addClass(‘c2’)返回的仍然是第 1个<div>中的<p>;现在算是有点明白了，关键是要搞清楚最后一次操作的元素的上一元素是什么。</p>
<h1 id="你如何给一个事件处理函数命名空间，为什么要这样做？"><a href="#你如何给一个事件处理函数命名空间，为什么要这样做？" class="headerlink" title="你如何给一个事件处理函数命名空间，为什么要这样做？"></a>你如何给一个事件处理函数命名空间，为什么要这样做？</h1><p>任何作为type参数的字符串都是合法的；如果一个字符串不是原生的JavaScript事件名，那么这个事件处理函数会绑定到一个自定义事件上。 这些自定义事件绝对不会由浏览器触发，但可以通过使用.trigger()或者.triggerHandler()在其他代码中手动触发。如果type参 数的字符串中包含一个点(.)字符，那么这个事件就看做是有命名空间的了。这个点字符就用来分隔事件和他的命名空间。举例来说，如果执 行.bind(‘click.name’,handler)，那么字符串中的click是事件类型，而字符串name就是命名空间。命名空间允许我们取消 绑定或者触发一些特定类型的事件，而不用触发别的事件。参考unbind()来获取更多信息。</p>
<p>jQuery的bind/unbind方法应该说使用很简单，而且大多数时候可能并不会用到，取而代之的是直接用click/keydown之类的事件名风格的方法来做事件绑定操作。</p>
<p>但假设如下情况：需要在运行时根据用户交互的结果进行不同click事件处理逻辑的绑定，因而理论上会无数次对某一个事件进行 bind/unbind操作。但又希望unbind的时候只把自己绑上去的处理逻辑给释放掉而不是所有其他地方有可能的额外的同一事件绑定逻辑。这时候如 果直接用.click()/.bind(‘click’)加上.unbind(‘click’)来进行重复绑定的话，被unbind掉的将是所有绑定在元 素上的click处理逻辑，潜在会影响到该元素其他第三方的行为。</p>
<p>当然如果在bind的时候是显示定义了function变量的话，可以在unbind的时候提供function作为第二个参数来指定只 unbind其中一个处理逻辑，但实际应用中很可能会碰到各种进行匿名函数绑定的情况。对于这种问题，jQuery的解决方案是使用事件绑定的命名空间。 即在事件名称后添加.something来区分自己这部分行为逻辑范围。</p>
<p>比如用.bind(‘click.myCustomRoutine’,function(){…});同样是把匿名函数绑定到click事件 （你可以用自己的命名空间多次绑定不同的行为方法上去），当unbind的时候用.unbind(‘click.myCustomRoutine’)即可 释放所有绑定到.myCustomRoutine命名空间的click事件，而不会解除其他通过.bind(‘click’)或另外的命名空间所绑定的事 件行为。同时，使用命令空间还可以让你一次性unbind所有此命名空间下的自定义事件绑定，通 过.unbind(‘.myCustomRoutine’)即可。要注意的是，jQuery的命名空间并不支持多级空间。</p>
<p>因为在jQuery里面，如果用.unbind(‘click.myCustomRoutine.myCustomSubone’)，解除的是命名 空间分别为myCustomRoutine和myCustomSubone的两个并列命名空间下的所有click事件，而不 是”myCustomRoutine下的myCustomSubone子空间”。</p>
</div></div></p></div></p></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/CSS面试题/" itemprop="url">
                  CSS面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T14:37:54+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/H5面试题/" itemprop="url" rel="index">
                    <span itemprop="name">H5面试题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/CSS面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/CSS面试题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="描述下“reset”CSS文件的作用和使用它的好处。"><a href="#描述下“reset”CSS文件的作用和使用它的好处。" class="headerlink" title="描述下“reset”CSS文件的作用和使用它的好处。"></a>描述下“reset”CSS文件的作用和使用它的好处。</h1><p>因为浏览器的品种很多，每个浏览器的默认样式也是不同的，所以定义一个css reset可以使各浏览器的默认样式统一。</p>
<h1 id="解释下浮动和它的工作原理。"><a href="#解释下浮动和它的工作原理。" class="headerlink" title="解释下浮动和它的工作原理。"></a>解释下浮动和它的工作原理。</h1><p>关于浮动我们需要了解，浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。要想使元素浮动，必须为元素设置一个宽度（width）。虽然浮动元素不是文档流之中，但是它浮动后所处的位置依然是在浮动之前的水平方向上。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样，下面的元素填补原来的位置。有些元素会在浮动元素的下方，但是这些元素的内容并不一定会被浮动的元素所遮盖，对内联元素进行定位时，这些元素会考虑浮动元素的边界，会围绕着浮动元素放置。也可以把浮动元素想象成是被块元素忽略的元素，而内联元素会关注浮动元素的。  </p>
<h1 id="列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。"><a href="#列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。" class="headerlink" title="列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。"></a>列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。</h1><ol>
<li><p>使用空标签清除浮动。这种方法是在所有浮动标签后面添加一个空标签定义css clear:both.弊端就是增加了无意义标签。</p>
</li>
<li><p>使用overflow。给包含浮动元素的父标签添加css属性overflow:auto;zoom:1;zoom:1用于兼容IE6。</p>
</li>
<li><p>使用after伪对象清除浮动。该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮 动元素的伪对象中设置height:0，否则该元素会比实际高出若干像素；二、content属性是必须的，但其值可以为空，content属性的值设 为”.”，空亦是可以的。</p>
</li>
<li><p>浮动外部元素</p>
</li>
</ol>
<p><strong>此三种方法各有利弊，使用时应择优选择，比较之下第二种方法更为可取。</strong></p>
<h1 id="解释下CSS-sprites，以及你要如何在页面或网站中使用它。"><a href="#解释下CSS-sprites，以及你要如何在页面或网站中使用它。" class="headerlink" title="解释下CSS sprites，以及你要如何在页面或网站中使用它。"></a>解释下CSS sprites，以及你要如何在页面或网站中使用它。</h1><p>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background- image”，“background-repeat”，“background-position”的组合进行背景定位，background- position可以用数字能精确的定位出背景图片的位置。</p>
<h1 id="讨论CSS-hacks，条件引用或者其他。"><a href="#讨论CSS-hacks，条件引用或者其他。" class="headerlink" title="讨论CSS hacks，条件引用或者其他。"></a>讨论CSS hacks，条件引用或者其他。</h1><pre><code>各个浏览器都认识，这里给firefox用；

background-color:red\9;\9所有的ie浏览器可识别；

background-color:yellow\0;\0是留给ie8的+background-color:pink;+ie7定了；

_background-color:orange;_专门留给神奇的ie6；:root#test{background-color:purple\9;}:root是给ie9的，

@media all and(min-width:0px){#test{background-color:black\0;}}这个是老是跟ie抢着认\0的神奇的opera，必须加个\0,不然firefox，chrome，safari也都认识。

@media screen and(-webkit-min-device-pixel-ratio:0){#test{background-color:gray;}}最后这个是浏览器新贵chrome和safari的。
</code></pre><h1 id="在书写高效CSS时会有哪些问题需要考虑？"><a href="#在书写高效CSS时会有哪些问题需要考虑？" class="headerlink" title="在书写高效CSS时会有哪些问题需要考虑？"></a>在书写高效CSS时会有哪些问题需要考虑？</h1><ol>
<li>样式是：从右向左的解析一个选择器；</li>
<li>ID最快，Universal最慢有四种类型的key selector，解析速度由快到慢依次是：ID、class、tag和universal ；</li>
<li>不要tag-qualify（永远不要这样做ul#main-navigation{}ID已经是唯一的，不需要Tag来标识，这样做会让选择器变慢。）；</li>
<li>后代选择器最糟糕（换句话说，下面这个选择器是很低效的：html body ul li a{}）；</li>
<li>想清楚你为什么这样写；</li>
<li>CSS3的效率问题（CSS3选择器（比如:nth-child）能够漂亮的定位我们想要的元素，又能保证我们的CSS整洁易读。但是这些神奇的选择器会浪费很多的浏览器资源。）；</li>
<li>我们知道#ID速度是最快的，那么我们都用ID，是不是很快。但是我们不应该为了效率而牺牲可读性和可维护性。</li>
</ol>
<h1 id="使用CSS预处理器的优缺点有哪些？"><a href="#使用CSS预处理器的优缺点有哪些？" class="headerlink" title="使用CSS预处理器的优缺点有哪些？"></a>使用CSS预处理器的优缺点有哪些？</h1><ul>
<li><p>LESS&amp;SassLESS是受Sass启发而开发的工具，它列出了如下开发的理由：</p>
<p>  “为什么要开发一个Sass的替代品呢？原因很简单：首先是语法。Sass的一个关键特性是缩进式的语法，这种语法可以产生柱式外观的代码。但是你需要 花费时间学习一门新的语法以及重新构建你现在的样式表。LESS给CSS带来了很多特性，使得LESS能够和CSS无缝地紧密结合在一起。因此，你可以平 滑地由CSS迁移到LESS，如果你只是对使用变量或者操作感兴趣的话，你不需要学习一整门全新的语言。”</p>
</li>
<li><p>StylusStylus相对前两者较新，可以看官方文档介绍的功能。</p>
<ol>
<li>来自NodeJS社区，所以和NodeJS走得很近，与JavaScript联系非常紧密。还有专门JavaScript API：<a href="http://learnboost.github.io/stylus/docs/js.html" target="_blank" rel="external">http://learnboost.github.io/stylus/docs/js.html</a></li>
<li>支持Ruby之类等等框架；</li>
<li>更多更强大的支持和功能总结：Sass看起来在提供的特性上占有优势，但是LESS能够让开发者平滑地从现存CSS文件过渡到LESS，而不需要像Sass那样需要将CSS文件转换成Sass格式。Stylus功能上更为强壮，和js联系更加紧密。</li>
</ol>
</li>
</ul>
<h1 id="请解释一下-box-sizing-border-box-的作用-并且说明使用它有什么好处？"><a href="#请解释一下-box-sizing-border-box-的作用-并且说明使用它有什么好处？" class="headerlink" title="请解释一下*{box-sizing:border-box;}的作用,并且说明使用它有什么好处？"></a>请解释一下*{box-sizing:border-box;}的作用,并且说明使用它有什么好处？</h1><p>说到IE的bug，在IE6以前的版本中，IE对盒模型的解析出现一些问题，跟其它浏览器不同，将border与padding都包含在width之内。而另外一些浏览器则与它相反，是不包括border和padding的。</p>
<p>在我们开发的过程中会发现，有时候，如果对页面中的大区域进行设置时，将border、padding计算到width和height之内，反而更 灵活。但W3C的CSS2.1规范却规定了他们并不能被包含其中。考虑到这个问题，css3中引入了一个新的属性：box-sizing，它具有 “content-box”和”border-box“两个值。</p>
<pre><code>box-sizing:content-box
</code></pre><p>当我们设置box-sizing:content-box;时，浏览器对盒模型的解释遵从我们之前认识到的W3C标准，当它定义width和height时，它的宽度不包括border和padding。</p>
<pre><code>box-sizing:border-box
</code></pre><p>当我们设置box-sizing:border-box;时，浏览器对盒模型的解释与IE6之前的版本相同，当它定义width和height 时，border和padding则是被包含在宽高之内的。内容的宽和高可以通过定义的“width”和“height”减去相应方向的 “padding”和“border”的宽度得到。内容的宽和高必须保证不能为负，必要时将自动增大该元素border box的尺寸以使其内容的宽或高 最小为0。</p>
<h1 id="请罗列出你所知道的display属性的全部值"><a href="#请罗列出你所知道的display属性的全部值" class="headerlink" title="请罗列出你所知道的display属性的全部值"></a>请罗列出你所知道的display属性的全部值</h1><p><img src="http://images2015.cnblogs.com/blog/716683/201510/716683-20151013142822460-1264753317.jpg" alt="jlkjklj"></p>
<h1 id="你目前在使用哪一套CSS框架，或者在产品线上使用过哪一套？"><a href="#你目前在使用哪一套CSS框架，或者在产品线上使用过哪一套？" class="headerlink" title="你目前在使用哪一套CSS框架，或者在产品线上使用过哪一套？"></a>你目前在使用哪一套CSS框架，或者在产品线上使用过哪一套？</h1><p>Bootstrap,PureCSS,Foundation等等</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/JavaScript面试题/" itemprop="url">
                  JavaScript面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T14:37:42+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/H5面试题/" itemprop="url" rel="index">
                    <span itemprop="name">H5面试题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/JavaScript面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/JavaScript面试题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在js中如何判断当前浏览器正在以何种方式解析？"><a href="#在js中如何判断当前浏览器正在以何种方式解析？" class="headerlink" title="在js中如何判断当前浏览器正在以何种方式解析？"></a>在js中如何判断当前浏览器正在以何种方式解析？</h1><p>document对象有个属性compatMode,它有两个值：BackCompat对应quirks mode，CSS1Compat对应strict mode。</p>
<h1 id="解释下JavaScript中this是如何工作的。"><a href="#解释下JavaScript中this是如何工作的。" class="headerlink" title="解释下JavaScript中this是如何工作的。"></a>解释下JavaScript中this是如何工作的。</h1><p>this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。匿名函数或不处于任何对象中的函数指向window 。</p>
<ol>
<li><p>如果是call，apply,with，指定的this是谁，就是谁。</p>
</li>
<li><p>普通的函数调用，函数被谁调用，this就是谁。</p>
</li>
</ol>
<h1 id="解释下原型继承的原理。"><a href="#解释下原型继承的原理。" class="headerlink" title="解释下原型继承的原理。"></a>解释下原型继承的原理。</h1><p>以下代码展示了JS引擎如何查找属性：</p>
<pre><code>function getProperty(obj,prop) {
    if (obj.hasOwnProperty(prop)) {
        return obj[prop];
    } else if (obj.__proto__!==null) {
        return getProperty(obj.__proto__,prop);
    } else {
        return undefined;
    }
}
</code></pre><p><img src="http://images.cnitblog.com/blog2015/716683/201504/171011349018292.jpg" alt=""></p>
<h1 id="什么是闭包，如何使用它，为什么要使用它？"><a href="#什么是闭包，如何使用它，为什么要使用它？" class="headerlink" title="什么是闭包，如何使用它，为什么要使用它？"></a>什么是闭包，如何使用它，为什么要使用它？</h1><p>包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>使用闭包的注意点：</p>
<p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<p><a href="http://www.cnblogs.com/syfwhu/p/4839562.html" target="_blank" rel="external">关于闭包，详细了解请看JavaScript之作用域与闭包详解</a></p>
<h1 id="请举出一个匿名函数的典型用例？"><a href="#请举出一个匿名函数的典型用例？" class="headerlink" title="请举出一个匿名函数的典型用例？"></a>请举出一个匿名函数的典型用例？</h1><p>自执行函数，用闭包模拟私有变量、特权函数等。</p>
<h1 id="解释“JavaScript模块模式”以及你在何时使用它。"><a href="#解释“JavaScript模块模式”以及你在何时使用它。" class="headerlink" title="解释“JavaScript模块模式”以及你在何时使用它。"></a>解释“JavaScript模块模式”以及你在何时使用它。</h1><pre><code>如果有提到无污染的命名空间，可以考虑加分。

如果你的模块没有自己的命名空间会怎么样？
</code></pre><p>请看文章-<a href="http://www.cnblogs.com/syfwhu/p/4883532.html" target="_blank" rel="external">JavaScript之模块化编程</a>和<a href="http://www.cnblogs.com/syfwhu/p/4415586.html" target="_blank" rel="external">JavaScript之命名空间模式 浅析</a></p>
<h1 id="请指出JavaScript宿主对象和原生对象的区别？"><a href="#请指出JavaScript宿主对象和原生对象的区别？" class="headerlink" title="请指出JavaScript宿主对象和原生对象的区别？"></a>请指出JavaScript宿主对象和原生对象的区别？</h1><p><strong>原生对象</strong></p>
<p>ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。</p>
<p>“本地对象”包含哪些内容：Object、Function、Array、String、Boolean、Number、Date、RegExp、 Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、 URIError。</p>
<p>由此可以看出，简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。</p>
<p><strong>内置对象</strong></p>
<p>ECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。</p>
<p>同样是“独立于宿主环境”。根据定义我们似乎很难分清“内置对象”与“本地对象”的区别。而 ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。如此就可以理解了。内置对象是本地对象的一种。</p>
<p><strong>宿主对象</strong></p>
<p>何为“宿主对象”？主要在这个“宿主”的概念上，ECMAScript中的“宿主”当然就是我们网页的运行环境，即“操作系统”和“浏览器”。</p>
<p>所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的BOM和DOM都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象。</p>
<h1 id="call和-apply的区别是什么？"><a href="#call和-apply的区别是什么？" class="headerlink" title="call和.apply的区别是什么？"></a>call和.apply的区别是什么？</h1><p><strong>call方法: </strong></p>
<p>语法：call(thisObj，Object)<br>定义：调用一个对象的一个方法，以另一个对象替换当前对象。<br>说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 </p>
<p><strong>apply方法： </strong><br>语法：apply(thisObj，[argArray])<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象。<br>说 明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p>
<p>对于apply和call两者在作用上是相同的，但两者在参数上有以下区别：<br>对于第一个参数意义都一 样，但对第二个参数：apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开 始）。如 func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1, [var1,var2,var3])同时使用apply的好处是可以直接将当前函数的arguments对象作为apply的第二个参数传入。</p>
<h1 id="你何时优化自己的代码？"><a href="#你何时优化自己的代码？" class="headerlink" title="你何时优化自己的代码？"></a>你何时优化自己的代码？</h1><p>请看文章<a href="http://www.cnblogs.com/syfwhu/p/4438810.html" target="_blank" rel="external">JavaScript之高效编程</a> 及<a href="http://www.cnblogs.com/syfwhu/p/4814435.html" target="_blank" rel="external">JavaScript编码风格指南</a></p>
<h1 id="你能解释一下JavaScript中的继承是如何工作的吗？"><a href="#你能解释一下JavaScript中的继承是如何工作的吗？" class="headerlink" title="你能解释一下JavaScript中的继承是如何工作的吗？"></a>你能解释一下JavaScript中的继承是如何工作的吗？</h1><p> 原型链等。</p>
<h1 id="在什么时候你会使用document-write-？"><a href="#在什么时候你会使用document-write-？" class="headerlink" title="在什么时候你会使用document.write()？"></a>在什么时候你会使用document.write()？</h1><p>大多数生成的广告代码依旧使用document.write()，虽然这种用法会让人很不爽。</p>
<h1 id="请解释变量声明提升。"><a href="#请解释变量声明提升。" class="headerlink" title="请解释变量声明提升。"></a>请解释变量声明提升。</h1><p>在JS里定义的变量，存在于作用域链里，而在函数执行时会先把变量的声明进行提升，仅仅是把声明进行了提升，而其值的定义还在原来位置。示例如下：</p>
<pre><code>var test = function() {
    console.log(name); // 输出：undefined
    var name = &quot;jeri&quot;;
    console.log(name); // 输出：jeri
}

test();
</code></pre><p>上述代码与下述代码等价。</p>
<pre><code>var test = function() {
    var name;
    console.log(name); // 输出：undefined
    name = &quot;jeri&quot;;
    console.log(name); // 输出：jeri
}

test();
</code></pre><p>由以上代码可知，在函数执行时，把变量的声明提升到了函数顶部，而其值定义依然在原来位置。</p>
<h1 id="“attribute”和”property”的区别是什么？"><a href="#“attribute”和”property”的区别是什么？" class="headerlink" title="“attribute”和”property”的区别是什么？"></a>“attribute”和”property”的区别是什么？</h1><ol>
<li><strong>定义</strong></li>
</ol>
<p>Property：属性，所有的HTML元素都由HTMLElement类型表示，HTMLElement类型 直接继承自Element并添加了一些属性，添加的这些属性分别对应于每个HTML元素都有下面的这5个标准特性: id,title,lang,dir,className。DOM节点是一个对象，因此，他可以和其他的JavaScript对象一样添加自定义的属性以 及方法。property的值可以是任何的数据类型，对大小写敏感，自定义的property不会出现在html代码中，只存在js中。</p>
<p>Attribute：特性，区别于property，attribute只能是字符串，大小写不敏感，出现在innerHTML中，通过类数组attributes可以罗列所有的attribute。</p>
<ol>
<li><strong>相同之处</strong></li>
</ol>
<p>标准的 DOM properties 与 attributes 是同步的。公认的（非自定义的）特性会被以属性的形式添加到DOM对象中。如，id，align，style等，这时候操作property或者使用操作 特性的DOM方法如getAttribute()都可以操作属性。不过传递给getAttribute()的特性名与实际的特性名相同。因此对于 class的特性值获取的时候要传入“class”。</p>
<ol>
<li><strong>不同之处</strong></li>
</ol>
<p>1).对于有些标准的特性的操作，getAttribute与点号(.)获取的值存在差异性。如href，src，value，style，onclick等事件处理程序。<br>2).href：getAttribute获取的是href的实际值，而点号获取的是完整的url，存在浏览器差异。</p>
<h1 id="请指出document-onload和document-ready两个事件的区别。"><a href="#请指出document-onload和document-ready两个事件的区别。" class="headerlink" title="请指出document.onload和document.ready两个事件的区别。"></a>请指出document.onload和document.ready两个事件的区别。</h1><p>页面加载完成有两种事件，</p>
<ol>
<li>ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），</li>
<li>onload，指示页面包含图片等文件在内的所有元素都加载完成。</li>
</ol>
<h1 id="和-有什么不同？"><a href="#和-有什么不同？" class="headerlink" title="==和===有什么不同？"></a>==和===有什么不同？</h1><p>首先，== equality 等同，=== identity 恒等。 ==， 两边值类型不同的时候，要先进行类型转换，再比较。 ===，不做类型转换，类型不同的一定不等。</p>
<p>先说 ===，这个比较简单。下面的规则用来判断两个值是否===相等： </p>
<ol>
<li>如果类型不同，就[不相等] </li>
<li>如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断） </li>
<li>如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。 </li>
<li>如果两个值都是true，或者都是false，那么[相等]。 </li>
<li>如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。 </li>
<li>如果两个值都是null，或者都是undefined，那么[相等]。 </li>
</ol>
<p>再说 ==，根据以下规则： </p>
<p>如果两个值类型相同，进行 === 比较。<br>如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： </p>
<ol>
<li>如果一个是null、一个是undefined，那么[相等]。 </li>
<li>如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 </li>
<li>如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 </li>
<li>如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方 法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。非js核心的对象，令说（比 较麻烦，我也不大懂） </li>
<li>任何其他组合，都[不相等]。 </li>
</ol>
<h1 id="你如何从浏览器的URL中获取查询字符串参数。"><a href="#你如何从浏览器的URL中获取查询字符串参数。" class="headerlink" title="你如何从浏览器的URL中获取查询字符串参数。"></a>你如何从浏览器的URL中获取查询字符串参数。</h1><p>以下函数把获取一个key的参数。</p>
<pre><code>function parseQueryString ( name ){
    name = name.replace(/[\[]/,&quot;\\\[&quot;);
    var regexS = &quot;[\\?&amp;]&quot;+name+&quot;=([^&amp;#]*)&quot;;
    var regex = new RegExp( regexS );
    var results = regex.exec( window.location.href );

    if(results == null) {
        return &quot;&quot;;
    } else { 
        return results[1];
    }
}
</code></pre><h1 id="请解释一下JavaScript的同源策略。"><a href="#请解释一下JavaScript的同源策略。" class="headerlink" title="请解释一下JavaScript的同源策略。"></a>请解释一下JavaScript的同源策略。</h1><p>在客户端编程语言中，如javascript和 ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚 本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的 HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。</p>
<h1 id="请描述一下JavaScript的继承模式"><a href="#请描述一下JavaScript的继承模式" class="headerlink" title="请描述一下JavaScript的继承模式"></a>请描述一下JavaScript的继承模式</h1><p> <a href="http://www.cnblogs.com/syfwhu/p/4415586.html" target="_blank" rel="external">关于继承请看文章JavaScript之对象的继承</a></p>
<h1 id="什么是三元表达式？“三元”表示什么意思？"><a href="#什么是三元表达式？“三元”表示什么意思？" class="headerlink" title="什么是三元表达式？“三元”表示什么意思？"></a>什么是三元表达式？“三元”表示什么意思？</h1><p>三元表达式：? :。三元–三个操作对象。</p>
<p>在表达式boolean-exp ? value0 : value1 中，如果“布尔表达式”的结果为true，就计算“value0”，而且这个计算结果也就是操作符最终产生的值。如果“布尔表达式”的结果为false， 就计算“value1”，同样，它的结果也就成为了操作符最终产生的值。</p>
<h1 id="JavaScript里函数参数arguments是数组吗？"><a href="#JavaScript里函数参数arguments是数组吗？" class="headerlink" title="JavaScript里函数参数arguments是数组吗？"></a>JavaScript里函数参数arguments是数组吗？</h1><p>在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，通过使用下标就可以访问相应的参数。</p>
<p>arguments虽然有一些数组的性质，但其并非真正的数组，只是一个类数组对象。其并没有数组的很多方法，不能像真正的数组那样调用.jion(),.concat(),.pop()等方法。</p>
<h1 id="什么是”use-strict”-使用它的好处和坏处分别是什么？"><a href="#什么是”use-strict”-使用它的好处和坏处分别是什么？" class="headerlink" title="什么是”use strict”;?使用它的好处和坏处分别是什么？"></a>什么是”use strict”;?使用它的好处和坏处分别是什么？</h1><p>在代码中出现表达式-“use strict”; 意味着代码按照严格模式解析，这种模式使得Javascript在更严格的条件下运行。</p>
<p>好处：</p>
<ul>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>
</ul>
<p>坏处：</p>
<p>同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。</p>
<h1 id="解释”chaining”。"><a href="#解释”chaining”。" class="headerlink" title="解释”chaining”。"></a>解释”chaining”。</h1><p>jQuery方法链接。直到现在，我们都是一次写一条jQuery语句（一条接着另一条）。不过，有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条jQuery命令，一条接着另一条。</p>
<p>提示：这样的话，浏览器就不必多次查找相同的元素。</p>
<p>如需链接一个动作，您只需简单地把该动作追加到之前的动作上。</p>
<h1 id="解释”deferreds”。"><a href="#解释”deferreds”。" class="headerlink" title="解释”deferreds”。"></a>解释”deferreds”。</h1><p>开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。</p>
<p>通常的做法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。</p>
<p>但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了deferred对象。</p>
<p>简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行</p>
<h1 id="你知道哪些针对jQuery的优化方法？"><a href="#你知道哪些针对jQuery的优化方法？" class="headerlink" title="你知道哪些针对jQuery的优化方法？"></a>你知道哪些针对jQuery的优化方法？</h1><h2 id="1-总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById-方法。"><a href="#1-总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById-方法。" class="headerlink" title="1. 总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById()方法。"></a>1. 总是从ID选择器开始继承在jQuery中最快的选择器是ID选择器，因为它直接来自于JavaScript的getElementById()方法。</h2><p>例如有一段HTML代码：</p>
<pre><code>&lt;div id=&quot;content&quot;&gt;
    &lt;form method=&quot;post&quot;action=&quot;#&quot;&gt;
        &lt;h2&gt;交通信号灯&lt;/h2&gt;
        &lt;ul id=&quot;traffic_light&quot;&gt;
            &lt;li&gt;
                &lt;input type=&quot;radio&quot;class=&quot;on&quot;name=&quot;light&quot;value=&quot;red&quot;/&gt;红色
            &lt;/li&gt;
            &lt;li&gt;
                &lt;input type=&quot;radio&quot;class=&quot;off&quot;name=&quot;light&quot;value=&quot;yellow&quot;/&gt;黄色
            &lt;/li&gt;
            &lt;li&gt;
                &lt;input type=&quot;radio&quot;class=&quot;off&quot;name=&quot;light&quot;value=&quot;green&quot;/&gt;绿色
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;input class=&quot;button&quot;id=&quot;traffic_button&quot;type=&quot;submit&quot;value=&quot;Go&quot;/&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre><p>比如需要选择红绿单选框，那么可以使用一个tag name来限制(修饰)class，如下所 示：var active_light=$(“input.on”);当然也可以结合就近的ID，如下所 示：var active_light=$(“#traffic_light input.on”);  如果采用下面的选择器，那么效率是低效的。var traffic_button=$(“#content.button”);因为button已经有 ID了，我们可以直接使用ID选择器。如下所示：var traffic_button=$(“#traffic_button”);当然这只是对于单一 的元素来讲。如果你需要选择多个元素，这必然会涉及到DOM遍历和循环，为了提高性能，建议从最近的ID开始继承。如下所示：</p>
<pre><code>var traffic_lights=$(“#traffic_light input”); 
</code></pre><h2 id="2-在class前使用tag-标签名-在jQuery中第二快的选择器是tag-标签-选择器-比如：-“head”"><a href="#2-在class前使用tag-标签名-在jQuery中第二快的选择器是tag-标签-选择器-比如：-“head”" class="headerlink" title="2. 在class前使用tag(标签名)在jQuery中第二快的选择器是tag(标签)选择器(比如：$(“head”))"></a>2. 在class前使用tag(标签名)在jQuery中第二快的选择器是tag(标签)选择器(比如：$(“head”))</h2><p>跟ID选择器累时，因为它来自原生的getElementsByTagName()方法。继续看刚才那段HTML代码：</p>
<p>在使用tag来修饰class的时候，我们需要注意以下几点：</p>
<pre><code>（1）不要使用tag来修饰ID，如下所 示：var content=$(“div#content”);这样一来，选择器会先遍历所有的div元素，然后匹配#content。（好像 jQuery从1.3.1开始改变了选择器核心后，不存在这个问题了。暂时无法考证。）
（2）不要画蛇添足的使用ID来修饰ID，如下所 示：var traffic_light=$(“#content#traffic_light”);
</code></pre><h2 id="3-将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。"><a href="#3-将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。" class="headerlink" title="3. 将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。"></a>3. 将jQuery对象缓存起来把jQuery对象缓存起来就是要告诉我们要养成将jQuery对象缓存进变量的习惯。</h2><p>下面是一个jQuery新手写的一段代码：</p>
<pre><code>$(&quot;#traffic_light input.on&quot;).bind(&quot;click&quot;,function(){});
$(&quot;#traffic_light input.on&quot;).css(&quot;border&quot;,&quot;1px dashed yellow&quot;);
$(&quot;#traffic_light input.on&quot;).css(&quot;background-color&quot;,&quot;orange&quot;);
$(&quot;#traffic_light input.on&quot;).fadeIn(&quot;slow&quot;);
</code></pre><p>但切记不要这么做。我们应该先将对象缓存进一个变量然后再操作，如下所示：</p>
<p>记住，永远不要让相同的选择器在你的代码里出现多次.注：</p>
<pre><code>（1）为了区分普通的JavaScript对象和jQuery对象，可以在变量首字母前加上$符号。
（2）上面代码可以使用jQuery的链式操作加以改善。如下所示：


     var $active_light = $(&quot;#traffic_light input.on&quot;);

     $active_light.bind(&quot;click&quot;,function(){})
     .css(&quot;border&quot;,&quot;1px dashed yellow&quot;)
     .css(&quot;background-color&quot;,&quot;orange&quot;)
     .fadeIn(&quot;slow&quot;);
</code></pre><h2 id="4-如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。"><a href="#4-如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。" class="headerlink" title="4. 如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。"></a>4. 如果你打算在其他函数中使用jQuery对象，那么你必须把它们缓存到全局环境中。</h2><p>如下代码所示：</p>
<pre><code>// 在全局范围定义一个对象(例如:window对象)
window.$my = {
    head:$(&quot;head&quot;),
    trafficLight:$(&quot;#trafficLight&quot;),
    trafficButton:$(&quot;#trafficButton&quot;)
};

function doSomething(){
    // 现在你可以引用存储的结果并操作它们
    var script=document.createElement(&quot;script&quot;);
    $my.head.append(script);

    // 当你在函数内部操作是,可以继续将查询存入全局对象中去.
    $my.coolResults=$(&quot;#some_ul li&quot;);
    $my.otherResults=$(&quot;#some_table td&quot;);

    // 将全局函数作为一个普通的jquery对象去使用.
    $my.otherResults.css(&quot;border-color&quot;,&quot;red&quot;);
    $my.trafficLight.css(&quot;border-color&quot;,&quot;green&quot;);
}
// 你也可以在其他函数中使用它.
</code></pre><p>这里的基本思想是在内存中建立你确实想要的东西，然后更新DOM。这并不是一个jQuery最佳实践，但必须进行有效的JavaScript操作。直接的DOM操作速度很慢。例如，你想动态的创建一组列表元素，千万不要这样做,如下所示：对直接的DOM操作进行限制。</p>
<pre><code>var top_100_list = [];// 假设这里是100个独一无二的字符串
var $mylist = $(&quot;#mylist&quot;);// jQuery选择到&lt;ul&gt;元素

for(var i = 0,l = top_100_list.length;i&lt;l;i++) {
    $mylist.append(&quot;&lt;li&gt;&quot; + top_100_list[i] + &quot;&lt;/li&gt;&quot;);
}
</code></pre><p>我们应该将整套元素字符串在插入进dom中之前先全部创建好，如下所示：</p>
<pre><code>$(&quot;#entryform input&quot;).bind(&quot;focus&quot;,function() {
    $(this).addClass(&quot;selected&quot;);
}).bind(&quot;blur&quot;,function(){
    $(this).removeClass(&quot;selected&quot;);
});
</code></pre><h2 id="5-冒泡除非在特殊情况下-否则每一个js事件-例如-click-mouseover等-都会冒泡到父级节点。"><a href="#5-冒泡除非在特殊情况下-否则每一个js事件-例如-click-mouseover等-都会冒泡到父级节点。" class="headerlink" title="5. 冒泡除非在特殊情况下,否则每一个js事件(例如:click,mouseover等.)都会冒泡到父级节点。"></a>5. 冒泡除非在特殊情况下,否则每一个js事件(例如:click,mouseover等.)都会冒泡到父级节点。</h2><p>当我们需要给多个元素调用同个函数时这点会很有用。代替这种效率很差的多元素事件监听的方法就是,你只需向它们的父节点绑定一次。比如,我们要为一 个拥有很多输入框的表单绑定这样的行为:当输入框被选中时为它添加一个class传统的做法是，直接选中input，然后绑定focus等，如下所示：</p>
<pre><code>$(&quot;#entryform&quot;).bind(&quot;focus&quot;,function(e) {
    var $cell = $(e.target); // e.target捕捉到触发的目标元素
    $cell.addClass(&quot;selected&quot;);
}).bind(&quot;blur&quot;,function(e) {
    var $cell = $(e.target);
    $cell.removeClass(&quot;selected&quot;);
});
</code></pre><p>当然上面代码能帮我们完成相应的任务，但如果你要寻求更高效的方法，请使用如下代码：</p>
<p>通过在父级监听获取焦点和失去焦点的事件，对目标元素进行操作。在上面代码中，父级元素扮演了一个调度员的角色,它可以基于目标元素绑定事件。如果你发现你给很多元素绑定了同一个事件监听,那么现在的你肯定知道哪里做错了。</p>
<h2 id="6-推迟到-window-load。"><a href="#6-推迟到-window-load。" class="headerlink" title="6. 推迟到$(window).load。"></a>6. 推迟到$(window).load。</h2><p>jQuery对于开发者来说有一个很诱人的东西,可以把任何东西挂到$(document).ready下。尽管$(document).rady 确实很有用，它可以在页面渲染时，其它元素还没下载完成就执行。如果你发现你的页面一直是载入中的状态，很有可能就是$(document).ready 函数引起的。你可以通过将jQuery函数绑定到$(window).load事件的方法来减少页面载入时的cpu使用率。它会在所有的html(包括 iframe)被下载完成后执行。一些特效的功能，例如拖放,视觉特效和动画,预载入隐藏图像等等，都是适合这种技术的场合。</p>
<h2 id="7-压缩JavaScript。"><a href="#7-压缩JavaScript。" class="headerlink" title="7. 压缩JavaScript。"></a>7. 压缩JavaScript。</h2><p>在线压缩地址:<a href="http://dean.edwards.name/packer/" target="_blank" rel="external">http://dean.edwards.name/packer/</a> 压缩之前，请保证你的代码的规范性，否则可能失败，导致Js错误。</p>
<h2 id="8-尽量使用ID代替Class。"><a href="#8-尽量使用ID代替Class。" class="headerlink" title="8. 尽量使用ID代替Class。"></a>8. 尽量使用ID代替Class。</h2><p> 前面性能优化已经说过，ID选择器的速度是最快的。所以在HTML代码中，能使用ID的尽量使用ID来代替class。看下面的一个例子：</p>
<pre><code>// 创建一个list
var $myList = $(&apos;#myList&apos;);
var myListItems = &apos;&lt;ul&gt;&apos;;

for(var i = 0; i &lt; 1000; i ++) {
    myListItems += &apos;&lt;li class = &quot;listItem&apos;+i+&apos;&quot;&gt;This is a list item&lt;/li&gt;&apos;;
    // 这里使用的是class
}

myListItems += &apos;&lt;/ul&gt;&apos;;
$myList.html(myListItems);
// 选择每一个li

for(var i = 0; i&lt;1000; i++) {
    var selectedItem = $(&apos;.listItem&apos; + i);
}
</code></pre><p>在上段代码中，选择每个li总共只用了61毫秒，相比class的方式，将近快了100倍。       在代码最后，选择每个li的过程中，总共用了5066毫秒，超过5秒了。接着我们做一个对比，用ID代替class：</p>
<h2 id="9-给选择器一个上下文。"><a href="#9-给选择器一个上下文。" class="headerlink" title="9. 给选择器一个上下文。"></a>9. 给选择器一个上下文。</h2><p>jQuery选择器中有一个这样的选择器，它能指定上下文。jQuery(expression,context);通过它，能缩小选择器在DOM 中搜索的范围，达到节省时间，提高效率。普通方式：$(‘.myDiv’)改进方式：$(‘.myDiv’,$(“#listItem”))。</p>
<h2 id="10-慎用-live-方法（应该说尽量不要使用）。"><a href="#10-慎用-live-方法（应该说尽量不要使用）。" class="headerlink" title="10. 慎用.live()方法（应该说尽量不要使用）。"></a>10. 慎用.live()方法（应该说尽量不要使用）。</h2><p>这是jQuery1.3.1版本之后增加的方法，这个方法的功能就是为新增的DOM元素动态绑定事件。但对于效率来说，这个方法比较占用资源。所以请尽量不要使用它。例如有这么一段代码:</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    $(function(){

        $(&quot;p&quot;).click(function(){
            alert($(this).text());
        });

        $(&quot;button&quot;).click(function(){
            $(&quot;&lt;p&gt;this is second p&lt;/p&gt;&quot;).appendTo(&quot;body&quot;);
        });
    })
&lt;/script&gt;
&lt;body&gt;
    &lt;p&gt;this is first p&lt;/p&gt;
    &lt;button&gt;add&lt;/button&gt;
&lt;/body&gt;
</code></pre><p>运行后，你会发现新增的p元素，并没用被绑定click事件。你可以改成.live(“click”)方式解决此问题，代码如下：</p>
<pre><code>$(function() {
    $(&quot;p&quot;).live(&quot;click&quot;,function() {
        // 改成live方式
        alert($(this).text());
    });

    $(&quot;button&quot;).click(function() {
        $(&quot;&lt;p&gt;this is second p&lt;/p&gt;&quot;).appendTo(&quot;body&quot;);
    });
})
</code></pre><p>但我并不建议大家这么做，我想用另一种方式去解决这个问题，代码如下：</p>
<pre><code>$(function() {
    $(&quot;p&quot;).click(function() {
        alert($(this).text());
    });

    $(&quot;button&quot;).click(function() {
        $(&quot;&lt;p&gt;this is second p&lt;/p&gt;&quot;).click(function() {
            // 为新增的元素重新绑定一次
            alert($(this).text());
        }).appendTo(&quot;body&quot;);
    });
})
</code></pre><p>虽然我把绑定事件重新写了一次，代码多了点，但这种方式的效率明显高于live()方式，特别是在频繁的DOM操作中，这点非常明显。</p>
<h1 id="请说出你可以传递给jQuery方法的四种不同值。"><a href="#请说出你可以传递给jQuery方法的四种不同值。" class="headerlink" title="请说出你可以传递给jQuery方法的四种不同值。"></a>请说出你可以传递给jQuery方法的四种不同值。</h1><p>选择器（字符串），HTML（字符串），回调函数，HTML元素，对象，数组，元素数组，jQuery对象等。</p>
<h1 id="什么是效果队列？"><a href="#什么是效果队列？" class="headerlink" title="什么是效果队列？"></a>什么是效果队列？</h1><p>jQuery中有个动画队列的机制。当我们对一个对象添加多次动画效果时后添加的动作就会被放入这个动画队列中，等前面的动画完成后再开始执行。可 是用户的操作往往都比动画快，如果用户对一个对象频繁操作时不处理动画队列就会造成队列堆积，影响到效果。jQuery中有stop这个方法可以停止当前 执行的动画，并且它有两个布尔参数，默认值都为false。第一个参数为true时会清空动画队列，第二个参数为true时会瞬间完成掉当前动画。所以， 我们经常使用obj.stop(true,true)来停止动画。但是这还不够！正如jQuery文档中的说法，即使第二个参数为true，也仅仅是把当 前在执行的动画跳转到完成状态。这时第一个参数如果也为true，后面的队列就会被清空。如果一个效果需要多个动画同时处理，我们仅完成其中的一个而把后 面的队列丢弃了，这就会出现意料之外的结果。</p>
<h1 id="请指出-get-，-，eq-的区别。"><a href="#请指出-get-，-，eq-的区别。" class="headerlink" title="请指出.get()，[]，eq()的区别。"></a>请指出.get()，[]，eq()的区别。</h1><p><strong>eq:</strong> 返回是一个jquery对象作用是将匹配的元素集合缩减为一个元素。这个元素在匹配元素集合中的位置变为0，而集合长度变成1。</p>
<p><strong>get:</strong> 是一个html对象数组作用是取得其中一个匹配的元素。num表示取得第几个匹配的元素。</p>
<h1 id="请指出-bind-，-live-和-delegate-的区别。"><a href="#请指出-bind-，-live-和-delegate-的区别。" class="headerlink" title="请指出.bind()，.live()和.delegate()的区别。"></a>请指出.bind()，.live()和.delegate()的区别。</h1><p>在操纵DOM的语境中，document是根节点。现在我们可以较容易地说明.bind()、.live()和.delegate()的不同之处了。</p>
<p><strong>.bind()</strong></p>
<pre><code>$(&apos;a&apos;).bind(&apos;click&apos;, function() {alert(&quot;That tickles!&quot;)});
</code></pre><p>这是最简单的绑定方法了。JQuery扫描文档找出所有的$(‘a’)元素，并把alert函数绑定到每个元素的click事件上。</p>
<p><strong>.live()</strong></p>
<pre><code>$(&apos;a&apos;).live(&apos;click&apos;, function() {alert(&quot;That tickles!&quot;)});
</code></pre><p>JQuery把alert函数绑定到$(document)元素上，并使用’click’和’a’作为参数。任何时候只要有事件冒泡到 document节点上，它就查看该事件是否是一个click事件，以及该事件的目标元素与’a’这一CSS选择器是否匹配，如果都是的话，则执行函数。</p>
<p>live方法还可以被绑定到具体的元素(或context)而不是document上，像这样：</p>
<pre><code>$(&apos;a&apos;, $(&apos;#container&apos;)[0]).live(...);
</code></pre><p><strong>.delegate()</strong></p>
<pre><code>$(&apos;#container&apos;).delegate(&apos;a&apos;, &apos;click&apos;, function() {alert(&quot;That tickles!&quot;)});
</code></pre><p>JQuery扫描文档查找$(‘#container’)，并使用click事件和’a’这一CSS选择器作为参数把alert函数绑定 到$(‘#container’)上。任何时候只要有事件冒泡到$(‘#container’)上，它就查看该事件是否是click事件，以及该事件的目 标元素是否与CCS选择器相匹配。如果两种检查的结果都为真的话，它就执行函数。</p>
<p>可以注意到，这一过程与.live()类似，但是其把处理程序绑定到具体的元素而非document这一根上。精明的JS’er们可能会做出这样的结论，即$(‘a’).live()==$(document).delegate(‘a’)，是这样吗?嗯，不，不完全是。</p>
<p>为什么.delegate()要比.live()好用？</p>
<p>基于几个原因，人们通常更愿意选用jQuery的delegate方法而不是live方法。考虑下面的例子：</p>
<pre><code>$(&apos;a&apos;).live(&apos;click&apos;, function(){blah()}); // 或者
$(document).delegate(&apos;a&apos;, &apos;click&apos;, function(){blah()});
</code></pre><p><strong>速度</strong></p>
<p>后者实际上要快过前者，因为前者首先要扫描整个的文档查找所有的$(‘a’)元素，把它们存成jQuery对象。尽管live函数仅需要把’a’作 为串参数传递以用做之后的判断，但是$()函数并未知道被链接的方法将会是.live()。而另一方面，delegate方法仅需要查找并存 储$(document)元素。</p>
<p>一种寻求避开这一问题的方法是调用在$(document).ready()之外绑定的live，这样它就会立即执行。在这种方式下，其会在DOM获得填充之前运行，因此就不会查找元素或是创建jQuery对象了。</p>
<p><strong>灵活性和链能力</strong></p>
<p>live函数也挺令人费解的。想想看，它被链到$(‘a’)对象集上，但其实际上是在$(document)对象上发生作用。由于这个原因，它能够 试图以一种吓死人的方式来把方法链到自身上。实际上，我想说的是，以$.live(‘a’,…)这一形式作为一种全局性的jQuery方法，live方法 会更具意义一些。</p>
<p><strong>仅支持CSS选择器</strong></p>
<p>最后一点，live方法有一个非常大的缺点，那就是它仅能针对直接的CSS选择器做操作，这使得它变得非常的不灵活。</p>
<p>为什么选择.live()或.delegate()而不是.bind()？<br>毕竟，bind看起来似乎更加的明确和直接，难道不是吗?嗯，有两个原因让我们更愿意选择delegate或live而不是bind：</p>
<p>为了把处理程序附加到可能还未存在于DOM中的DOM元素之上。因为bind是直接把处理程序绑定到各个元素上，它不能把处理程序绑定到还未存在于页面中的元素之上。</p>
<p>如果你运行了$(‘a’).bind(…)，而后新的链接经由AJAX加入到了页面中，则你的bind处理程序对于这些新加入的链接来说是无效的。 而另一方面live和delegate则是被绑定到另一个祖先节点上，因此其对于任何目前或是将来存在于该祖先元素之内的元素都是有效的。</p>
<p>或者为了把处理程序附加到单个元素上或是一小组元素之上，监听后代元素上的事件而不是循环遍历并把同一个函数逐个附加到DOM中的100个元素上。把处理程序附加到一个(或是一小组)祖先元素上而不是直接把处理程序附加到页面中的所有元素上，这种做法带来了性能上的好处。</p>
<p><strong>停止传播</strong></p>
<p>最后一个我想做的提醒与事件传播有关。通常情况下，我们可以通过使用这样的事件方法来终止处理函数的执行：</p>
<pre><code>$(&apos;a&apos;).bind(&apos;click&apos;, function(e) {
    e.preventDefault();
    // 或者 e.stopPropagation();
});
</code></pre><p>不过，当我们使用live或是delegate方法的时候，处理函数实际上并没有在运行，需要等到事件冒泡到处理程序实际绑定的元素上时函数才会运行。而到此时为止，我们的其他的来自.bind()的处理函数早已运行了。</p>
<h1 id="请指出-和-fn的区别，或者说出-fn的用途。"><a href="#请指出-和-fn的区别，或者说出-fn的用途。" class="headerlink" title="请指出$和$.fn的区别，或者说出$.fn的用途。"></a>请指出$和$.fn的区别，或者说出$.fn的用途。</h1><p>Jquery为开发插件提供了两个方法，分别是：</p>
<pre><code>$.extend(obj);
$.fn.extend(obj);
</code></pre><p>1.那么这两个分别是什么意思？</p>
<pre><code>$.extend(obj);是为了扩展jquery本身，为类添加新的方法。

$.fn.extend(obj);给JQUERY对象添加方法。
</code></pre><p>2.$.fn中的fn是什么意思，其实是prototype，即$.fn=$.prototype;<br>具体用法请看下面的例子：</p>
<pre><code>$.extend({

    add:function(a, b) {
        return a+b;
    }
})

$.add(5,8); // return 13
</code></pre><p>注意没有，这边的调用直接调用，前面不用任何对象。直接$.+方法名</p>
<p>$.fn.extend(obj)；对prototype进行扩展，为jquery类添加成员函数，jquery类的实例可以使用这个成员函数。</p>
<pre><code>$.fn.extend({

    clickwhile:function(){

        $(this).click(function(){
            alert($(this).val())
        })
    }
})

$(&apos;input&apos;).clickwhile(); // 当点击输入框会弹出该对象的Value值
</code></pre><p>注意调用时候前面是有对象的。即$(‘input’)这么个东西。</p>
<h1 id="var-foo-foo-push-1-foo-push-2-问题：foo-length的值是什么？"><a href="#var-foo-foo-push-1-foo-push-2-问题：foo-length的值是什么？" class="headerlink" title="var foo=[];foo.push(1);foo.push(2);问题：foo.length的值是什么？"></a>var foo=[];foo.push(1);foo.push(2);问题：foo.length的值是什么？</h1><p> 答案：2</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/HTML面试题/" itemprop="url">
                  HTML面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T11:06:38+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/H5面试题/" itemprop="url" rel="index">
                    <span itemprop="name">H5面试题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/HTML面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/HTML面试题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTML和XHTML有什么区别？"><a href="#HTML和XHTML有什么区别？" class="headerlink" title="HTML和XHTML有什么区别？"></a>HTML和XHTML有什么区别？</h1><h2 id="XHTML-HTML"><a href="#XHTML-HTML" class="headerlink" title="XHTML,HTML"></a>XHTML,HTML</h2><p>   XHTML 与 HTML 4.01 标准没有太多的不同， XHTML1.0 是 XML 风格的 HTML4.01 ,标签的规范更加严格 , W3C一直是推崇XHTML这种严格类型的语法, 但是 XHTML 从 1.0 升级到了 1.1 以后就夭折了。</p>
<h2 id="html和xhtml最主要的不同："><a href="#html和xhtml最主要的不同：" class="headerlink" title="html和xhtml最主要的不同："></a>html和xhtml最主要的不同：</h2><ul>
<li><p>XHTML 元素必须被正确地嵌套。</p>
<pre><code>错误：&lt;Head&gt;&lt;/Head&gt;&lt;Body&gt;&lt;/Body&gt;
正确：&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;
</code></pre></li>
<li><p>XHTML 元素必须被关闭。</p>
<pre><code>错误：&lt;p&gt;xxxx
正确: &lt;p&gt;xxxx&lt;/p&gt;
</code></pre></li>
<li><p>标签名必须用小写字母。</p>
<pre><code>错误：&lt;Div&gt;&lt;/diV&gt;
正确：&lt;div&gt;&lt;/div&gt;
</code></pre></li>
<li><p>XHTML 文档必须拥有根元素。</p>
</li>
<li><p>其他</p>
<p>  不允许使用target=”_blank”</p>
<p>  从XHTML 1.1开始全面禁止target属性，如果想要有开新窗口的功能，就必须改写为rel=”external”，并搭配JavaScript实现此效果。</p>
<pre><code>错误：&lt;a href=&quot;http://blog.mukispace.com&quot; target=&quot;_blank&quot;&gt;MUKI space&lt;/a&gt;

正确：&lt;a href=&quot;http://blog.mukispace.com&quot; rel=&quot;external&quot;&gt;MUKI space&lt;/a&gt;
</code></pre></li>
</ul>
<h1 id="如果页面使用-‘application-xhtml-xml’-会有什么问题吗？"><a href="#如果页面使用-‘application-xhtml-xml’-会有什么问题吗？" class="headerlink" title="如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗？"></a>如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗？</h1><p>一些老的浏览器不支持，实际上，任何最新的浏览器都将支持application/xhtml+xml媒体类型。大多数浏览器也接受以application/xml发送的XHTML文档。</p>
<h1 id="doctype（文档类型）的作用是什么？你知道多少种文档类型？"><a href="#doctype（文档类型）的作用是什么？你知道多少种文档类型？" class="headerlink" title="doctype（文档类型）的作用是什么？你知道多少种文档类型？"></a>doctype（文档类型）的作用是什么？你知道多少种文档类型？</h1><ul>
<li><p>此标签可告知浏览器文档使用哪种HTML或XHTML规范。该标签可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的HTML文档。</p>
</li>
<li><p>HTML 4.01规定了三种文档类型：Strict、Transitional以及Frameset。</p>
</li>
<li><p>XHTML 1.0规定了三种XML文档类型：Strict、Transitional以及Frameset。</p>
</li>
<li><p>Standards（标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>
</li>
</ul>
<h1 id="浏览器标准模式和怪异模式之间的区别是什么？"><a href="#浏览器标准模式和怪异模式之间的区别是什么？" class="headerlink" title="浏览器标准模式和怪异模式之间的区别是什么？"></a>浏览器标准模式和怪异模式之间的区别是什么？</h1><p>W3C标准推出以后，浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编 写的，如果用的标准来渲染，将导致页面显示异常。为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的IE）。 这样浏览器渲染上就产生了Quircks mode和Standars mode，两种渲染方法共存在一个浏览器上。IE盒子模型和标准W3C盒子模 型：ie的width包括：padding\border。标准的width不包括：padding\border</p>
<h1 id="使用XHTML的局限有哪些？"><a href="#使用XHTML的局限有哪些？" class="headerlink" title="使用XHTML的局限有哪些？"></a>使用XHTML的局限有哪些？</h1><p>XHTML 与HTML的区别为：</p>
<p>XHTML 元素必须被正确地嵌套。<br>XHTML 元素必须被关闭。<br>标签名必须用小写字母。<br>XHTML 文档必须拥有根元素。<br>局限：</p>
<p>所有的 XHTML 元素都必须被正确地嵌套，XHTML 必须拥有良好的结构，所有的标签必须小写，并且所有的 XHTML 元素必须被关闭。所有的 XHTML 文档必须拥有 DOCTYPE 声明，并且 html、head、title 和 body 元素必须存在。虽然代码更加的优雅，但缺少容错性，不利于快速开发。</p>
<h1 id="如果把HTML5看作做一个开放平台，那它的构建模块有哪些？"><a href="#如果把HTML5看作做一个开放平台，那它的构建模块有哪些？" class="headerlink" title="如果把HTML5看作做一个开放平台，那它的构建模块有哪些？"></a>如果把HTML5看作做一个开放平台，那它的构建模块有哪些？</h1><p><nav>,<header>,<section>,<footer>等。</footer></section></header></nav></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/多线程理论部分/" itemprop="url">
                  多线程理论部分
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T10:33:06+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/多线程理论部分/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/多线程理论部分/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><p>线程是用来执行任务的，线程彻底执行完任务A才能去执行任务B。为了同时执行两个任务，产生了多线程。</p>
</li>
<li><p>我打开一个视频软件，我开辟一个线程A让它执行下载任务，我开辟一个线程B，用来播放视频。我开辟两个线程后，这两个任务能同时执行，如果我开辟一个线程，只有下载任务完成，才能去执行播放任务。</p>
</li>
<li><p>线程相当于店里的服务员，一个服务员同时只能做一件事情，多顾几个服务员，就能同时做很多事情。</p>
</li>
</ul>
<h1 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li><p>进程是应用程序的执行实例,简单来说就是在操作系统中<code>运行的</code>程序。例如我在手机上只打开QQ和微信这两个软件，系统中就会有两个进程存在。</p>
</li>
<li><p>进程不能执行任务</p>
</li>
<li><p>进程在运行时创建的资源随着进程的终止而死亡。</p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>进程本身是不能执行任务的,进程想要执行任务必须的有线程,线程是进程内部的一个独立的执行单元，同时只能执行一个任务，相当于一个子程序。线程被分为两种,<code>主线程</code>(用户界面线程)和<code>子线程</code>(工作线程或称为后台线程)。我在望京(操作系统)开了一个橘子产品体验店(进程)，里面有很多工作人员，有店长帮我布置门面(主线程)，咨询人员(子线程)、销售人员(子线程)。</li>
</ul>
<ul>
<li><p>线程执行完毕就会被销毁。</p>
</li>
<li><p><strong><em>主线程(也称父线程)</em></strong>：当应用程序启动时自动创建和启动，通常用来处理用户的输入并响应各种事件和消息。主线程的终止也意味着该程序的结束。</p>
</li>
<li><p><strong><em>子线程</em></strong>：由主线程来创建,用来帮助主线程执行程序的后台处理任务。如果子线程A中又创建一个子线程B，在创建之后，这两者就是相互独立的，多个子线程之间<code>效果上</code>可以同时执行。</p>
</li>
<li><p>一个进程中可以有多个线程，并且所有线程都在该进程的虚拟地址空间中，可以使用进程的全局变量和系统资源。</p>
</li>
<li><p>线程状态：<a href="http://blog.csdn.net/peter_teng/article/details/10197785" target="_blank" rel="external">线程的五种状态</a></p>
</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li><p>目前大多数的app,都需要连接服务器，而访问服务器的速度可能快也可能很慢。如果一个app访问服务器的操作没有在子线程操作的话，在该app访问服务器的过程中，该软件是不能响应用户的操作的，只有该app访问结束以后，app才能响应用户的操作，这就造成线程阻塞，也就是我们常见的卡顿现象。一条线程在同一时间内只能执行一个任务,但是进程可以有多条线程。可以开启多条线程来执行不同的任务,从而提高程序的执行效率，避免线程阻塞。  </p>
</li>
<li><p>操作系统会根据线程的优先级(线程的优先级可以手动设置)来安排CPU的时间，优先级高的线程，优先调用的几率会更大，同级的话，看线程执行的先后。</p>
</li>
<li><p>同一时间内，CPU只能处理一条线程，只有一条线程在工作。多线程并行执行，其实就是各个线程不断切换，因为执行切换的时间很快很快，就造成了同时执行的假象，原理如下，比如A，B两个线程；</p>
<ol>
<li><p>A执行到某一时间段要切换了，可A任务没完成，系统就会把A当前执行的位置和数据以入栈的方式保存起来</p>
</li>
<li><p>然后B线程执行，B执行时间到了，它的位置状态等也会被系统保存到B的栈中。</p>
</li>
<li><p>系统自动找到A的栈，将A之前保存的数据恢复，又可以从A之前断开的状态继续执行下去，如此循环</p>
</li>
</ol>
<ul>
<li>系统每开一个线程都有比较大的开销。若线程开的过多，不仅会占用大量内存和让程序变得更加复杂，而且会加重CPU的负担，这样的软件，会使你的手机在冬天变成暖手宝。</li>
</ul>
</li>
</ul>
<h1 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h1><ul>
<li>提高程序执行效率，避免线程阻塞造成的卡顿现象。</li>
<li><p>能适当提高资源利用率(CPU,内存)。</p>
</li>
<li><p><strong>不可滥用多线程</strong>：</p>
<ol>
<li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB，可以自己设置内存大小，但必须是4的倍数），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>
<li>线程越多，CPU在调度线程上的开销就越大</li>
<li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li>
</ol>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><strong>线程与进程的关系</strong><ol>
<li>线程是CPU执行任务的基本单位，一个进程可以有多个线程，但同时只能执行一个任务。</li>
<li>进程就是运行中的软件，是动态的。</li>
<li>一个操作系统可以对应多个进程,一个进程可以有多条线程,但至少有一个线程</li>
<li>同一个进程内的线程共享进程里的资源</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>主线程</strong></p>
<ol>
<li>进程一启动就自动创建</li>
<li>显示和刷新UI界面</li>
<li>处理UI事件</li>
</ol>
</li>
<li><p><strong>子线程的作用</strong> </p>
<ol>
<li>处理耗时的操作</li>
<li>子线程不能用来刷新UI</li>
</ol>
</li>
</ul>
<h1 id="三种多线程编程技术"><a href="#三种多线程编程技术" class="headerlink" title="三种多线程编程技术"></a>三种多线程编程技术</h1><h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><ul>
<li><p>NSThread是轻量级的多线程开发，使用并不复杂，但使用NSThread需要自己管理线程的声明周期。</p>
</li>
<li><p><a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSThread/" target="_blank" rel="external">NSThread详解</a></p>
</li>
</ul>
<h2 id="Cocoa-NSOperation"><a href="#Cocoa-NSOperation" class="headerlink" title="Cocoa NSOperation"></a>Cocoa NSOperation</h2><ul>
<li><p>使用NSOperation和NSOperationQueue进行多线程开发类似于线程池，只要将一个NSOperation(实际开发中需要使用其子类NSInvocationOperation、NSBlockOperation)放到NSOperationQueue这个队列中线程就会依次启动。NSOperationQueue负责管理、执行所有的NSOperation，在这个过程中可以更加容易管理线程总数和控制线程之间的依赖关系。</p>
</li>
<li><p>NSOperation有两常用子类用于创建线程操作：NSInvocationOperation和NSBlockOperation，两种方式本质没有区别，但后者使用block形式进行代码组织，使用相对方便。</p>
</li>
<li><p><a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSOperation/" target="_blank" rel="external">NSOperation详解</a></p>
</li>
</ul>
<h2 id="GCD-Grand-Central-Dispatch"><a href="#GCD-Grand-Central-Dispatch" class="headerlink" title="GCD(Grand Central Dispatch)"></a>GCD(Grand Central Dispatch)</h2><ul>
<li><p>GCD是基于C语言开发的一套多线程开发机制，也是目前苹果官网推荐的多线程开发方法。</p>
</li>
<li><p>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程），程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</p>
</li>
<li><p>GCD是这三种多线程开发方式中抽象层次最高的，使用起来也是最为方便的，只是基于C语言开发，并不像前两种是面向对象开发，而是完全面向过程的。这种机制相比较于前面两种多线程开发方式最显著的优点就是<code>它对于多核运算更加有效，会自动利用更多的CPU内核(比如双核、四核)</code>。</p>
</li>
<li><p>GCD中也有一个类似于NSOperationQueue的队列，GCD统一管理整个队列中的任务。但是GCD中的队列分为并行队列和串行队列两类：         </p>
<blockquote>
<p>串行队列：只有一个线程，加入到队列中的操作按添加顺序依次执行。<br>并发队列：有多个线程，操作进来以后他会将这些线程安排在可用的处理器上，同时保证先进来的任务优先处理。</p>
<p>其实在GCD中还有一个特殊队列就是主队列，用来执行主线程上的操作任务。</p>
</blockquote>
</li>
</ul>
<ul>
<li><a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BGCD/" target="_blank" rel="external">GCD详解</a></li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><p>无论使用哪种方法进行多线程开发，每个线程启动后并不一定立即执行相应的操作，具体什么时候由系统调度（CPU空闲时就会执行）</p>
</li>
<li><p>更新UI应该在主线程（UI线程）中进行，并且推荐使用同步调用，常用的方法如下：</p>
<pre><code>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait 

- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL) wait;方法传递主线程[NSThread mainThread])

[[NSOperationQueue mainQueue] addOperationWithBlock:^{}];

dispatch_sync(dispatch_get_main_queue(), ^{})  
</code></pre></li>
</ul>
<ul>
<li><p>NSThread适合轻量级多线程开发，控制线程顺序比较难，同时线程总数无法控制（每次创建并不能重用之前的线程，只能创建一个新的线程）。</p>
</li>
<li><p>对于简单的多线程开发建议使用NSObject的扩展方法完成，而不必使用NSThread。</p>
</li>
<li><p>可以使用NSThread的currentThread方法取得当前线程，使用 sleepForTimeInterval:方法让当前线程休眠。</p>
</li>
<li><p>NSOperation进行多线程开发可以控制线程总数及线程依赖关系。</p>
</li>
<li><p>创建一个NSOperation不应该直接调用start方法（如果直接start则会在主线程中调用）而是应该放到NSOperationQueue中启动。</p>
</li>
<li><p>相比NSInvocationOperation推荐使用NSBlockOperation，代码简单，同时由于闭包性使它没有传参问题。</p>
</li>
<li><p>NSOperation是对GCD面向对象的ObjC封装，但是相比GCD基于C语言开发，效率却更高，建议如果任务之间有依赖关系或者想要监听任务完成状态的情况下优先选择NSOperation否则使用GCD。</p>
</li>
<li><p>在GCD中串行队列中的任务被安排到一个单一线程执行（不是主线程），可以方便地控制执行顺序；并发队列在多个线程中执行（前提是使用异步方法），顺序控制相对复杂，但是更高效。</p>
</li>
<li><p>在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并行队列并且使用异步方法执行时才能在多个线程中执行（如果是并行队列使用同步方法调用则会在主线程中执行）。</p>
</li>
<li><p>相比使用NSLock，@synchronized更加简单，推荐使用后者。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/02/多线程NSThread/" itemprop="url">
                  多线程NSThread
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-02T10:16:55+08:00" content="2016-09-02">
              2016-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/02/多线程NSThread/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/02/多线程NSThread/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 这篇文章主要讲NSThread的使用，相关博客如下：<br> <a href="https://wangliguang.github.io/2016/09/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/" target="_blank" rel="external">iOS开发之多线程理论部分</a><br> <a href="https://wangliguang.github.io/2016/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSOperation/" target="_blank" rel="external">NSOperation</a></p>
<h1 id="什么是NSThread"><a href="#什么是NSThread" class="headerlink" title="什么是NSThread"></a>什么是NSThread</h1><p>NSThread是轻量级的多线程开发，使用并不复杂，但使用NSThread需要自己管理线程的生命周期。</p>
<h1 id="使用NSThread开辟线程的两种方式"><a href="#使用NSThread开辟线程的两种方式" class="headerlink" title="使用NSThread开辟线程的两种方式"></a>使用NSThread开辟线程的两种方式</h1><ol>
<li>创建并手动开启线程<pre><code>NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(compete) object:nil];   
[thread start];
</code></pre></li>
<li>创建并自动开启线程<pre><code>[NSThread detachNewThreadSelector:@selector(compete) toTarget:self withObject:nil];
</code></pre></li>
</ol>
<h1 id="NSThread的常用方法"><a href="#NSThread的常用方法" class="headerlink" title="NSThread的常用方法"></a>NSThread的常用方法</h1><ol>
<li><p><strong>判断当前进程是否是多线程</strong></p>
<pre><code>BOOL isMultiThread = [NSThread isMultiThreaded];
</code></pre></li>
<li><p><strong>获取当前线程对象</strong></p>
<pre><code>//输出当前线程的信息
NSLog(@&quot;当前所在的线程=%@&quot;,[NSThread currentThread]);
</code></pre><p>控制台</p>
<blockquote>
<p>NSThread[10433:1182963] viewDidLoad 方法所在的线程=<nsthread: 0x7fca98507b10="">{number = 1, name = main}</nsthread:></p>
<p><strong>number = 1 ： 线程的编号，由系统设置，主线程的编号为1</strong><br><strong>name = main：指当前所在的线程的名字叫做main,可以自己设置，主线程的名字默认是main，其他线程如果不给他设置名字默认是nil。</strong></p>
</blockquote>
</li>
<li><p><strong>使当前线程睡眠指定的时间，单位为秒</strong></p>
<pre><code>//这句代码在哪个线程执行就让哪个线程睡眠。
[NSThread sleepForTimeInterval:2];
</code></pre><p><strong>线程一旦休眠就进入阻塞状态，就是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。</strong></p>
</li>
<li><p><strong>设置线程的优先级</strong></p>
<pre><code>//取值范围(0.0~1.0),默认为0.5,取值越大,优先级越大。
thread.threadPriority = 1.0;
</code></pre></li>
<li><p><strong>判断当前线程是否为主线程</strong></p>
<pre><code>[NSThread isMainThread];
</code></pre></li>
<li><p><strong>给线程设置名字</strong></p>
<pre><code>[thread setName:@&quot;线程名字&quot;]; 
</code></pre></li>
<li><p><strong>NSThread对象可知的三种状态</strong></p>
<pre><code>isExecuting：是否正在执行，只读
isFinished：是否已经完成，只读
isCancellled：是否已经取消，可通过[thread cancel]手动设置，线程取消意味着该线程处于准备退出状态，但不会影响线程的运行。
</code></pre></li>
<li><strong>退出当前线程</strong><pre><code>//线程退出前，必须要要，该线程之后的代码将不在执行
if (thread.isCancelled == YES) {
    [NSThread exit];
}
</code></pre></li>
</ol>
<h1 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h1><h2 id="使用多线程加载一张url图片"><a href="#使用多线程加载一张url图片" class="headerlink" title="使用多线程加载一张url图片"></a>使用多线程加载一张url图片</h2><ol>
<li>在self.view上放一个UIImageView试图</li>
<li>开辟一条子线程</li>
<li>在<code>子线程</code>中将url图片转成image对象</li>
<li>回到<code>主线程</code></li>
<li><p>在主线程中将image对象给UIImageView试图</p>
<pre><code>//
//  ViewController.m
//  NSThread
//
//  Created by GG on 16/2/18.
//  Copyright © 2016年 GG. All rights reserved.
//

#import &quot;ViewController.h&quot;

#define kUrl @&quot;http://store.storeimages.cdn-apple.com/8748/as-images.apple.com/is/image/AppleInc/aos/published/images/s/38/s38ga/rdgd/s38ga-rdgd-sel-201601?wid=848&amp;hei=848&amp;fmt=jpeg&amp;qlt=80&amp;op_sharpen=0&amp;resMode=bicub&amp;op_usm=0.5,0.5,0,0&amp;iccEmbed=0&amp;layer=comp&amp;.v=1454777389943&quot;

@interface ViewController ()
{
    UIImageView *imageView;
}

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    /*
     * 1、在self.view上放一个UIImageView试图
     */
    imageView = [[UIImageView alloc]initWithFrame:CGRectMake(50, 50, 200, 200)];
    [self.view addSubview:imageView];

    /*
     * 2、 开辟一条子线程(我这里采用创建并手动开启线程的方式)

     * target: 信息发送者

     * selector: 方法选择器选择一个方法

     * object: 如果上面选择的方法有参数，则object便是这个方法的参数

     */
    NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(downloadImage:) object:kUrl];

    //给线程起名字
    thread.name = @&quot;子线程&quot;;

    // 开启线程
    [thread start];

}

/*
 * 3、 在`子线程`中将url图片转成image对象

 *  downloadImage该方法的参数取决于创建线程时传给object的参数

 */
- (void)downloadImage:(NSString *)url{

    //将图片的url地址转化为data对象
    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:kUrl]];

    //将data对象转化为image对象
    UIImage *image = [UIImage imageWithData:data];

    /* 
     * 4. 是NSObject的一个方法，用来回到主线程

     * 方法updataUI将在主线程中执行

     * withObject:updateUI的参数

     * waitUntilDone: 设为YES，会阻塞当前子线程，去主线程执行updateUI方法，也就是更新UI，直到UI更新完毕。设为NO,意味着在主线程updateUI方法执行到一半时可能会被打断去做其他线程的工作，也就是说我主线程的UI还没有显示完就程序就跳出了主线程。
     */
    [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];

    /*

     * 查看打印结果

     * number = 1 ：线程的编号，由系统设置，主线程的编号为1

     * name = main：指当前所在的线程的名字叫做main,可以自己设置，主线程的名字默认是main，其他线程如果不给他设置名字默认是nil

     */
    NSLog(@&quot;downlaodImage方法所在的线程 = %@&quot;,[NSThread currentThread]);

            }

/*
 * 5、 在主线程中将image对象给UIImageView试图
 */

- (void)updateUI:(UIImage *)image{

    imageView.image = image;

    NSLog(@&quot;downlaodImage方法所在的线程 = %@&quot;,[NSThread currentThread]);

}

@end
</code></pre></li>
</ol>
<h2 id="使用多线程加载多张图片"><a href="#使用多线程加载多张图片" class="headerlink" title="使用多线程加载多张图片"></a>使用多线程加载多张图片</h2><ol>
<li>在self.view上放多个UIImageView试图</li>
<li>开辟多条子线程</li>
<li>在<code>子线程</code>中将url图片转成image对象</li>
<li>回到<code>主线程</code></li>
<li><p>在主线程中将image对象给UIImageView试图</p>
<pre><code>//
//  MoreImageViewViewController.m
//  NSThread
//
//  Created by GG on 16/2/22.
//  Copyright © 2016年 GG. All rights reserved.
//

#pragma mark ------------------NSThread分析详解 http://www.jianshu.com/p/b1c2bd572e81-------------

#import &quot;MoreImageViewViewController.h&quot;

#define kUrl @&quot;http://store.storeimages.cdn-apple.com/8748/as-images.apple.com/is/image/AppleInc/aos/published/images/s/38/s38ga/rdgd/s38ga-rdgd-sel-201601?wid=848&amp;hei=848&amp;fmt=jpeg&amp;qlt=80&amp;op_sharpen=0&amp;resMode=bicub&amp;op_usm=0.5,0.5,0,0&amp;iccEmbed=0&amp;layer=comp&amp;.v=1454777389943&quot;

@interface MoreImageViewViewController ()
{
    int imageIndex;

    NSMutableArray *threadArrays;

    UIImage *image;
}

@end

@implementation MoreImageViewViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    UILabel *lable = [[UILabel alloc]initWithFrame:CGRectMake(100, 300, 0, 0)];
    lable.text = @&quot;点击屏幕停止加载&quot;;
    lable.textColor = [UIColor blackColor];
    [lable sizeToFit];
    [self.view addSubview:lable];

    //创建多个UIImageView
    self.title = @&quot;多线程加载多张图片&quot;;
    self.edgesForExtendedLayout = UIRectEdgeNone;
    self.view.backgroundColor = [UIColor whiteColor];

    imageIndex = 100;

    for (int  row= 0; row&lt;3; row++) {
        for (int list = 0; list&lt;2; list++) {

            UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(10+list*200, 10+row*200, 200, 200)];

            imageView.tag = imageIndex++;

            [self.view addSubview:imageView];

        }
    }

    threadArrays = [NSMutableArray array];

    //创建多个线程
    for (int index = 0; index&lt;6; index++) {
        //此时我传的参数是线程创建的顺序
        NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(downloadImage:) object:@(index)];

        //给线程设置优先级（0-1），优先级越高，被优先调用的几率越高。
//        thread.threadPriority = index/10.0;
        thread.name = [NSString stringWithFormat:@&quot;线程%d&quot;,index];
        [thread start];

        [threadArrays addObject:thread];

    }
}

//每条线程都会走这个方法，来下载相应的图片，在这里为了方便起见，我采用了同一个url图片
- (void)downloadImage:(NSNumber *)index{

    /*

     * 通过线程的休眠来实现图片的顺序加载

        1. 第一个线程，休眠0秒，第二个线程休眠1秒...第六个线程休眠5面

        2. 正常的流程如下（基于线程同时执行的原理，多线程理论部分有介绍到）

           1. 多线程开启，并在线程中写上线程休眠代码
           2. 线程执行到休眠代码，停止执行
           3. 点击屏幕，将为完成的线程设为取消状态
           4. 休眠结束，线程进行判断是否被取消，被取消就退出

        3. 错误流程

           1. 多线程开启，并在线程中写上线程休眠代码
           2. 线程进行判断是否被取消，被取消就退出
           3. 线程执行到休眠代码，停止执行
           4. 点击屏幕，将为完成的线程设为取消状态
           5. 休眠结束，继续执行线程

     */
    [NSThread sleepForTimeInterval:[index integerValue]];

    NSThread *currentThread = [NSThread currentThread];
    //如果当前线程处于取消状态，则退出当前线程
    if (currentThread.isCancelled) {
        NSLog(@&quot;thread(%@) will be cancelled!&quot;,currentThread);
        [NSThread exit];//退出当前线程
    }

    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:kUrl]];

    image = [UIImage imageWithData:data];

    //用index找到相应线程的数据，赋给相应的图片试图。
    [self performSelectorOnMainThread:@selector(updateUI:) withObject:index waitUntilDone:YES];

    NSThread *thread = [NSThread currentThread];
    NSLog(@&quot;当前线程是 = %@&quot;,thread.name);

}

- (void)updateUI:(NSNumber *)ktest{

        UIImageView *imageView = [self.view viewWithTag:100+[ktest integerValue]];

        imageView.image = image;

}

//点击屏幕将没有完成的线程设置为取消状态
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{

    for (int i=0; i&lt;6; i++) {
        NSThread *thread= threadArrays[i];
        //判断线程是否完成，如果没有完成则设置为取消状态
        //注意设置为取消状态仅仅是改变了线程状态而言，并不能终止线程
        if (!thread.isFinished) {
            [thread cancel];

            NSLog(@&quot;============&quot;);

        }
    }

}

@end
</code></pre><p>顺序启动的线程一般不会按照启动顺序执行，这是因为线程都创建好以后，CPU会根据实际情况（网速、启动时间、优先级等）来决定执行线程的先后顺序，<strong>在这里我采用线程sleep的方式实现了线程的顺序执行。</strong></p>
</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p> 为了简化多线程开发过程，苹果官方对NSObject进行分类扩展(本质还是创建NSThread)，对于简单的多线程操作可以直接使用这些扩展方法。</p>
<pre><code>//在后台执行一个操作，本质就是重新创建一个线程执行当前方法。
- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg：

//在指定的线程上执行一个方法，需要用户创建一个线程对象。
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait：

//在主线程上执行一个方法（前面已经使用过）。
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait：
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://i1.buimg.com/8311/e0cc1a1fed3a4bda.jpg"
               alt="涅槃广广" />
          <p class="site-author-name" itemprop="name">涅槃广广</p>
          <p class="site-description motion-element" itemprop="description">说不定世界上根本就没有偶然，就如一切都是必然那样</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">27</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wangliguang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5987686599/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">涅槃广广</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"gg-ios"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
